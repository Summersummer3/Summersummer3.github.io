[{"content":"A useless security engineer/cn:帅华\n工作经历\n字节跳动：移动安全风控工程师，专注反自动化\n华为: 硬件安全与移动安全工程师，TEE/HSM/渗透测试/安全启动 都做过点\n学习经历\n日本筑波大学，社会工学，硕士: 差分隐私研究\n中南大学，计算机科学与技术，本科: 瞎玩儿\n","description":"","id":2,"section":"","tags":null,"title":"About Techsum","uri":"https://summersummer3.github.io/about/"},{"content":"背景 由于很多headless浏览器的webgl信息比较明显，如果源站尝试采集webgl参数会暴露自动化工具的特征，所以黑产攻击中需要去欺骗webgl的信息上报。\n目前在github上可以找到一个spoof webgl的项目，star数并不多，但其思路应该是比较主流的hook webgl相关接口的方式。本文主要对该工具的使用和源码进行分析。\n这份代码并不完美，甚至能找到几处bug，但不妨碍我们学习其思想；github地址：https://github.com/siejqa/spoofHeadless\n背景知识简单介绍 Webgl和参数采集 简单来说webgl就是浏览器给前端js代码调用的渲染绘图API，该API可以在在html canvas元素中使用，可以调用到硬件进行加速，所以webgl的参数通常与硬件强相关。更具体的介绍和教程可以参考：https://www.w3cschool.cn/webgl/i4gf1oh1.html\n具体采集webgl的参数时，需要首先先获取canvas下的webgl Context，使用getContext接口。而采集具体参数是使用getParameter函数完成，getParameter接受一个整数，每个整数对应一个属性；以获取GPU型号为例：\n1 2 3 4 5  // 获取webgl context var gl = document.createElement(\u0026#34;canvas\u0026#34;).getContext(\u0026#34;webgl\u0026#34;) // 采集GPU render：编号为37446 gl.getExtension(\u0026#34;WEBGL_debug_renderer_info\u0026#34;)[\u0026#34;UNMASKED_RENDERER_WEBGL\u0026#34;] gl.getParameter(37446)   完整的getParameter常量表可以参考：https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\nWebdriver webdriver本质上是浏览器根据w3c实现的一套操作浏览器的接口，而每个浏览器都有一个特定的 WebDriver 实现，如chrome webdriver：https://chromedriver.chromium.org/downloads\n而目前比较广义的定义（或者说黑产使用的方式），通常是指puppeteer/selenium这类，集成了多种浏览器，并提供高级api供上层应用调用的自动化工具；可以直接使用python(selenium)和nodejs(puppeteer)来编写脚本，完成webdriver的控制，从而完成浏览器上的自动化操作。相关资料可以自行搜索学习。\nSpoofWebGL使用方法 此处介绍如何在selenium使用SpoofWebGL工具，当然该工具简单改造后可以在所有的webdriver上使用。\n 将项目clone下来之后，使用可以看到src文件夹下有两个文件，其中manifest.json是extension的配置文件，injected是源码。   之后用zip命令将src文件夹打包：zip -rj extension.zip src/ 将zip后缀名改成.crx(chrome extension的后缀名) ：mv extension.zip extension.crx 编写webdriver脚本如下（注意要先安装好selenium和chrome webdriver），去观察我们的webgl参数读取情况（注意原项目中使用的是firefox的webdriver，所以脚本要做修改）：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver opt = webdriver.ChromeOptions() extension_path = \u0026#39;./extension.crx\u0026#39; opt.add_extension(extension_path) driver = webdriver.Chrome(options=opt) # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   可以看到这个vendor和render已经不太正常了；\n 作为对比，注释掉options直接启动，会显示本机的真实GPU：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver # opt = webdriver.ChromeOptions() #  # extension_path = \u0026#39;./extension.crx\u0026#39; # opt.add_extension(extension_path) driver = webdriver.Chrome() # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   注：此处是使用浏览器界面模式打开的，实际上如果是启动headless模式，该renderer会和本机的有差别，这也是为什么要使用spoof webgl的原因\n源码分析 总结来说，该extension是将webgl相关的接口全部进行了hook，本质技术难度上并不大，且可以很容易进行定制化。下面开始对hook方法进行分析\nwebdriver相关绕过 开始的第一部分跟webgl检测关系不大，主要是用defineProperty方法对navigator下一些字段进行了hook，绕过webdriver相关的一些检测；主要是设置上浏览器语言，以及将Navigator.webdriver置为false：\n1 2 3 4 5 6 7 8 9 10  Object.defineProperty(navigator, \u0026#39;languages\u0026#39;, { get: function () { var availableLanguages = Array(\u0026#39;en\u0026#39;, \u0026#39;pl\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;ru\u0026#39;, \u0026#39;fr\u0026#39;, \u0026#39;fr-fr\u0026#39;, \u0026#39;lb\u0026#39;, \u0026#39;no\u0026#39;) return [\u0026#39;en-US\u0026#39;, get_random_item(availableLanguages)]; }, }); // fake webdriver property (headless has it as true) Object.defineProperty(navigator, \u0026#39;webdriver\u0026#39;, { get: () =\u0026gt; false, });   WebGL Hook 根据上文中webgl调用示例可知调用webgl接口采集参数主要分为三步：\n 使用getContext获取webgl Context 使用context.getExtension获取webgl拓展的编号 使用context.getParameter获取具体参数的值  对应步骤我们查看该脚本的hook方法：\nHTMLCanvasElement.getContext Hook 要hook该方法，我们需要先定义一个类，如下：\n1 2 3 4 5  function WebGLRenderingContext(canvas) { this.canvas = canvas; this.drawingBufferWidth = canvas.width; this.drawingBufferHeight = canvas.height; };   之后将WebGLRenderingContext中的基本属性和方法进行初始化，即对Object.prototype.attribute进行赋值一个空函数。注意，基础属性本质上都是一些编号，如上文中的例子一样，他是用来传入getParameter做入参的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 原webgl Context中的基本方法集合 var functions = [ \u0026#39;viewport\u0026#39;, \u0026#39;vertexAttribPointer\u0026#39;, \u0026#39;vertexAttrib4fv\u0026#39;, \u0026#39;vertexAttrib4f\u0026#39;, \u0026#39;vertexAttrib3fv\u0026#39;, ... ] // 原webgl Context中的基本属性集合，这里挑选一些经常被收集的作为例子 var enumerates = { ... \u0026#39;VERSION\u0026#39;: 7938, ... \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446, ... \u0026#39;DEPTH_BITS\u0026#39;: 3414, \u0026#39;GREEN_BITS\u0026#39;: 3411, \u0026#39;BLUE_BITS\u0026#39;: 3412, ... \u0026#39;STENCIL_BITS\u0026#39;: 3415, ... \u0026#39;MAX_VERTEX_UNIFORM_VECTORS\u0026#39;: 36347, \u0026#39;MAX_VERTEX_TEXTURE_IMAGE_UNITS\u0026#39;: 35660, \u0026#39;MAX_VERTEX_ATTRIBS\u0026#39;: 34921, \u0026#39;MAX_VARYING_VECTORS\u0026#39;: 36348, \u0026#39;MAX_TEXTURE_SIZE\u0026#39;: 3379, \u0026#39;MAX_TEXTURE_IMAGE_UNITS\u0026#39;: 34930, \u0026#39;MAX_RENDERBUFFER_SIZE\u0026#39;: 34024, \u0026#39;MAX_FRAGMENT_UNIFORM_VECTORS\u0026#39;: 36349, \u0026#39;MAX_CUBE_MAP_TEXTURE_SIZE\u0026#39;: 34076, \u0026#39;MAX_COMBINED_TEXTURE_IMAGE_UNITS\u0026#39;: 35661, ... }; // 将原本的函数全部替换成空函数 functions.forEach(function (func) { WebGLRenderingContext.prototype[func] = function () { return {}; }; }); Object.keys(enumerates).forEach(function (key) { WebGLRenderingContext.prototype[key] = enumerates[key]; });   实际上原脚本之后马上对context.getExtension完成了赋值，那此处其实顺序不影响执行结果，所以我们留在下一节描述。\n进入hook的代码，实际上document.createElement(\u0026ldquo;canvas\u0026rdquo;).getContext(\u0026quot;webgl\u0026quot;)调用到的是HTMLCanvasElement.getContext方法，所以对该方法进行Hook：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  try { const getContext = HTMLCanvasElement.prototype.getContext; // 利用重定义HTMLCanvasElement.prototype.getContext完成Hook，是常见的hook方法  HTMLCanvasElement.prototype.getContext = function () { // 获取第一个入参，通常为\u0026#34;webgl\u0026#34;，\u0026#39;webgl-experimental\u0026#39;等  var name = arguments[0]; console.log(\u0026#34;HTMLCanvasElement app requested extension: \u0026#34; + name); console.log(JSON.stringify(arguments, null, 4)); if (name == \u0026#39;webgl\u0026#39; || name == \u0026#39;webgl-experimental\u0026#39; || name == \u0026#39;experimental-webgl\u0026#39; || name == \u0026#39;moz-webgl\u0026#39;) { // 最终返回了上文中自定义的类WebGLRenderingContext，完成hook  var y = new WebGLRenderingContext(this); console.log(\u0026#34;WEBGL \u0026#34; + y); console.log(JSON.stringify(y, null, 4)); return y; } // 其他的webgl类型不支持，返回原始数据  if (name == \u0026#39;webgl2\u0026#39; || name == \u0026#39;experimental-webgl2\u0026#39; || name == \u0026#39;fake-webgl\u0026#39;) { console.log(\u0026#34;WEBGL2\u0026#34;) return null; } var ext = getContext.apply(this, arguments); console.log(\u0026#34;HTMLCanvasElement extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(ext); return ext; } } catch (e) { }   context.getExtension定义 实际上很简单，只需要get对应属性时返回指定编号即可，此处以上文中的\u0026quot;WEBGL_debug_renderer_info\u0026quot;为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var extensions = { // ratified  ... \u0026#39;WEBGL_debug_renderer_info\u0026#39;: { \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446 }, ... } WebGLRenderingContext.prototype.getExtension = function (ext) { console.log(\u0026#34;WebGLRenderingContext.getExtension\u0026#34; + ext); return extensions[ext]; };   注意此处有一些特例是\u0026quot;WEBGL_lose_context\u0026quot;和\n\u0026ldquo;WEBGL_draw_buffers\u0026rdquo;, 他们的属性内部包含方法，需要定义一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function loseContext () { } function restoreContext () { } function drawBuffersWEBGL () { } var extensions = { // ratified  ... \u0026#39;WEBGL_lose_context\u0026#39;: { loseContext, restoreContext }, ... \u0026#39;WEBGL_draw_buffers\u0026#39;: { \u0026#39;MAX_DRAW_BUFFERS_WEBGL\u0026#39;: 34852, \u0026#39;MAX_COLOR_ATTACHMENTS_WEBGL\u0026#39;: 36063, ... drawBuffersWEBGL }, }   context.getParameter 定义，完成取值的Hook 代码可以拆解如下：\n 定义部分，拿到getParameter的参数：  1 2 3 4 5 6 7  try { const getParameter = WebGLRenderingContext.prototype.getParameter; WebGLRenderingContext.prototype.getParameter = function () { var name = arguments[0]; console.log(\u0026#34;WebGLRenderingContext - getParameter: \u0026#34; + name); ... } catch (a) { }    Hook UNMASKED_VENDOR_WEBGL 和UNMASKED_RENDERER_WEBGL 参数，从一个备选列表中随机返回一个vendor/renderer，可以很好的防止收集信息结果过度集中，也可以很方便的进行拓展：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function get_random_item(list) { return list[Math.floor((Math.random() * list.length))]; } WebGLRenderingContext.prototype.getParameter = function () { ... // UNMASKED_VENDOR_WEBGL  if (name == 37445) { var options = [\u0026#39;Intel Open Source Technology Center\u0026#39;, \u0026#39;X.Org\u0026#39;, \u0026#39;Vendor Google Inc.\u0026#39;]; return get_random_item(options); } else if (name == 37446) { // UNMASKED_RENDERER_WEBGL  var options = [\u0026#39;Mesa DRI Intel(R) Ivybridge Mobile\u0026#39;, \u0026#39;AMD KAVERI (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Renderer Google SwiftShader\u0026#39;, \u0026#39;AMD ARUBA (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Mesa DRI Intel(R) HD Graphics 630 (Kaby Lake GT2)\u0026#39;, \u0026#39;Gallium 0.4 on AMD KAVERI (DRM 2.43.0 / 4.4.0-83-generic, LLVM 3.8.0)\u0026#39;]; return get_random_item(options); } ... }    Hook 一些基础属性, 如RENDERER / VENDOR / SHADING_LANGUAGE_VERSION /  VERSION\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 7936) { // RENDERER // VENDOR  return \u0026#39;Mozilla\u0026#39;; } else if (name == 35724) { // SHADING_LANGUAGE_VERSION  return \u0026#39;WebGL GLSL ES 1.0\u0026#39;; } else if (name == 7937 || name == 7938) { // VERSION  return \u0026#39;WebGL 1.0\u0026#39;; } ... }    Hook ALIASED_LINE_WIDTH_RANGE / ALIASED_POINT_SIZE_RANGE, 会返回一个float array，size为2；这里代码有点小问题，不影响功能，name == 7937是VERSION，不过在上面已经判断过了，不会进到这个分支：  1 2 3 4 5 6 7 8 9  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 33901 || name == 33902) { // ALIASED_LINE_WIDTH_RANGE // ALIASED_POINT_SIZE_RANGE  var option = new Float32Array([1, 8192]); return option; } ... }    针对一些webgl位宽信息进行Hook，返回随机值[2, 4, 8, 16]中1个，具体参数见注释：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3413 || name == 3412 || name == 3411 || name == 3410 || name == 34852) { // ALPHA_BITS // BLUE_BITS // GREEN_BITS // RED_BITS // MAX_DRAW_BUFFERS_WEBGL  return get_random_item([2, 4, 8, 16]); } ... }    针对一些位宽信息进行Hook，返回固定值，参数见注释  1 2 3 4 5 6 7 8 9 10 11  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3415) // STENCIL_BITS  return 0; } else if (name == 3414) { // DEPTH_BITS  return 24; } ... }    接下来是该脚本bug的地方，Hook出现问题，如果使用该脚本不加修改，很容易通过此bug识别；原因主要在于以下hook的三个参数值理论上是返回一个整数，但不知为何作者这里使用了get_random_items, 但没有给第二个参数，所以n会为undefined，导致固定返回一个Array：undefined；修复也很简单，换成get_random_item即可。源代码如下：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function get_random_items(list, n) { var result = new Array(n), len = list.length, taken = new Array(len); if (n \u0026gt; len) n = len while (n--) { var x = Math.floor(Math.random() * len); result[n] = list[x in taken ? taken[x] : x]; // 比较巧妙的取随机多个值的方式，留一个array标记如果下次再取到其下标会从目前未取成的最后一个元素  taken[x] = --len in taken ? taken[len] : len; } return result; } WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 34047 || name == 34921) { // MAX_TEXTURE_MAX_ANISOTROPY_EXT // MAX_VERTEX_ATTRIBS  return get_random_items([2, 4, 8, 16]); } else if (name == 35661) { // MAX_COMBINED_TEXTURE_IMAGE_UNITS  return get_random_items([128, 192, 256]); } ... }    对一些其他的MAX相关属性进行Hook，返回随机值，具体属性见注释  1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... } else if (name == 34076 || name == 34024 || name == 3379) { // MAX_CUBE_MAP_TEXTURE_SIZE // MAX_RENDERBUFFER_SIZE  return get_random_item([16384, 32768]) ; } else if (name == 36349 || name == 36347) { // MAX_FRAGMENT_UNIFORM_VECTORS // MAX_VERTEX_UNIFORM_VECTORS  return get_random_item([4096, 8192]); } else if (name == 34930 || name == 36348 || name == 35660) { // MAX_TEXTURE_IMAGE_UNITS // MAX_VARYING_VECTORS // MAX_VERTEX_TEXTURE_IMAGE_UNITS  return get_random_item([16, 32, 64]); } ... }    对MAX_VIEWPORT_DIMS进行Hook，会返回一个长度为2且两个值相等的Int32Array，同样此处随机取值：  1 2 3 4 5 6 7 8 9 10  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3386) { // MAX_VIEWPORT_DIMS  var value = get_random_item([8192, 16384, 32768]) var options = new Int32Array([value, value]); return options; } ... }    最后，剩下的参数统一随机从[0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]随机取值返回(此处还有个冗余分支STENCIL_BITS，上面已经判断过了，属于冗余代码)  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else { console.log(\u0026#34;Retuning random value for: \u0026#34; + name); return get_random_item([0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]); } ... }    最后的迷惑操作：理论上此处已经涵盖了所有的case返回，但是最后还多了个跑不到的分支：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... var ext = getParameter.apply(this, arguments); console.log(\u0026#34;WebGLRenderingContext extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(JSON.stringify(ext, null, 4)); return ext; }   说实话我猜测此处他是想模拟一些参数，他们在getParameter之前必须先调用getExtension方法后才可以获取，但是此处加在最后属实看不懂，个人理解应该放在这个大if\u0026hellip;else\u0026hellip;前面；有时间我可以好好修复一下这个项目😂😂\n其他的一些被Hook的方法  getSupportedExtension：比较简单，随机从extensions中间选择随机个keys并返回，出现异常则将所有的keys都返回。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // extensions的keys可以参见getExtension部分 const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions; WebGLRenderingContext.prototype.getSupportedExtensions = function () { try { console.log(\u0026#34;WebGLRenderingContext.getSupportedExtensions\u0026#34;) var availableExtensions = Object.keys(extensions); console.log(availableExtensions); var itemsToGet = Math.floor(Math.random() * (availableExtensions.length - 6) + 5); console.log(itemsToGet); var selectedExtensions = get_random_items(availableExtensions, itemsToGet); console.log(selectedExtensions); return selectedExtensions; } catch (a) { console.log(a) return Object.keys(extensions); } }    针对一些headless浏览器有可能会出现canvas的一些属性异常（broken会为0），如canvas的width和height，以及offset，进行Hook，还是使用defineProperty重写get方法对属性进行hook：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // in case of broken image return random height/width var size = 0; [\u0026#39;height\u0026#39;, \u0026#39;width\u0026#39;].forEach(property =\u0026gt; { const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, property); Object.defineProperty(HTMLImageElement.prototype, property, { imageDescriptor, get: function () { // 如果canvas破损，则返回随机size  if (this.complete \u0026amp;\u0026amp; this.naturalHeight == 0) { if (!size) { // 返回随机的长/宽  size = Math.floor(Math.random() * (30 - 10 + 1)) + 10; } return size; } // 未破损则返回正常size  return imageDescriptor.get.apply(this); }, }); }); // hairline feature (headless can\u0026#39;t render it normally) const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;); Object.defineProperty(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;, { ...imageDescriptor, get: function () { if (this.id == \u0026#39;modernizr\u0026#39;) { return 1; } return imageDescriptor.get.apply(this); }, });   插件执行 方法比较简单，将整个大函数作为字符串，最后在html document中新建一个script tag，script.textContent赋值为字符串即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  var scriptCode = \u0026#39;(\u0026#39; + function () { ... function WebGLRenderingContext(canvas) { ... }; ... WebGLRenderingContext.prototype.getExtension = function (ext) { ... }; ... WebGLRenderingContext.prototype.getParameter = function () { ... } ... } + \u0026#39;)();\u0026#39;; // 转成字符串，可直接执行  // 新建script节点插入document中，即自动执行 var script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = scriptCode; (document.head || document.documentElement).appendChild(script); // 最后move掉代码即可 script.remove();   ","description":"SpoofWebGL","id":3,"section":"posts","tags":["黑产工具"],"title":"SpoofWebGL","uri":"https://summersummer3.github.io/posts/spoofwebgl/"},{"content":"很久没有写博客了，主要是最近换了个地打工，开始对一些反自动化的工作开始进行研究；这是一篇学习笔记，欢迎交流~\n背景与网站介绍 Bot Challenge是专门的web bot检测的网站：https://bot.incolumitas.com/#botChallenge\n该网站对用户行为的检测手段很完整，值得学习；\n用户行为数据 总体收集的event 1 2 3 4 5 6 7  this.recordedEvents = [\u0026#34;mousemove\u0026#34;, \u0026#34;mousedown\u0026#34;, \u0026#34;mouseup\u0026#34;, \u0026#34;dblclick\u0026#34;, \u0026#34;contextmenu\u0026#34;, \u0026#34;scroll\u0026#34;, \u0026#34;resize\u0026#34;, \u0026#34;keydown\u0026#34;, \u0026#34;keyup\u0026#34;, \u0026#34;touchstart\u0026#34;, \u0026#34;touchmove\u0026#34;, \u0026#34;touchcancel\u0026#34;, \u0026#34;touchend\u0026#34;, \u0026#34;load\u0026#34;, \u0026#34;DOMContentLoaded\u0026#34;, \u0026#34;visibilitychange\u0026#34;, \u0026#34;pagehide\u0026#34;, \u0026#34;beforeunload\u0026#34;, \u0026#34;unload\u0026#34;], this.newRecordedEvents = [\u0026#34;copy\u0026#34;, \u0026#34;paste\u0026#34;, \u0026#34;deviceorientation\u0026#34;, \u0026#34;devicemotion\u0026#34;] this.onlyWindowEvent = [\u0026#34;scroll\u0026#34;, \u0026#34;keydown\u0026#34;, \u0026#34;keyup\u0026#34;, \u0026#34;resize\u0026#34;, \u0026#34;copy\u0026#34;, \u0026#34;paste\u0026#34;, \u0026#34;deviceorientation\u0026#34;, \u0026#34;devicemotion\u0026#34;, \u0026#34;visibilitychange\u0026#34;, \u0026#34;load\u0026#34;, \u0026#34;DOMContentLoaded\u0026#34;, \u0026#34;pagehide\u0026#34;, \u0026#34;beforeunload\u0026#34;, \u0026#34;unload\u0026#34;], this.recordNewEvents \u0026amp;\u0026amp; (this.recordedEvents = this.recordedEvents.concat(this.newRecordedEvents))   具体行为收集可以分为以下几类，主要分析下收集的具体数据和触发收集的事件:\n鼠标动作(MouseEvent) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  getMetaKeysBitstring: function(e) { var t = \u0026#34;\u0026#34;; return t += !0 === e.ctrlKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;, t += !0 === e.shiftKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;, t += !0 === e.altKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;, t += !0 === e.metaKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34; } getMouseFrame: function(e, t) { return [t, e.clientX, e.clientY, e.screenX, e.screenY, e.button, this.getMetaKeysBitstring(e)] }, mousemoveListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;m\u0026#34;) }, mousedownListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;md\u0026#34;) }, mouseupListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;mu\u0026#34;) }, dblclickListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;dc\u0026#34;) }, contextmenuListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;cm\u0026#34;) },   数据（列表形式，都是以事件名简写打头，后面是收集的具体数据，下同）：\n  clientX：double（原为long）；鼠标在事件触发时的应用浏览器内的水平坐标\n  clientY：double（原为long）；鼠标在事件触发时的应用浏览器内的垂直坐标\n  screenX：double（原为long）；鼠标在事件触发时全局（屏幕）中的水平坐标\n  screenY：double（原为long）；鼠标在事件触发时全局（屏幕）中的垂直坐标\n  button: number；代表事件触发时按下的鼠标按键：\n 0：主按键，通常指鼠标左键或默认值（译者注：如document.getElementById(\u0026lsquo;a\u0026rsquo;).click()这样触发就会是默认值）    1：辅助按键，通常指鼠标滚轮中键\n  2：次按键，通常指鼠标右键\n  3：第四个按钮，通常指浏览器后退按钮\n  4：第五个按钮，通常指浏览器的前进按钮\n  MetaKey：String；收集触发事件时对应按键是否被按下；\u0026lsquo;0\u0026rsquo;与'1\u0026rsquo;组成的字符串\n  事件：\n mousemove：鼠标移动 mousedown：鼠标按钮按下时触发 mouseup：鼠标按钮松开时触发 dblclick：鼠标双击时触发 contextmenu：打开上下文菜单时触发，例如在页面右键打开菜单  键盘动作(KeyboardEvent) 1 2 3 4 5 6 7 8 9  getKeyFrame: function(e, t) { return [t, e.code, e.key, e.location, e.repeat, this.getMetaKeysBitstring(e)] }, keydownListener: function(e, t) { return e.getKeyFrame(t, \u0026#34;kd\u0026#34;) }, keyupListener: function(e, t) { return e.getKeyFrame(t, \u0026#34;ku\u0026#34;) },   数据：\n code：String；键盘上的物理键（与按键生成的字符相对）。换句话说，此属性返回一个值，该值不会被键盘布局或修饰键的状态改变。如QWERTY布局键盘上的“q”键返回的code是“KeyQ” key: String；返回用户按下的真实逻辑输入。它还与 shiftKey 等调节性按键的状态和键盘的区域 / 和布局有关。 location: unsigned long，表示按键在键盘或其他设备上的位置, 主要针对ctrl/shift等键盘上有多个的按键，以及数字/enter等按键：  0: 表示不区分或者无法区分 1: 来自左边的ctrl/shift/alt\u0026hellip; 2: 来自右边的按键 3: 来自数字小键盘的按键 其他值已废弃   repeat: Bool；如果按键被一直按住，返回值为true Metakey: 与鼠标事件一样  事件：\n keydown：键盘按下触发 keyup：键盘松开触发  触摸动作(TouchEvent) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  getTouchFrame: function(e, t) { for (var n = [], i = 0; i \u0026lt; e.touches.length; i++) { var a = e.touches[i] , o = [this.round2(a.clientX), this.round2(a.clientY), this.round2(a.screenX), this.round2(a.screenY), a.identifier]; this.mobileExperimental \u0026amp;\u0026amp; (o = o.concat([this.round2(a.radiusX), this.round2(a.radiusY), a.rotationAngle, a.force])), n.push(o) } return [t, n, this.getMetaKeysBitstring(e)] }, touchstartListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;ts\u0026#34;) }, touchmoveListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;tm\u0026#34;) }, touchcancelListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;tc\u0026#34;) }, touchendListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;te\u0026#34;) },   数据：\n touches: List；是一个touchList，一个触摸平面上所有触点的列表。例如，如果一个用户用三根手指接触屏幕（或者触控板），与之对应的 TouchList 会包含每根手指的 [Touch](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch) 对象，总共三个  touch.clientX/Touch.clientY/Touch.screenX/Touch.screenY：double (之前为long)；同鼠标事件同名属性 touch.identifier：long；返回一个可以唯一地识别和触摸平面接触的点的值. 这个值在这根手指（或触摸笔等）所引发的所有事件中保持一致, 直到它离开触摸平面；主要是touchmove中    底下的事件将是Experimental功能：\n touch.radiusX：float；手指与屏幕接触面的椭圆水平轴半径 touch.radiusY：float；手指与屏幕接触面的椭圆垂直轴半径 touch.rotationAngle: float；返回以度为单位的旋转角. 由radiusX 和 radiusY 描述的正方向的椭圆，通过顺时针旋转这个角度后，能最精确地覆盖住用户和触摸平面的接触面的角度. 这个值可能从0到90 touch.force：float；手指挤压触摸平面的压力大小, 从0.0(没有压力)到1.0(最大压力)  事件：\n  touchstart: 当用户在触摸平面上放置了一个触点时触发\n  touchmove: 当用户在触摸平面上移动触点时触发; 当触点的半径、旋转角度以及压力大小发生变化时，也将触发此事件\n  touchcancel: 当触点由于某些原因被中断时触发。有几种可能的原因如下（具体的原因根据不同的设备和浏览器有所不同）：\n 由于某个事件出现而取消了触摸：例如触摸过程被弹窗打断。    触点离开了文档窗口，而进入了浏览器的界面元素、插件或者其他外部内容区域。\n  当用户产生的触点个数超过了设备支持的个数，从而导致 [TouchList](https://developer.mozilla.org/zh-CN/docs/Web/API/TouchList) 中最早的 [Touch] 对象被取消。\n  touchend: 当一个触点被用户从触摸平面上移除（即用户的一个手指或手写笔离开触摸平面）时触发。当触点移出触摸平面的边界时也将触发。例如用户将手指划出屏幕边缘\n  元素移动相关 1 2 3 4 5 6  scrollListener: function(e, t) { return [\u0026#34;s\u0026#34;, e.round2(document.scrollingElement.scrollLeft), e.round2(document.scrollingElement.scrollTop)] } resizeListener: function(e, t) { return [\u0026#34;r\u0026#34;, window.innerWidth, window.innerHeight] },    ScrollEvent：文档视图或者一个元素在滚动时，会触发; 主要是收集滚动条数据  scrollingElement.scrollLeft：integer(有比例缩放的系统可能为float)；滚动条到最左边的距离 scrollingElement.scrollTop：integer(有比例缩放的系统可能为float)；滚动条到最顶端的距离   resizeEvent：调整视窗大小时触发该事件  window.innerWidth：integer；返回以像素为单位的窗口的内部宽度。如果垂直滚动条存在，则这个属性将包括它的宽度。 window.innerHeight：integer；返回以像素为单位的窗口的内部高度度。如果有水平滚动条，也包括滚动条高度。    页面相关事件 主要是页面加载，tab切换等：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  loadListener: function(e, t) { return [\u0026#34;lo\u0026#34;] }, DOMContentLoadedListener: function(e, t) { return [\u0026#34;dcl\u0026#34;] }, visibilitychangeListener: function(e, t) { return [\u0026#34;vc\u0026#34;, document.visibilityState] }, pagehideListener: function(e, t) { return [\u0026#34;ph\u0026#34;, t.persisted] }, beforeunloadListener: function(e, t) { return [\u0026#34;bu\u0026#34;] }, unloadListener: function(e, t) { return [\u0026#34;ul\u0026#34;] },     load：当整个页面及所有依赖资源如样式表和图片都已完成加载时，将触发\n  DOMContentLoaded：当纯HTML被完全加载以及解析时，事件会被触发，而不必等待样式表，图片或者子框架完成加载\n  visibilitychange：当其选项卡的内容变得可见或被隐藏时，会在文档上触发\n document.visibilityState：String；返回document的可见性, 即当前可见元素的上下文环境. 由此可以知道当前文档(即为页面)是在背后, 或是不可见的隐藏的标签页，或者(正在)预渲染.可用的值如下：  'visible' : 此时页面内容至少是部分可见. 即此页面在前景标签页中，并且窗口没有最小化.      'hidden\u0026rsquo; : 此时页面对用户不可见. 即文档处于背景标签页或者窗口处于最小化状态，或者操作系统正处于 \u0026lsquo;锁屏状态\u0026rsquo; .\n  'prerender' : 页面此时正在渲染中, 因此是不可见的 (considered hidden for purposes of document.hidden). 文档只能从此状态开始，永远不能从其他值变为此状态.注意: 浏览器支持是可选的.\n  pagehide：当浏览器在隐藏当前页面时, 页面隐藏事件会被发送到一个window 。例如，当用户单击浏览器的“后退”按钮时，当前页面在显示上一页之前会收到一个页面隐藏事件。\n persisted：代表一个页面是否从缓存中加载的，可以判断隐藏页面是否已缓存以进行可能的重用时执行特殊处理    beforeunload：window、document 和它们的资源即将卸载时触发，例如可以弹窗确定是否关闭选项卡\n  unload：window、document 和它们的资源正在卸载时触发\n  用户操作相关  Copy \u0026amp; paste  1 2 3 4 5 6 7 8 9 10  copyListener: function(e, t) { var n = document.getSelection() , i = [\u0026#34;co\u0026#34;]; return n \u0026amp;\u0026amp; i.push(Math.abs(n.anchorOffset, n.focusOffset)), i }, pasteListener: function(e, t) { return [\u0026#34;pa\u0026#34;, (t.clipboardData || window.clipboardData).getData(\u0026#34;text\u0026#34;).length] },    getSelection：返回一个选中对象  selection.anchorOffset: integer；返回选中元素在DOM节点中起始位置（按下鼠标）偏移 selection.focusOffset：integer；返回选中元素在DOM节点中终止位置（松开鼠标）偏移    例子:\n1  \u0026lt;text\u0026gt;abcdefg\u0026lt;text\u0026gt;   若选中该text元素内的\u0026quot;bcd\u0026quot;，则anchorOffset = 1，focusOffset = 3\n  clipboardData. getData(\u0026ldquo;text\u0026rdquo;).length: integer；粘贴板上字符串长度\n  Deviceorientation: 设备（指手机，平板等移动设备）在浏览页面时物理旋转的信息；注意safari未实现\n  1 2 3 4 5 6 7 8 9  deviceorientationListener: function(e, t) { if (!(Math.abs(e.rotateDegrees - t.alpha) \u0026lt; 2 || Math.abs(e.leftToRight - t.gamma) \u0026lt; 1 || Math.abs(e.frontToBack - t.beta) \u0026lt; 1)) { e.rotateDegrees = t.alpha, e.frontToBack = t.beta, e.leftToRight = t.gamma; t = t.absolute; return null !== e.rotateDegrees \u0026amp;\u0026amp; null !== e.frontToBack \u0026amp;\u0026amp; null !== e.leftToRight ? [\u0026#34;do\u0026#34;, e.round2(e.rotateDegrees), e.round2(e.frontToBack), e.round2(e.leftToRight), t] : void 0 } },   收集逻辑以1度为精度，若误差小于一度则不记录\n  alpha：double；一个表示设备绕z轴旋转的角度（范围在0-360之间）的数字\n  beta：double：一个表示设备绕x轴旋转（范围在－180到180之间）的数字，从前到后的方向为正方向\n  gamma：double；一个表示设备绕y轴旋转（范围在－90到90之间）的数字，从左向右为正方向。\n  absolute：boolean；表示该设备是否提供绝对定位数据 (这个数据是关于地球的坐标系) 或者使用了由设备决定的专门的坐标系.\n  devicemotion：关于设备在浏览页面时的位置和方向的改变速度的信息；同样Safari不支持\n  1 2 3 4 5 6 7 8 9  devicemotionListener: function(e, t) { var n = e.round2(t.acceleration.x) , i = e.round2(t.acceleration.y) , e = e.round2(t.acceleration.z) , t = (t.rotationRate, t.interval); if (null !== n \u0026amp;\u0026amp; null !== i \u0026amp;\u0026amp; null !== e \u0026amp;\u0026amp; (1 \u0026lt; Math.abs(n) || 1 \u0026lt; Math.abs(i) || 1 \u0026lt; Math.abs(e))) return [\u0026#34;dm\u0026#34;, n, i, e, t] }    acceleration.x/acceleration.y/acceleration.z: double；x, y, z方向上的加速度信息 rotationRate.alpha/rotationRate.beta/rotationRate.gamma: double；三个方向上旋转的加速度信息 Interval: integer；返回从底层硬件获取数据的时间间隔（单位：毫秒）。可以使用它来确定运动事件的粒度  其他公共信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  getTimestamp: function() { return \u0026#34;performance\u0026#34;in window \u0026amp;\u0026amp; \u0026#34;now\u0026#34;in window.performance ? this.round(performance.now(), 3) : (new Date).getTime() - 1e3 * this.startedAt }, getPassiveSupported: function() { let t = !1; try { var e = { get passive() { return !(t = !0) } }; window.addEventListener(\u0026#34;test\u0026#34;, null, e), window.removeEventListener(\u0026#34;test\u0026#34;, null, e) } catch (e) { t = !1 } return t },    Timestamp：触发时间戳，可以看到此处优先使用window.performance.now()函数 PassiveSupported：用于检查addEventlistener时是否支持使用passive模式：设置为true时，可以优化收集滚屏事件的性能，可查看https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E7%9A%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD event.isTrusted：boolean；当事件是由用户行为生成的时候，这个属性的值为 true ，而当事件是由脚本创建、修改、通过 [EventTarget.dispatchEvent()](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent) 派发的时候，这个属性的值为 false 。  收集 开始recording： Record接口提供开始行为记录收集\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  getFrameHandler: function(n, i) { return function(e) { var t = i(n, e) , e = 1 == e.isTrusted ? 1 : 0 , t = t.concat([e, n.getTimestamp()]); n.frames.push(t), n.pdFlag \u0026amp;\u0026amp; n.frames.length \u0026gt;= n.push_after \u0026amp;\u0026amp; (e = new Event(\u0026#34;musPushData\u0026#34;), window.dispatchEvent(e), n.pdFlag = !1), n.onFrame \u0026amp;\u0026amp; n.onFrame instanceof Function \u0026amp;\u0026amp; n.onFrame(t) } }, record: function() { if (!this.recording) { 0 == this.startedAt \u0026amp;\u0026amp; (this.startedAt = (new Date).getTime() / 1e3), document.scrollingElement \u0026amp;\u0026amp; this.frames.push([\u0026#34;s\u0026#34;, this.round2(document.scrollingElement.scrollLeft), this.round2(document.scrollingElement.scrollTop), this.getTimestamp()]); for (var e = 0; e \u0026lt; this.recordedEvents.length; e++) { var t = this.recordedEvents[e] , n = \u0026#34;scroll\u0026#34; === t , i = null , i = this.onlyWindowEvent.includes(t) \u0026amp;\u0026amp; this.listenNode !== window ? window : this.listenNode; \u0026#34;visibilitychange\u0026#34; === t \u0026amp;\u0026amp; (i = document); var a = this.passiveSupported ? { passive: !0, capture: n } : n , n = this.getFrameHandler(this, this[t + \u0026#34;Listener\u0026#34;]); this.eventListenerParams[t] = [i, t, n, a], i.addEventListener(t, n, a) } this.recording = !0 } },   本段代码主要用来逐一注册事件的listener(Line27-29):\n 记录开始时间 (Line 15) 当开始记录时会首先记录一次当前滚动条的位置(Line 16) addEventListener的capture设置为true是用来阻止事件向上冒泡的，只有对scroll阻止冒泡：例如针对一个iframe开启了scroll listener，该事件不会触发window侧scroll listener(Line19) onlyWindowEvent主要记录只有window拥有的事件，由于该脚本支持设置监听DOM中某个node的event，所以此时若监听node非window则应该去对应监听window下的事件，即运行到29行时，i == window(Line 21) 优先使用passive模式进行监听(Line 23) 使用了**eventListenerParams**列表来保存了所有监听的事件，用于后续stop，该条值得学习 Line 4 - 5，每次收集都包含的公共信息 可以设置push_after来控制收集多少条信息后触发上报，所有收集的信息没有分类，全部放在frame列表中；触发上报的本质是通过dispatchEvent触发一个事件，该事件的处理函数将发起上报，后面将讲述具体触发上报的时机 (Line 7) recording设置为1，表示开始数据收集  Stop 1 2 3 4 5 6 7 8  stop: function() { for (var e in this.finishedAt = (new Date).getTime() / 1e3, this.eventListenerParams) { var t = this.eventListenerParams[e]; t[0].removeEventListener(t[1], t[2], t[3]) } this.recording = !1 },   记录下停止的时间后，将record时记录的事件全部remove掉，recording置为0表示当前未收集数据\n上报触发时机 以下事件触发时，将发起数据上报；其中\u0026quot;musPushData\u0026quot;事件即为上文描述的主动控制收集多少条数据后进行上报\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  document.addEventListener(\u0026#34;visibilitychange\u0026#34;, function(e) { \u0026#34;hidden\u0026#34; === document.visibilityState \u0026amp;\u0026amp; (t = !0, i(\u0026#34;vc\u0026#34;)) }), window.addEventListener(\u0026#34;pagehide\u0026#34;, function(e) { !1 === t \u0026amp;\u0026amp; (t = !0, i(\u0026#34;ph\u0026#34;)) }), window.addEventListener(\u0026#34;beforeunload\u0026#34;, function(e) { !1 === t \u0026amp;\u0026amp; (t = !0, i(\u0026#34;bu\u0026#34;)) }), window.addEventListener(\u0026#34;unload\u0026#34;, function(e) { !1 === t \u0026amp;\u0026amp; (t = !0, i(\u0026#34;un\u0026#34;)) }), window.addEventListener(\u0026#34;musPushData\u0026#34;, function(e) { i(\u0026#34;pd\u0026#34;), mus.pdFlag = !0 })   DeviceData收集 该脚本同样会收集当前浏览器的信息，此处只列出部分值得学习的部分\nSayswho 用于识别当前浏览器及其版本；通常会注册在navigator中，非标准接口；参考代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  navigator.sayswho= (function(){ var ua= navigator.userAgent, tem, M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || []; if(/trident/i.test(M[1])){ tem= /\\brv[ :]+(\\d+)/g.exec(ua) || []; return \u0026#39;IE \u0026#39;+(tem[1] || \u0026#39;\u0026#39;); } if(M[1]=== \u0026#39;Chrome\u0026#39;){ tem= ua.match(/\\b(OPR|Edge)\\/(\\d+)/); if(tem!= null) return tem.slice(1).join(\u0026#39; \u0026#39;).replace(\u0026#39;OPR\u0026#39;, \u0026#39;Opera\u0026#39;); } M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, \u0026#39;-?\u0026#39;]; if((tem= ua.match(/version\\/(\\d+)/i))!= null) M.splice(1, 1, tem[1]); return M.join(\u0026#39; \u0026#39;); })(); console.log(navigator.sayswho);   我们可以用此条快速解决UA解析版本的问题\nString.prototype.toSource异常检测 主流浏览器都会发生异常，除非是特别低版本的浏览器，可以快速定位低版本浏览器，参考代码：\n1 2 3 4 5 6 7 8 9 10 11 12  getErrorFF: function() { try { throw \u0026#34;a\u0026#34; } catch (e) { try { return e.toSource(), !0 } catch (e) { return !1 } } },   Audio/Video解码能力测试 利用canPlayType接口，若大概率可以播放，则返回\u0026quot;probably\u0026quot;，若确定无能力则返回空字符串; 不同的主流浏览器及版本会有比较显著的特性，低版本浏览器将全部为空\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  audioCodecs: function() { var e = document.createElement(\u0026#34;audio\u0026#34;) , t = {} , n = { ogg: \u0026#39;audio/ogg; codecs=\u0026#34;vorbis\u0026#34;\u0026#39;, mp3: \u0026#34;audio/mpeg;\u0026#34;, wav: \u0026#39;audio/wav; codecs=\u0026#34;1\u0026#34;\u0026#39;, m4a: \u0026#34;audio/x-m4a;\u0026#34;, aac: \u0026#34;audio/aac;\u0026#34; }; if (e.canPlayType) for (var i in n) t[i] = e.canPlayType(n[i]); return t }, videoCodecs: function() { var e = document.createElement(\u0026#34;video\u0026#34;) , t = {} , n = { ogg: \u0026#39;video/ogg; codecs=\u0026#34;theora\u0026#34;\u0026#39;, h264: \u0026#39;video/mp4; codecs=\u0026#34;avc1.42E01E\u0026#34;\u0026#39;, webm: \u0026#39;video/webm; codecs=\u0026#34;vp8, vorbis\u0026#34;\u0026#39;, mpeg4v: \u0026#39;video/mp4; codecs=\u0026#34;mp4v.20.8, mp4a.40.2\u0026#34;\u0026#39;, mpeg4a: \u0026#39;video/mp4; codecs=\u0026#34;mp4v.20.240, mp4a.40.2\u0026#34;\u0026#39;, theora: \u0026#39;video/x-matroska; codecs=\u0026#34;theora, vorbis\u0026#34;\u0026#39; }; if (e.canPlayType) for (var i in n) t[i] = e.canPlayType(n[i]); return t },   window.eval hook检测 不同浏览器长度会有所不同，firefox为37，chrome类的为33，同时eval中会包含\u0026rsquo;native code\u0026rsquo;关键字\n1  u.deviceData.emptyEvalLength = eval.toString().length   网络相关检测 仅chrome支持，获取网络环境信息\n1 2 3 4 5 6  navigator \u0026amp;\u0026amp; navigator.connection \u0026amp;\u0026amp; (r = navigator.connection, u.deviceData.connection = { effectiveType: r.effectiveType, rtt: r.rtt, downlink: r.downlink })   webAssembly能力检测 本条是在查阅资料过程中发现了还有类似功能的一个开源项目friendly challenge：GitHub - FriendlyCaptcha/friendly-challenge: The widget and docs for the proof of work challenge use，其中发现的一个检测点；关于该项目一些相关点后续可以再总结\n检测方法其实比较简单，使用一串可以被编译的字串，使用webAssembly.compile进行编译，尝试捕获异常，若捕获则检测失败：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const A = WebAssembly.compile(function(A) { const C = A.length; let t = 3 * C \u0026gt;\u0026gt;\u0026gt; 2; A.charCodeAt(C - 1) === I \u0026amp;\u0026amp; t--, A.charCodeAt(C - 2) === I \u0026amp;\u0026amp; t--; const B = new Uint8Array(t); for (let I = 0, t = 0; I \u0026lt; C; I += 4) { const C = g[A.charCodeAt(I + 0)], Q = g[A.charCodeAt(I + 1)], e = g[A.charCodeAt(I + 2)], r = g[A.charCodeAt(I + 3)]; B[t++] = C \u0026lt;\u0026lt; 2 | Q \u0026gt;\u0026gt; 4, B[t++] = (15 \u0026amp; Q) \u0026lt;\u0026lt; 4 | e \u0026gt;\u0026gt; 2, B[t++] = (3 \u0026amp; e) \u0026lt;\u0026lt; 6 | 63 \u0026amp; r } return B }(\u0026#34;一个base64编码的可编译webAssembly源码\u0026#34;))   ","description":"Bot Challenge中的behavior collection分析","id":4,"section":"posts","tags":["检测工具"],"title":"Bot Challenge中的behavior collection分析","uri":"https://summersummer3.github.io/posts/botchallenge/"},{"content":"ARM-V8与Trustzone ARM v8 AArch64架构 由上图可知：ARM处理器有两种状态：Normal world与 Secure world; ARM处理器有四个异常等级(Exception Level)：Elx (x = 0, 1, 2, 3). 由于el3拥有最高权限，不区分安全与非安全，所以ARM处理器总共有2 * 4 - 1 = 7个状态\n重要的寄存器 通用寄存器：\nARMv8-A提供了31个64位的通用寄存器，始终可以访问，并且可以在所有异常级别访问。 在AArch64执行状态下，每个寄存器（X0-X30）都是64位宽度。 宽度增加有助于减少大部分应用程序中的寄存器压力。\n每个64位通用寄存器（X0 - X30）也有一个32位的格式（W0 - W30）。\n   Register x 功能     CPSR - 记录当前处理器状态:NZCV IFTM…   SP_ELx 0,1,2,3 指向堆栈顶部的指针寄存器   ELR_ELx 1,2,3 异常链接寄存器, 保存要在异常后返回的地址   SPSR_ELx 1,2,3 保存的处理器状态寄存器   VBAR_ELx 1,2,3 基于向量的地址寄存器, 保存异常基地址以便发送到ELn的任何异常。   TTBR0_ELx/TTBR1_ELx 0,1,2,3 保存页表基地址   SCR_EL3 - 用于配置arm核上的安全属性：如指示当前核的安全状态NS位，指示当前中断或异常是否路由至el3，不同的中断将使用不同位段表示：https://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/SCR-EL3\u0026ndash;Secure-Configuration-Register    异常等级切换 系统调用异常：SVC, HVC, or SMC (vbar_elx, spsr_elx)\nSVC通常被EL0（user mode）的软件用来申请 操作系统上EL1（OS service）请求特权操作或访问系统资源。\nHVC主要被guest OS用来请求hypervisor的服务;\nSMC表示: Secure monitor Call, 用于secure与non-secure切换, 本质是通过保存两个世界的寄存器上下文信息后，设置scr_el3.NS位来完成世界的切换：：\n高异常等级-\u0026gt;低异常等级：ERET (elr_elx, cpsr)\nTrustzone与TEE GP(Glabol Platform)标准下的TEE GP规范化定义了一个Trustzone下TEE软件与硬件架构。用白话说就是一整套TEE标准化的众多规则，本质上也是为了保证安全应用调用的接口命名一致，保持可移植性。\n 对于CA/TA开发者来说，我们主要需要在CA侧调用对应接口，在TA侧实现对应接口，以打通CA与TA的交互session.\nCA侧调用：  TEEC_InitializeContext TEEC_FinalizeContext TEEC_RegisterSharedMemory TEEC_AllocateSharedMemory TEEC_ReleaseSharedMemory TEEC_OpenSession TEEC_CloseSession TEEC_InvokeCommand TEEC_RequestCancellation TA侧实现：\nTA_CreateEntryPoint TA_DestroyEntryPoint TA_InvokeCommandEntryPoint TA_OpenSessionEntryPoint  对于TEE_OS开发者来说，则需要的实现GP规定下的各种component，也必须实现对应和TA交互的API，方便TA的移植。这个比较多就不在这里列举，可以参考官方网站 ：https://globalplatform.org/specs-library/?filter-committee=tee  硬件基础：   在支持trustzone技术的微处理器中，AMR实现了对cortex的虚拟化，将每个物理的处理器虚拟化成两个虚拟核，一个为安全核，一个普通安全核，也就是一个物理核存在secure wrold态和normal world态。\n  AXI总线上NS位的扩展：在原有的AXI基础上对每一个读写信道增加了一个额外的控制信号，用来表示当前的读写操作是安全操作还是非安全操作，被称为NS位或者Non-Secure位。当NS位信号为1时，拒绝访问安全资源\n  其他支持\n   Secure bootrom：启动的rom，存储安全启动代码 TZASC组件(Trustzone Address Space Controller)：配置所有设备地址的安全属性 TZMA组件(Trustzone Memory Adapter)：配置片上静态ram地址的安全属性 TZPC组件(Trustzone Protection Controller)：确定外部设备的发送的信号安全属性 TZIC组件（Trustzone Interrupt Controller）：配置中断的安全属性(CPU处于安全态时，中断为安全中断) MMU的扩展：也就是每个世界都具有单独的MMU页表。存放在MMU中的每一条页表描述符都会包含一个NS位来表示被映射的内存安全属性。 Cache的扩展**：**在cache中的每一项都会按照normal world和secure world的状态打上对应的tag，这就能实现在不同的world下面，处理器只要属性自己world的cache就可以了。  ARM TEE软件架构： 下面是GP标准下，TEE软件架构图，对应optee中的组件名\n TEE Cilent API: 提供给非安全用户态应用调用TA的接口，将参数下沉至tee内核驱动；在optee中位libteec.so TEE protocol Specs: 接受来自tee-driver的命令完成需要在el0才能进行的工作：如文件加载的；在optee中为tee-supplicant，是一个后台进程 Driver \u0026amp; REE Communication Agent 1.管理非安全相关设备以及与安全世界通信的共享内存; 2.非安全世界rpc通信的端点; 3.触发smc异常，使arm核进入安全态. 在optee中为tee-driver.ko（目前已默认集成在linux kernel中） ATF runtime: 保存非安全世界cpu上下文，恢复安全世界上下文，调用eret 将cpu退回sel1. Trusted OS Component：即运行在安全世界的OS组件，功能在不断扩展，在optee则为optee编译好的镜像，通常为tee.bin TEE Internal Core API：通常为一个用于安全应用编译时的SDK，optee中有一个sdk文件夹，可以参考其安全应用编译文档 TA (Trusted App)：运行在隔离环境下的安全应用  所以TEE是啥 TEE (Trusted Execution Environment):\n在ARM下，由上述Trustzone硬件基础与软件组件共同构建的一个与非安全世界隔离的可信程序运行环境。\n除了Trustzone之外，其他的硬件平台上的TEE有以下知名环境：\nIntel SGX/AMD Secure Execution Environment/RISC-V MultiZone…\noptee 为什么选择optee 先看optee官方是怎么给自己定义的：\n OP-TEE is a Trusted Execution Environment (TEE) designed as companion to a non-secure Linux kernel running on Arm; Cortex-A cores using the TrustZone technology. OP-TEE implements TEE Internal Core API v1.1.x which is the API exposed to Trusted Applications and the TEE Client API v1.0, which is the API describing how to communicate with a TEE. Those APIs are defined in the GlobalPlatform API specifications.\nThe main design goals for OP-TEE are:\n  Isolation - the TEE provides isolation from the non-secure OS and protects the loaded Trusted Applications (TAs) from each other using underlying hardware support, Small footprint - the TEE should remain small enough to reside in a reasonable amount of on-chip memory as found on Arm based systems, Portability - the TEE aims at being easily pluggable to different architectures and available HW and has to support various setups such as multiple client OSes or multiple TEEs    在我看来选择这个项目作为TEE学习更主要的原因是：开源。大部分TEE过于封闭，很难去窥探trustzone里奥秘，optee是一个所有组件都完全开源的项目，由linaro主导并维护，社区活跃度也很高，仅一年左右时间更新5个大版本\n参考资料 源码 optee_os: https://github.com/OP-TEE/optee_os\noptee_client: https://github.com/OP-TEE/optee_client\ntee驱动默认在linux内核中, 更新在这: https://github.com/linaro-swg/linux/tree/optee\n中文资料书籍 《手机安全和可信应用开发指南:TrustZone与OP-TEE技术详解》\n作者博客：https://blog.csdn.net/shuaifengyun  OPTEE Core 架构参考 Architecture ‒ OP-TEE documentation documentation\n本文不介绍optee os的具体架构，而是通过一个经典的例子来分析optee中一个完整的请求是如何从非安全世界的app发送到安全应用ta，并完成功能调用的，linaro官方的example仓，有许多功能调用的例子：https://github.com/linaro-swg/optee_examples\n本文就以最简单的hello_world为例子\nCA-\u0026gt;TA CA是调用TEE安全服务的入口程序，运行在非安全用户态el0。\nTA是TEE服务的重点，大部分自定义的安全服务在TA中实现，运行在安全用户态SEL0.\n从CA到TA的invoke command，完成一次服务调用，将会经历一个漫长的层级及CPU安全态切换，通常的通路如下：\n(链接)\t(ioctl) (smc指令)\t(el3 eret sel1) (sel1 eret)  CA========\u0026gt;libteec.so=======\u0026gt;tee_driver=========\u0026gt;ATF==========\u0026gt;TEE_kernel==========\u0026gt;TA\n若TEE/TA服务有部分工作需要返回非安全态执行，则需要返回tee_driver呼叫非安全侧守护进程tee_supplicant去完成工作：\nTA/TEE_kernel====\u0026gt;ATF====\u0026gt;tee_driver====\u0026gt;tee_supplicant\n由于ATF主要工作是在启动阶段完成，运行态时主要用于切换CPU安全/非安全状态，保存/恢复彼此的寄存器状态上下文，不在此处细聊。下面我们将通过一次TA加载过程的数据流来细讲每一个组件的主要功能。\nCA 非安全用户态程序，动态链接libteec.so，调用其接口。CA是调用安全世界TA服务的起点。\nlinaro官方的example仓，有许多功能调用的例子：\nhttps://github.com/linaro-swg/optee_examples\n简单看一下hello_world:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #define TA_HELLO_WORLD_UUID \\ { 0x8aaaf200, 0x2450, 0x11e4, \\ { 0xab, 0xe2, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b} }  int main(void) { TEEC_Result res; TEEC_Context ctx; TEEC_Session sess; TEEC_Operation op; TEEC_UUID uuid = TA_HELLO_WORLD_UUID; uint32_t err_origin; /* Initialize a context connecting us to the TEE */ res = TEEC_InitializeContext(NULL, \u0026amp;ctx); if (res != TEEC_SUCCESS) errx(1, \u0026#34;TEEC_InitializeContext failed with code 0x%x\u0026#34;, res); /* * Open a session to the \u0026#34;hello world\u0026#34; TA, the TA will print \u0026#34;hello * world!\u0026#34; in the log when the session is created. */ res = TEEC_OpenSession(\u0026amp;ctx, \u0026amp;sess, \u0026amp;uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, \u0026amp;err_origin); if (res != TEEC_SUCCESS) errx(1, \u0026#34;TEEC_Opensession failed with code 0x%x origin 0x%x\u0026#34;, res, err_origin); /* * Execute a function in the TA by invoking it, in this case * we\u0026#39;re incrementing a number. * * The value of command ID part and how the parameters are * interpreted is part of the interface provided by the TA. */ /* Clear the TEEC_Operation struct */ memset(\u0026amp;op, 0, sizeof(op)); /* * Prepare the argument. Pass a value in the first parameter, * the remaining three parameters are unused. */ op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE); op.params[0].value.a = 42; /* * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be * called. */ printf(\u0026#34;Invoking TA to increment %d\\n\u0026#34;, op.params[0].value.a); res = TEEC_InvokeCommand(\u0026amp;sess, TA_HELLO_WORLD_CMD_INC_VALUE, \u0026amp;op, \u0026amp;err_origin); if (res != TEEC_SUCCESS) errx(1, \u0026#34;TEEC_InvokeCommand failed with code 0x%x origin 0x%x\u0026#34;, res, err_origin); printf(\u0026#34;TA incremented value to %d\\n\u0026#34;, op.params[0].value.a); /* * We\u0026#39;re done with the TA, close the session and * destroy the context. * * The TA will print \u0026#34;Goodbye!\u0026#34; in the log when the * session is closed. */ TEEC_CloseSession(\u0026amp;sess); TEEC_FinalizeContext(\u0026amp;ctx); return 0; }   libteec.so(el0) libteec.so中包含了GP标准下提供的五个供CA调用与TA通讯的接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  TEEC_Result TEEC_InitializeContext( const char* name, TEEC_Context* context) void TEEC_FinalizeContext( TEEC_Context* context) TEEC_Result TEEC_OpenSession ( TEEC_Context* context, TEEC_Session* session, const TEEC_UUID* destination, uint32_t connectionMethod, const void* connectionData, TEEC_Operation* operation, uint32_t* returnOrigin) void TEEC_CloseSession ( TEEC_Session* session) TEEC_Result TEEC_InvokeCommand( TEEC_Session* session, uint32_t commandID, TEEC_Operation* operation, uint32_t* returnOrigin)   可以看到成对出现的ctx和session操作以及服务调用的TEEC_InvokeCommand。\n调用TEE中TA的服务第一步是打开TEE驱动：可以看到TEEC_InitializeContext操作是很简单的，尝试去打开tee_driver的字符设备，teec的上下文中将驱动的描述符存下来，供后续使用; 并查询了一些驱动中保存的TEE_OS的一些版本信息.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx) { char devname[PATH_MAX] = { 0 }; int fd = 0; size_t n = 0; if (!ctx) return TEEC_ERROR_BAD_PARAMETERS; for (n = 0; n \u0026lt; TEEC_MAX_DEV_SEQ; n++) { uint32_t gen_caps = 0; snprintf(devname, sizeof(devname), \u0026#34;/dev/tee%zu\u0026#34;, n); //通常tee驱动只会创建一个设备，自定义条件下可能有多个设备。 \tfd = teec_open_dev(devname, name, \u0026amp;gen_caps);//尝试去打开tee_driver的驱动 \tif (fd \u0026gt;= 0) { ctx-\u0026gt;fd = fd; //将设备的文件描述符存储在上下文中 \tctx-\u0026gt;reg_mem = gen_caps \u0026amp; TEE_GEN_CAP_REG_MEM; //reg_mem TEE状态 动态注册共享内存 \tctx-\u0026gt;memref_null = gen_caps \u0026amp; TEE_GEN_CAP_MEMREF_NULL; return TEEC_SUCCESS; } } return TEEC_ERROR_ITEM_NOT_FOUND; } static int teec_open_dev(const char *devname, const char *capabilities, uint32_t *gen_caps) { int fd = 0; struct tee_ioctl_version_data vers; memset(\u0026amp;vers, 0, sizeof(vers)); fd = open(devname, O_RDWR); if (fd \u0026lt; 0) return -1; if (ioctl(fd, TEE_IOC_VERSION, \u0026amp;vers)) { EMSG(\u0026#34;TEE_IOC_VERSION failed\u0026#34;); goto err; } /* We can only handle GP TEEs */ if (!(vers.gen_caps \u0026amp; TEE_GEN_CAP_GP)) goto err; ... }   TEEC_OpenSession提供了从文件系统加载TA到TEE中，并打开TA-CA的安全通道session的功能。\nlibteec通过结构体tee_ioctl_open_session_arg和tee_ioctl_param传递session的信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  struct tee_ioctl_open_session_arg { __u8 uuid[TEE_IOCTL_UUID_LEN]; __u8 clnt_uuid[TEE_IOCTL_UUID_LEN]; __u32 clnt_login; __u32 cancel_id; __u32 session; __u32 ret; __u32 ret_origin; __u32 num_params; } __aligned(8); struct tee_ioctl_param_memref { __u64 shm_offs; __u64 size; __s64 shm_id; }; struct tee_ioctl_param_value { __u64 a; __u64 b; __u64 c; }; struct tee_ioctl_param { __u64 attr; union { struct tee_ioctl_param_memref memref; struct tee_ioctl_param_value value; } u; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  /* optee_client/libteec/src/tee_client_api.c */ TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session, const TEEC_UUID *destination, uint32_t connection_method, const void *connection_data, TEEC_Operation *operation, uint32_t *ret_origin) { struct tee_ioctl_open_session_arg *arg = NULL; struct tee_ioctl_param *params = NULL; TEEC_Result res = TEEC_ERROR_GENERIC; uint32_t eorig = 0; int rc = 0; const size_t arg_size = sizeof(struct tee_ioctl_open_session_arg) + TEEC_CONFIG_PAYLOAD_REF_COUNT * sizeof(struct tee_ioctl_param); union { struct tee_ioctl_open_session_arg arg; uint8_t data[arg_size]; } buf; struct tee_ioctl_buf_data buf_data; TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT]; //当teec输入的operation的param中含有数据流buffer时，需要申请将buffer拷贝到一块有tee驱动申请的安全与非安全交互的share_memory。  memset(\u0026amp;buf, 0, sizeof(buf)); memset(\u0026amp;shm, 0, sizeof(shm)); memset(\u0026amp;buf_data, 0, sizeof(buf_data)); (void)\u0026amp;connection_data; if (!ctx || !session) { eorig = TEEC_ORIGIN_API; res = TEEC_ERROR_BAD_PARAMETERS; goto out; } buf_data.buf_ptr = (uintptr_t)\u0026amp;buf; buf_data.buf_len = sizeof(buf); arg = \u0026amp;buf.arg; arg-\u0026gt;num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT; params = (struct tee_ioctl_param *)(arg + 1); uuid_to_octets(arg-\u0026gt;uuid, destination); arg-\u0026gt;clnt_login = connection_method; res = teec_pre_process_operation(ctx, operation, params, shm); //此处完成share_memory从内核到用户态的映射以及数据流的拷贝 \tif (res != TEEC_SUCCESS) { eorig = TEEC_ORIGIN_API; goto out_free_temp_refs; } rc = ioctl(ctx-\u0026gt;fd, TEE_IOC_OPEN_SESSION, \u0026amp;buf_data); //进入驱动ioctl函数,cmd决定了 \tif (rc) { EMSG(\u0026#34;TEE_IOC_OPEN_SESSION failed\u0026#34;); eorig = TEEC_ORIGIN_COMMS; res = ioctl_errno_to_res(errno); goto out_free_temp_refs; } res = arg-\u0026gt;ret; //驱动回写的返回值 \teorig = arg-\u0026gt;ret_origin; if (res == TEEC_SUCCESS) { session-\u0026gt;ctx = ctx; session-\u0026gt;session_id = arg-\u0026gt;session; } teec_post_process_operation(operation, params, shm); out_free_temp_refs: teec_free_temp_refs(operation, shm); out: if (ret_origin) *ret_origin = eorig; return res; }   此处主要是将open_session用户态入参结构体初始化并通过ioctl传入内核中, 注意此处关键函数teec_pre_process_operation，注释中有描述大概的功能。后文中共享内存都指安全与非安全交互的share_memory。我们主要查看对用户态buffer的处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100  static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx, TEEC_Operation *operation, struct tee_ioctl_param *params, TEEC_SharedMemory *shms) { TEEC_Result res = TEEC_ERROR_GENERIC; size_t n = 0; memset(shms, 0, sizeof(TEEC_SharedMemory) * TEEC_CONFIG_PAYLOAD_REF_COUNT); ... for (n = 0; n \u0026lt; TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) { uint32_t param_type = 0; /* 遍历操作中的params */ param_type = TEEC_PARAM_TYPE_GET(operation-\u0026gt;paramTypes, n); switch (param_type) { ... /* in_buffer中有两种类型，tmpref是还没写进share_memory的buffer */ case TEEC_MEMREF_TEMP_INPUT: case TEEC_MEMREF_TEMP_OUTPUT: case TEEC_MEMREF_TEMP_INOUT: res = teec_pre_process_tmpref(ctx, param_type, \u0026amp;operation-\u0026gt;params[n].tmpref, params + n, shms + n); //主要关心的是对temref处理，见下面实现 \tif (res != TEEC_SUCCESS) return res; break; /* memref需要先申请一块share_memory，在CA中就直接写入共享内存 */ /* 在CA申请共享内存有两种方式 1. TEEC_AllocateSharedMemory 若上下文中reg_mem为true则将申请一块新内存，注册进内核作为新增的共享内存。 否则将从mmap一块内核中的共享内存，供CA使用。 2. TEEC_RegisterSharedMemory 与TEEC_AllocateSharedMemory基本一样，区别在于此时注册的进共享内存需要在外面申请好。 */ case TEEC_MEMREF_WHOLE: res = teec_pre_process_whole( \u0026amp;operation-\u0026gt;params[n].memref, params + n); if (res != TEEC_SUCCESS) return res; break; case TEEC_MEMREF_PARTIAL_INPUT: case TEEC_MEMREF_PARTIAL_OUTPUT: case TEEC_MEMREF_PARTIAL_INOUT: res = teec_pre_process_partial(param_type, \u0026amp;operation-\u0026gt;params[n].memref, params + n); if (res != TEEC_SUCCESS) return res; break; default: return TEEC_ERROR_BAD_PARAMETERS; } } return TEEC_SUCCESS; } static TEEC_Result teec_pre_process_tmpref(TEEC_Context *ctx, uint32_t param_type, TEEC_TempMemoryReference *tmpref, struct tee_ioctl_param *param, TEEC_SharedMemory *shm) { TEEC_Result res = TEEC_ERROR_GENERIC; /* 设置一些param和share_memory的属性，通常是读写属性 */ switch (param_type) { /*input tee预计做读操作， output tee预计做写操作， inout tee将读写整块区域*/ case TEEC_MEMREF_TEMP_INPUT: param-\u0026gt;attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT; shm-\u0026gt;flags = TEEC_MEM_INPUT; break; ... } /* 入参buffer的长度，后面去申请shm将会以这个长度去申请 */ shm-\u0026gt;size = tmpref-\u0026gt;size; if (!tmpref-\u0026gt;buffer \u0026amp;\u0026amp; ctx-\u0026gt;memref_null) { if (tmpref-\u0026gt;size) return TEEC_ERROR_BAD_PARAMETERS; /* Null pointer, indicate no shared memory attached */ param-\u0026gt;u.memref.shm_id = TEE_MEMREF_NULL; shm-\u0026gt;id = -1; } else { res = TEEC_AllocateSharedMemory(ctx, shm); // 申请share_memory \tif (res != TEEC_SUCCESS) return res; //将入参buffer拷入申请share_memory \tmemcpy(shm-\u0026gt;buffer, tmpref-\u0026gt;buffer, tmpref-\u0026gt;size); param-\u0026gt;u.memref.shm_id = shm-\u0026gt;id; } param-\u0026gt;u.memref.size = tmpref-\u0026gt;size; return TEEC_SUCCESS; }   内核tee_driver(el1): 用户态到内核态的中间发生了啥 驱动的初始化相关分析见：https://blog.csdn.net/shuaifengyun/article/details/72934531\n首先我们要有一个概念，tee的driver是一个两层结构，第一层在开源内核代码driver/tee/tee_core.c中，其提供了一个设备创建的框架，提供了基础的open/ioctl的操作的外层封装。第二层才是真正的具体的实现, 具体挂载方式在下面代码分析可以看到。optee中是实现在driver/tee/optee中。当然厂商可以根据自己的需求，去挂载自己的实现，这也是二层结构的主要意义，厂商开发自己的驱动不必过于关心设备的创建问题，只要关心驱动的具体实现就好。\n此处主要分析ioctl到open_session的流程。 分析内核首先得找到f_ops：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* driver/tee/tee_core.c */ struct tee_device *tee_device_alloc(const struct tee_desc *teedesc, struct device *dev, struct tee_shm_pool *pool, void *driver_data) { struct tee_device *teedev; /* 驱动的全局变量，包含了驱动中各个驱动的结构 */ void *ret; int rc, max_id; int offs = 0; teedev = kzalloc(sizeof(*teedev), GFP_KERNEL); ... cdev_init(\u0026amp;teedev-\u0026gt;cdev, \u0026amp;tee_fops); // tee的驱动为字符设备，tee_fops here! \t... dev_set_drvdata(\u0026amp;teedev-\u0026gt;dev, driver_data); device_initialize(\u0026amp;teedev-\u0026gt;dev); ... /* 挂载上的二级结构，看下面的分析 */ teedev-\u0026gt;desc = teedesc; } EXPORT_SYMBOL_GPL(tee_device_alloc); static const struct file_operations tee_fops = { .owner = THIS_MODULE, .open = tee_open, // open入口 \t.release = tee_release, .unlocked_ioctl = tee_ioctl, // ioctl入口 \t.compat_ioctl = compat_ptr_ioctl, };   首先看看tee_open的操作，由TEEC_InitializeContext调用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  /* driver/tee/tee_core.c */ static int tee_open(struct inode *inode, struct file *filp) { struct tee_context *ctx; /* 初始化好打开设备的上下文, 通过inode中的i_cdev找到驱动全局变量teedev */ ctx = teedev_open(container_of(inode-\u0026gt;i_cdev, struct tee_device, cdev)); if (IS_ERR(ctx)) return PTR_ERR(ctx); /* * Default user-space behaviour is to wait for tee-supplicant * if not present for any requests in this context. */ ctx-\u0026gt;supp_nowait = false; filp-\u0026gt;private_data = ctx; return 0; } static struct tee_context *teedev_open(struct tee_device *teedev) { int rc; struct tee_context *ctx; if (!tee_device_get(teedev)) return ERR_PTR(-EINVAL); ctx = kzalloc(sizeof(*ctx), GFP_KERNEL); // 创建上下文 \tif (!ctx) { rc = -ENOMEM; goto err; } kref_init(\u0026amp;ctx-\u0026gt;refcount); ctx-\u0026gt;teedev = teedev; INIT_LIST_HEAD(\u0026amp;ctx-\u0026gt;list_shm); /* 真正的open操作，由optee驱动的desc-\u0026gt;op提供. 如上文所说，tee_driver是一个外层框架，其驱动真正实现的挂载点正是此处 */ rc = teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;open(ctx); if (rc) goto err; return ctx; err: kfree(ctx); tee_device_put(teedev); return ERR_PTR(rc); } /* desc 挂载的位置： driver/tee/optee/core.c*/ static struct optee *optee_probe(struct device_node *np) { ... invoke_fn = get_invoke_func(np); // 此处将为触发smc的函数挂载  ... optee-\u0026gt;invoke_fn = invoke_fn; ... /* 调用了上面的tee_device_alloc，注册上了具体的tee驱动描述和op*/ teedev = tee_device_alloc(\u0026amp;optee_desc, NULL, pool, optee); if (IS_ERR(teedev)) { rc = PTR_ERR(teedev); goto err; } optee-\u0026gt;teedev = teedev; teedev = tee_device_alloc(\u0026amp;optee_supp_desc, NULL, pool, optee); if (IS_ERR(teedev)) { rc = PTR_ERR(teedev); goto err; } optee-\u0026gt;supp_teedev = teedev; ... } static optee_invoke_fn *get_invoke_func(struct device_node *np) { ... else if (!strcmp(\u0026#34;smc\u0026#34;, method)) return optee_smccc_smc; //optee-\u0026gt;invoke_fn = optee_smccc_smc； \t... } static const struct tee_driver_ops optee_ops = { .get_version = optee_get_version, .open = optee_open, // open函数， 不具体分析了，主要还是用于初始化打开tee设备的上下文 \t.release = optee_release, //ioctl下的操作，如open_session: \t.open_session = optee_open_session, .close_session = optee_close_session, .invoke_func = optee_invoke_func, .cancel_req = optee_cancel_req, .shm_register = optee_shm_register, .shm_unregister = optee_shm_unregister, }; static const struct tee_desc optee_desc = { .name = DRIVER_NAME \u0026#34;-clnt\u0026#34;, .ops = \u0026amp;optee_ops, .owner = THIS_MODULE, };   有了对teedev_open的分析，分析ioctl相关操作也就并不复杂了，直接看tee_ioctl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  /* driver/tee/tee_core.c */ static long tee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct tee_context *ctx = filp-\u0026gt;private_data; void __user *uarg = (void __user *)arg; switch (cmd) { ... /* 主要看open_session */ case TEE_IOC_OPEN_SESSION: return tee_ioctl_open_session(ctx, uarg); ... } } static int tee_ioctl_open_session(struct tee_context *ctx, struct tee_ioctl_buf_data __user *ubuf) { int rc; size_t n; struct tee_ioctl_buf_data buf; struct tee_ioctl_open_session_arg __user *uarg; struct tee_ioctl_open_session_arg arg; struct tee_ioctl_param __user *uparams = NULL; struct tee_param *params = NULL; bool have_session = false; if (!ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;open_session) return -EINVAL; if (copy_from_user(\u0026amp;buf, ubuf, sizeof(buf))) return -EFAULT; if (buf.buf_len \u0026gt; TEE_MAX_ARG_SIZE || buf.buf_len \u0026lt; sizeof(struct tee_ioctl_open_session_arg)) return -EINVAL; /* 这一段操作都是将用户态的args拷贝到内核态，恢复对应的结构体；和普通驱动操作差不多 */ uarg = u64_to_user_ptr(buf.buf_ptr); if (copy_from_user(\u0026amp;arg, uarg, sizeof(arg))) return -EFAULT; if (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len) return -EINVAL; if (arg.num_params) { params = kcalloc(arg.num_params, sizeof(struct tee_param), GFP_KERNEL); if (!params) return -ENOMEM; uparams = uarg-\u0026gt;params; rc = params_from_user(ctx, params, arg.num_params, uparams); if (rc) goto out; } // 从上一段源码可看到挂载的具体处理函数为optee_open_session, \trc = ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;open_session(ctx, \u0026amp;arg, params); if (rc) goto out; have_session = true; /* 将结果拷贝回用户态空间 */ if (put_user(arg.session, \u0026amp;uarg-\u0026gt;session) || put_user(arg.ret, \u0026amp;uarg-\u0026gt;ret) || put_user(arg.ret_origin, \u0026amp;uarg-\u0026gt;ret_origin)) { rc = -EFAULT; goto out; } rc = params_to_user(uparams, arg.num_params, params); out: /* * If we\u0026#39;ve succeeded to open the session but failed to communicate * it back to user space, close the session again to avoid leakage. */ if (rc \u0026amp;\u0026amp; have_session \u0026amp;\u0026amp; ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;close_session) ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;close_session(ctx, arg.session); if (params) { /* Decrease ref count for all valid shared memory pointers */ for (n = 0; n \u0026lt; arg.num_params; n++) if (tee_param_is_memref(params + n) \u0026amp;\u0026amp; params[n].u.memref.shm) tee_shm_put(params[n].u.memref.shm); kfree(params); } return rc; }   内核切换到安全世界做了啥 之后ioctl将进入cpu切换安全世界的准备工作：optee_msg_arg是最重要的结构体，他是安全世界与非安全世界信息的结构体。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  struct optee_msg_arg { uint32_t cmd; uint32_t func; uint32_t session; uint32_t cancel_id; uint32_t pad; uint32_t ret; uint32_t ret_origin; uint32_t num_params; /* num_params tells the actual number of element in params */ struct optee_msg_param params[]; }; /* driver/tee/optee/call.c */ int optee_open_session(struct tee_context *ctx, struct tee_ioctl_open_session_arg *arg, struct tee_param *param) { struct optee_context_data *ctxdata = ctx-\u0026gt;data; int rc; struct tee_shm *shm; struct optee_msg_arg *msg_arg; phys_addr_t msg_parg; struct optee_session *sess = NULL; /* +2 for the meta parameters added below */ /* 这个函数用来申请传递smc的具体msg的共享内存空间，安全与非安全通过该结构体完成通信 msg_parg是具体的物理地址，通过该物理地址传递具体cmd参数 （安全态和非安全态维护着不同的页表） */ shm = get_msg_arg(ctx, arg-\u0026gt;num_params + 2, \u0026amp;msg_arg, \u0026amp;msg_parg); if (IS_ERR(shm)) return PTR_ERR(shm); /* 指定上具体的smc msg中的cmd，此处将去完成open_session操作 */ msg_arg-\u0026gt;cmd = OPTEE_MSG_CMD_OPEN_SESSION; msg_arg-\u0026gt;cancel_id = arg-\u0026gt;cancel_id; /* * Initialize and add the meta parameters needed when opening a * session. * 主要包含上uuid和client_uuid： * uuid是一个TA服务的唯一标识符 */ msg_arg-\u0026gt;params[0].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT | OPTEE_MSG_ATTR_META; msg_arg-\u0026gt;params[1].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT | OPTEE_MSG_ATTR_META; memcpy(\u0026amp;msg_arg-\u0026gt;params[0].u.value, arg-\u0026gt;uuid, sizeof(arg-\u0026gt;uuid)); memcpy(\u0026amp;msg_arg-\u0026gt;params[1].u.value, arg-\u0026gt;uuid, sizeof(arg-\u0026gt;clnt_uuid)); msg_arg-\u0026gt;params[1].u.value.c = arg-\u0026gt;clnt_login; /* 我们主要关心的函数：将用户态传下来的数据拷入上面申请的smc通讯共享内存中params的字段 */ rc = optee_to_msg_param(msg_arg-\u0026gt;params + 2, arg-\u0026gt;num_params, param); if (rc) goto out; sess = kzalloc(sizeof(*sess), GFP_KERNEL); if (!sess) { rc = -ENOMEM; goto out; } /* 此处将触发smc指令，cpu进入el3的atf中*/ if (optee_do_call_with_arg(ctx, msg_parg)) { msg_arg-\u0026gt;ret = TEEC_ERROR_COMMUNICATION; msg_arg-\u0026gt;ret_origin = TEEC_ORIGIN_COMMS; } if (msg_arg-\u0026gt;ret == TEEC_SUCCESS) { /* A new session has been created, add it to the list. */ sess-\u0026gt;session_id = msg_arg-\u0026gt;session; mutex_lock(\u0026amp;ctxdata-\u0026gt;mutex); list_add(\u0026amp;sess-\u0026gt;list_node, \u0026amp;ctxdata-\u0026gt;sess_list); mutex_unlock(\u0026amp;ctxdata-\u0026gt;mutex); } else { kfree(sess); } /* 将拷贝数据从msg共享内存拷贝回非安全入参的共享内存中 */ ... } int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params, const struct tee_param *params) { int rc; size_t n; for (n = 0; n \u0026lt; num_params; n++) { /*value类型的传参，赋值即可，memref的buffer入参如下处理：*/ ... case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT: /* 将shm注册进msg_param结构体中 * tmp需要写入具体物理地址，ref直接写入shm结构体即可 */ if (tee_shm_is_registered(p-\u0026gt;u.memref.shm)) rc = to_msg_param_reg_mem(mp, p); else rc = to_msg_param_tmp_mem(mp, p); if (rc) return rc; break; default: return -EINVAL; } } return 0; }   参数准备好之后，开始配置寄存器，触发smc指令，完成切换到el3，准备进行CPU安全态与非安全态切换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  /* driver/tee/optee/call.c */ u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg) { struct optee *optee = tee_get_drvdata(ctx-\u0026gt;teedev); struct optee_call_waiter w; struct optee_rpc_param param = { }; struct optee_call_ctx call_ctx = { }; u32 ret; /* 准备好寄存器的值 */ /* r0: smc_call的命令 */ param.a0 = OPTEE_SMC_CALL_WITH_ARG; /* r1, r2: 上面准备好的msg结构体的物理地址, r1低32位，r2高32位，通过寄存器传递给安全侧 */ reg_pair_from_64(\u0026amp;param.a1, \u0026amp;param.a2, parg); /* Initialize waiter */ optee_cq_wait_init(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); while (true) { struct arm_smccc_res res; optee_bm_timestamp(); /*如上文optee_probe所示， 此处将挂载上optee_smccc_smc */ optee-\u0026gt;invoke_fn(param.a0, param.a1, param.a2, param.a3, param.a4, param.a5, param.a6, param.a7, \u0026amp;res); optee_bm_timestamp(); if (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) { /* * Out of threads in secure world, wait for a thread * become available. */ optee_cq_wait_for_completion(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); } else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) { might_sleep(); param.a0 = res.a0; param.a1 = res.a1; param.a2 = res.a2; param.a3 = res.a3; optee_handle_rpc(ctx, \u0026amp;param, \u0026amp;call_ctx); } else { ret = res.a0; break; } } optee_rpc_finalize_call(\u0026amp;call_ctx); /* * We\u0026#39;re done with our thread in secure world, if there\u0026#39;s any * thread waiters wake up one. */ optee_cq_wait_final(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); return ret; } /* driver/tee/optee/core /* Simple wrapper functions to be able to use a function pointer */ static void optee_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4, unsigned long a5, unsigned long a6, unsigned long a7, struct arm_smccc_res *res) { arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res); }   触发smc处：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /* include/linux/arm-smccc.h */ #define arm_smccc_smc(...) __arm_smccc_smc(__VA_ARGS__, NULL) ... asmlinkage void __arm_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4, unsigned long a5, unsigned long a6, unsigned long a7, struct arm_smccc_res *res, struct arm_smccc_quirk *quirk); /* arch/arm64/kernel/smccc-call.S */ .macro SMCCC instr .cfi_startproc \\instr\t#0 /* smc 0, 此处触发smc指令进入el3 atf */ ldr\tx4, [sp] stp\tx0, x1, [x4, #ARM_SMCCC_RES_X0_OFFS] /* smc指令回来之后，保存结果寄存器状态 */ stp\tx2, x3, [x4, #ARM_SMCCC_RES_X2_OFFS] ldr\tx4, [sp, #8] cbz\tx4, 1f /* no quirk structure */ ldr\tx9, [x4, #ARM_SMCCC_QUIRK_ID_OFFS] cmp\tx9, #ARM_SMCCC_QUIRK_QCOM_A6 b.ne\t1f str\tx6, [x4, ARM_SMCCC_QUIRK_STATE_OFFS] 1:\tret .cfi_endproc .endm /* * void arm_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2, *\tunsigned long a3, unsigned long a4, unsigned long a5, *\tunsigned long a6, unsigned long a7, struct arm_smccc_res *res, *\tstruct arm_smccc_quirk *quirk) */ ENTRY(__arm_smccc_smc) SMCCC\tsmc ENDPROC(__arm_smccc_smc) EXPORT_SYMBOL(__arm_smccc_smc)   具体流程参考下图：\nArm Trusted firmware(ATF, el3) 之后CPU陷入EL3态，进入ATF，ATF主要确认TEE kernel入口(std_smc或者fast_smc模式，有不同的入口)，非安全世界寄存器上下文的保存工作，修改CPU系统寄存器SCR的NS状态为安全位等，此处不细讲，具体可以看：\nhttps://blog.csdn.net/shuaifengyun/article/details/73118852\nTEE_kernel kernel为smc_call创建线程并启动线程 ATF完成好工作后, CPU进入sel1状态, 代码运行的入口由ATF复原并选择，以arm64为例：\n/* optee-src/core/arch/arm/kernel/thread_optee_smc_a64.S */ /* * Vector table supplied to ARM Trusted Firmware (ARM-TF) at * initialization. * * Note that ARM-TF depends on the layout of this vector table, any change * in layout has to be synced with ARM-TF. */ FUNC thread_vector_table , : , .identity_map b\tvector_std_smc_entry b\tvector_fast_smc_entry b\tvector_cpu_on_entry b\tvector_cpu_off_entry b\tvector_cpu_resume_entry b\tvector_cpu_suspend_entry b\tvector_fiq_entry b\tvector_system_off_entry b\tvector_system_reset_entry END_FUNC thread_vector_table KEEP_PAGER thread_vector_table LOCAL_FUNC vector_std_smc_entry , : , .identity_map readjust_pc bl\tthread_handle_std_smc /* * Normally thread_handle_std_smc() should return via * thread_exit(), thread_rpc(), but if thread_handle_std_smc() * hasn\u0026#39;t switched stack (error detected) it will do a normal \u0026#34;C\u0026#34; * return. */ mov\tw1, w0 ldr\tx0, =TEESMC_OPTEED_RETURN_CALL_DONE smc\t#0 b\t.\t/* SMC should not return */ END_FUNC vector_std_smc_entry open_session将进入vector_std_smc_entry-\u0026gt;thread_handle_std_smc，进一步分析TEE的内核如何处理一条smc_call:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* optee-src/core/arch/arm/kernel/thread.c */ uint32_t thread_handle_std_smc(uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5, uint32_t a6 __unused, uint32_t a7 __maybe_unused) { uint32_t rv = OPTEE_SMC_RETURN_OK; /* 检查tee堆栈的canary，是否有溢出情况 */ thread_check_canaries(); ... /* * thread_resume_from_rpc() and thread_alloc_and_run() only return * on error. Successful return is done via thread_exit() or * thread_rpc(). */ /* smc_call来自rpc(非安全侧响应tee的命令的守护进程)分支 */ if (a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC) { thread_resume_from_rpc(a3, a1, a2, a4, a5); rv = OPTEE_SMC_RETURN_ERESUME; } else { /* smc_call来自Libteec，主要包括open session, close session, invoke等 */ /*a0-a3对应寄存器r0-r3*/ thread_alloc_and_run(a0, a1, a2, a3); rv = OPTEE_SMC_RETURN_ETHREAD_LIMIT; } ... }   thread_alloc_and_run将对于来自libteec的smc_call创建一个thread:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  /* optee-src/core/arch/arm/thread.c */ void thread_alloc_and_run(uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3) { size_t n; struct thread_core_local *l = thread_get_core_local(); bool found_thread = false; /* 确定当前核上没有线程占据， * 特别注意，OPTEE每一个核只能有一个线程运行 */ assert(l-\u0026gt;curr_thread == -1); thread_lock_global(); /* 从全局变量的thread中，拿出一个分配给当前的请求 */ for (n = 0; n \u0026lt; CFG_NUM_THREADS; n++) { if (threads[n].state == THREAD_STATE_FREE) { threads[n].state = THREAD_STATE_ACTIVE; found_thread = true; break; } } thread_unlock_global(); if (!found_thread) return; l-\u0026gt;curr_thread = n; threads[n].flags = 0; /* 初始化thread的各种寄存器上下文 */ init_regs(threads + n, a0, a1, a2, a3); thread_lazy_save_ns_vfp(); /* 线程启动 */ thread_resume(\u0026amp;threads[n].regs); /*NOTREACHED*/ panic(); } static void init_regs(struct thread_ctx *thread, uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3) { /* 指定该线程上下文中PC指针的地址，当该thread resume回来之后就会开始执行regs.pc执 * 行的函数 */ thread-\u0026gt;regs.pc = (uint64_t)thread_std_smc_entry; /* * Stdcalls starts in SVC mode with masked foreign interrupts, masked * Asynchronous abort and unmasked native interrupts. */ thread-\u0026gt;regs.cpsr = SPSR_64(SPSR_64_MODE_EL1, SPSR_64_MODE_SP_EL0, THREAD_EXCP_FOREIGN_INTR | DAIFBIT_ABT); /* Reinitialize stack pointer */ thread-\u0026gt;regs.sp = thread-\u0026gt;stack_va_end; /* * Copy arguments into context. This will make the * arguments appear in x0-x7 when thread is started. */ thread-\u0026gt;regs.x[0] = a0; thread-\u0026gt;regs.x[1] = a1; thread-\u0026gt;regs.x[2] = a2; thread-\u0026gt;regs.x[3] = a3; thread-\u0026gt;regs.x[4] = 0; thread-\u0026gt;regs.x[5] = 0; thread-\u0026gt;regs.x[6] = 0; thread-\u0026gt;regs.x[7] = 0; /* Set up frame pointer as per the Aarch64 AAPCS */ thread-\u0026gt;regs.x[29] = 0; }   thread_resume将启动线程， 该函数为汇编代码，主要是保存一些寄存器状态，并且指定thread运行在什么模式。\n/* optee-src/core/arch/arm/kernel/arm64_macros.S*/ /* void thread_resume(struct thread_ctx_regs *regs) */ FUNC thread_resume , : /* 恢复线程寄存器状态 */ /* 加载结构体中前三个寄存器sp, pc, cpsr到x1, x2, x3，见下thread_ctx_regs结构体 */ load_xregs x0, THREAD_CTX_REGS_SP, 1, 3 /* 加载结构体x4-x30 */ load_xregs x0, THREAD_CTX_REGS_X4, 4, 30 /* 恢复sp, pc, cpsr, pc加载进elr_el1，即触发返回时将执行到该地址： * thread_std_smc_entry */\tmov\tsp, x1 msr\telr_el1, x2 msr\tspsr_el1, x3 b_if_spsr_is_el0 w3, 1f /* 处理由ta触发svc下陷到sel1的操作，CA过来的操作不走这条路 */ /* 恢复 x0 - x3 */ load_xregs x0, THREAD_CTX_REGS_X1, 1, 3 ldr\tx0, [x0, THREAD_CTX_REGS_X0] /* 触发函数返回， 进入thread_std_smc_entry */ eret 1:\tload_xregs x0, THREAD_CTX_REGS_X1, 1, 3 ldr\tx0, [x0, THREAD_CTX_REGS_X0] msr\tspsel, #1 store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1 b\teret_to_el0 END_FUNC thread_resume /* optee-src/core/arch/arm/include/kernel/thread.h */ /* 线程寄存器上下文 */ struct thread_ctx_regs { uint64_t sp; uint64_t pc; uint64_t cpsr; uint64_t x[31]; }; 在init_regs中的regs.pc中已经制定了该thread被resume回来之后的pc指针为thread_std_smc_entry，当thread被resume之后就会去执行该函数：\n/* optee-src/core/arch/arm/kernel/thread_optee_smc_a64.S */ FUNC thread_std_smc_entry , : bl\t__thread_std_smc_entry /* 线程入口，此时线程真正启动起来 */ mov\tw20, w0\t/* Save return value for later */ /* Mask all maskable exceptions before switching to temporary stack */ msr\tdaifset, #DAIFBIT_ALL bl\tthread_get_tmp_sp mov\tsp, x0 bl\tthread_state_free ldr\tx0, =TEESMC_OPTEED_RETURN_CALL_DONE mov\tw1, w20 mov\tx2, #0 mov\tx3, #0 mov\tx4, #0 /* 触发smc，退出安全世界，进入el3 */ smc\t#0 b\t.\t/* SMC should not return */ END_FUNC thread_std_smc_entry 用一张图表示如下：\nkernel对msg的处理 __thread_std_smc_entry对于不同的硬件环境可能有一些不同的处理，是一个weak函数，但最终都将进入函数\ntee_entry_std，注意r0带着smc_call的cmd，r1，r2两个寄存器保存着optee_msg的物理地址，这些都是来自于非安全世界的传入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  static uint32_t std_smc_entry(uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3 __unused) { paddr_t parg = 0; struct optee_msg_arg *arg = NULL; uint32_t num_params = 0; struct mobj *mobj = NULL; uint32_t rv = 0; /* 此处可以看到来自CA的请求,r0只能是OPTEE_SMC_CALL_WITH_ARG */ if (a0 != OPTEE_SMC_CALL_WITH_ARG) { EMSG(\u0026#34;Unknown SMC 0x%\u0026#34;PRIx32, a0); DMSG(\u0026#34;Expected 0x%x\u0026#34;, OPTEE_SMC_CALL_WITH_ARG); return OPTEE_SMC_RETURN_EBADCMD; } /* 通过r1-r2恢复msg的物理地址 */ parg = reg_pair_to_64(a1, a2); /* Check if this region is in static shared space */ if (core_pbuf_is(CORE_MEM_NSEC_SHM, parg, sizeof(struct optee_msg_arg))) { /* 此处将物理地址转成安全世界中的虚拟地址 */ mobj = get_cmd_buffer(parg, \u0026amp;num_params); } else { if (parg \u0026amp; SMALL_PAGE_MASK) return OPTEE_SMC_RETURN_EBADADDR; mobj = map_cmd_buffer(parg, \u0026amp;num_params); } if (!mobj || !ALIGNMENT_IS_OK(parg, struct optee_msg_arg)) { EMSG(\u0026#34;Bad arg address 0x%\u0026#34; PRIxPA, parg); mobj_put(mobj); return OPTEE_SMC_RETURN_EBADADDR; } /* mobj_shm_alloc函数完成了mobj的申请，拿到va即可，获得msg的虚拟地址 */ arg = mobj_get_va(mobj, 0); assert(arg \u0026amp;\u0026amp; mobj_is_nonsec(mobj)); /* 获取msg，开始处理请求 */ rv = tee_entry_std(arg, num_params); mobj_put(mobj); return rv; } static struct mobj *get_cmd_buffer(paddr_t parg, uint32_t *num_params) { struct optee_msg_arg *arg; size_t args_size; /* arg的地址在此 */ arg = phys_to_virt(parg, MEM_AREA_NSEC_SHM); if (!arg) return NULL; /* 读取params的数量 */ *num_params = READ_ONCE(arg-\u0026gt;num_params); if (*num_params \u0026gt; OPTEE_MSG_MAX_NUM_PARAMS) return NULL; args_size = OPTEE_MSG_GET_ARG_SIZE(*num_params); /* optee中的对于虚拟内存分解成mobj(memory object)结构体，将保存虚拟地址，物理地址等 */ return mobj_shm_alloc(parg, args_size, 0); }   Open_session 内核的处理流程 过了这么久的流程，终于来到了TEE真正处理请求操作的代码:\nopen_session主要完成的工作就是确定TA处理服务cmd(invoke_command)的代码入口，其3.5版本之后有一个巨大的改版，3.5之后版本的实现后续将简单提到一下，此处我们先看3.5版本的实现方式：\n其流程非常复杂，先贴一张大神总结的流程图，顺着这个往下看，后面我们解读一些关键步骤的源码：\n图太大，看起来很复杂，我们总结几个重点：\n 构造session与寻找目标TA是否已经加载：所有的session会以一个链表的形式存在一个结构体struct tee_ta_session_head中，主要 在src/core/kernel/tee_ta_manager.c中的tee_ta_init_session函数中。同时确定目标TA已打开过，打开过则将直接将该ta的上下文返回，进入TA中的打开session操作中。 加载TA：从tee发起的对ree侧的服务请求RPC，呼叫守护进程tee_supplicant将TA加载进一段共享内存中，并 触发smc返回安全侧 TEE将恢复线程，并对TA进行elf格式校验与签名校验(验签的公钥被编入了tee_kernel中，需要在编译时放在指定文件夹) 若验签成功，TEE将加载TA进入安全内存中，通过TA头中对各函数地址偏移的指定，进入TA的open_session 的entry，完成TA中指定的处理后，返回REE侧  TEE_kernel 处理入口 简单分析一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  /* optee-src/core/arch/arm/entry_std.c */ uint32_t __tee_entry_std(struct optee_msg_arg *arg, uint32_t num_params) { uint32_t rv = OPTEE_SMC_RETURN_OK; /* Enable foreign interrupts for STD calls */ thread_set_foreign_intr(true); switch (arg-\u0026gt;cmd) { /* 回忆起来, tee_driver填的cmd为OPTEE_MSG_CMD_OPEN_SESSION */ case OPTEE_MSG_CMD_OPEN_SESSION: entry_open_session(arg, num_params); break; ... return rv;\t} static void entry_open_session(struct optee_msg_arg *arg, uint32_t num_params) { TEE_Result res; TEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE; struct tee_ta_session *s = NULL; TEE_Identity clnt_id; TEE_UUID uuid; struct tee_ta_param param; size_t num_meta; uint64_t saved_attr[TEE_NUM_PARAMS] = { 0 }; /* 获取一些基本的参数，在驱动侧我们能看到前两个params是驱动填充的，是一些meta数据： * 1. uuid，用来确定加载的TA的名字 * 2. 参数个数 * 3. clnt_id (这个具体其实没有具体使用，可能后续将用于客户端鉴权) */ res = get_open_session_meta(num_params, arg-\u0026gt;params, \u0026amp;num_meta, \u0026amp;uuid, \u0026amp;clnt_id); if (res != TEE_SUCCESS) goto out; /* 此处是非常关键的安全操作：将共享内存中的param拷贝到安全内存中 */ res = copy_in_params(arg-\u0026gt;params + num_meta, num_params - num_meta, \u0026amp;param, saved_attr); if (res != TEE_SUCCESS) goto cleanup_shm_refs; /* 之后所有的操作都在此函数中完成，以下流程都在该函数中进行 */ res = tee_ta_open_session(\u0026amp;err_orig, \u0026amp;s, \u0026amp;tee_open_sessions, \u0026amp;uuid, \u0026amp;clnt_id, TEE_TIMEOUT_INFINITE, \u0026amp;param); if (res != TEE_SUCCESS) s = NULL; ... }   构造session与寻找目标TA是否已经加载 tee_ta_open_session第一步就是去初始化session：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  /* core/kernel/tee_ta_manager.c */ TEE_Result tee_ta_open_session(TEE_ErrorOrigin *err, struct tee_ta_session **sess, struct tee_ta_session_head *open_sessions, const TEE_UUID *uuid, const TEE_Identity *clnt_id, uint32_t cancel_req_to, struct tee_ta_param *param) { TEE_Result res; struct tee_ta_session *s = NULL; struct tee_ta_ctx *ctx; bool panicked; bool was_busy = false; res = tee_ta_init_session(err, open_sessions, uuid, \u0026amp;s); if (res != TEE_SUCCESS) { DMSG(\u0026#34;init session failed 0x%x\u0026#34;, res); return res; } ... } static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *err, struct tee_ta_session_head *open_sessions, const TEE_UUID *uuid, struct tee_ta_session **sess) { TEE_Result res; struct tee_ta_ctx *ctx; /* session结构体的初始化，ta_ctx上下文也将注册进此结构体 */ struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session)); ... /* Look for already loaded TA */ ctx = tee_ta_context_find(uuid); if (ctx) { res = tee_ta_init_session_with_context(ctx, s); if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND) goto out; } /* Look for pseudo TA */ /* 静态 pseudo TA是指已经一起连编进optee内核的一些TA。 * 这种TA打开比较简单，搜索内核中PTA的段，匹配对应的uuid，若匹配上，则直接进入open_session处理 * 由于是与optee内核连编，无需验签 */ res = tee_ta_init_pseudo_ta_session(uuid, s); if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND) goto out; /* Look for user TA */ /* 关键函数，假如我们要加载从文件系统/安全存储上的TA，走这个分支，我们这里主要观察 */ res = tee_ta_init_user_ta_session(uuid, s); ... }   加载TA与签名认证 tee_ta_init_user_ta_session 核心处理函数就是load_elf函数，他将发起一个从TEE到REE的请求，请求去加载文件系统上指定UUID的TA。\n首先看一下TA的结构：\n可以看到，TA是分段的，而加载过程中，只需要加载TA raw image即可，但加载前需要对其进行校验，其校验方法参看下文：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /* core/arch/arm/kernel/user_ta.c */ static TEE_Result load_elf(const TEE_UUID *uuid, struct user_ta_ctx *utc) { TEE_Result res = TEE_ERROR_ITEM_NOT_FOUND; const struct user_ta_store_ops *op = NULL; /* ta_stores总共有三个，我们主管关心runtime时从文件系统上加载TA，其注册的op在底下 */ SCATTERED_ARRAY_FOREACH(op, ta_stores, struct user_ta_store_ops) { DMSG(\u0026#34;Lookup user TA ELF %pUl (%s)\u0026#34;, (void *)uuid, op-\u0026gt;description); res = load_elf_from_store(uuid, op, utc); ... } /* core/arch/arm/kernel/ree_fs_ta.c */ TEE_TA_REGISTER_TA_STORE(9) = { .description = \u0026#34;REE\u0026#34;, .open = ree_fs_ta_open, /*此处注册上了open函数*/ .get_size = ree_fs_ta_get_size, .read = ree_fs_ta_read, .close = ree_fs_ta_close, };   load_elf_from_store将处理将文件系统中的TA加载进安全内存中，并把entry_func入口确定下来，整个流程非常复杂，牵扯到多次TEE到REE的交互（TEE到REE的交互部分，下个部分tee_supplicant相关章节将着重关注，当前只阐述流程，源码分析可以后续补上。TA实际上还是一个前面有一个签名头的elf文件，其加载过程如下：\n  ta_store-\u0026gt;open(uuid, \u0026amp;handle):TEE让REE首先加载TA头部, 验证头部中hash值的签名，确保头部hash值的可靠性. 并且比较被签名的UUID时候与文件系统上ta命名的UUID相同；\n  elf_load_init：准备好加载elf所需要的状态和处理函数；\n  elf_load_head：加载elf头，updata哈希计算；\n  为TA分配栈空间;\n  get_elf_segments：解析elf段表；\n  elf_load_body: 分段拷贝段并update哈希值，最后一段计算最后hash值与第一步哈希值是否一致；一致的话完成TA加载。\n  之后我们查看TA的入口，入口依然在load_elf_from_store中被定义：我们由TA raw image可以看到，第一个section为.ta_head, 我们看一下这一段的结构体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /* ta/arch/arm/user_ta_header.c */ const struct ta_head ta_head __section(\u0026#34;.ta_head\u0026#34;) = { /* UUID, unique to each TA */ .uuid = TA_UUID, /* * According to GP Internal API, TA_FRAMEWORK_STACK_SIZE corresponds to * the stack size used by the TA code itself and does not include stack * space possibly used by the Trusted Core Framework. * Hence, stack_size which is the size of the stack to use, * must be enlarged */ .stack_size = TA_STACK_SIZE + TA_FRAMEWORK_STACK_SIZE, .flags = TA_FLAGS, #ifdef __ILP32__ \t/* * This workaround is neded on 32-bit because it seems we can\u0026#39;t * initialize a 64-bit integer from the address of a function. */ .entry.ptr32 = { .lo = (uint32_t)__utee_entry }, #else \t.entry.ptr64 = (uint64_t)__utee_entry, #endif };   这一个.section将通过链接的脚本，在TA的编译链接过程中作为raw image的第一个section:\n/* ta/arch/arm/ta.ld.S */ SECTIONS { .ta_head : {*(.ta_head)} .text : { __text_start = .; *(.text .text.*) *(.stub) *(.glue_7) *(.glue_7t) *(.gnu.linkonce.t.*) /* Workaround for an erratum in ARM\u0026#39;s VFP11 coprocessor */ *(.vfp11_veneer) __text_end = .; } ... } /* core/arch/arm/kernel/user_ta.c */ static TEE_Result load_elf_from_store(const TEE_UUID *uuid, const struct user_ta_store_ops *ta_store, struct user_ta_ctx *utc) { ... res = get_elf_segments(elf, \u0026amp;segs, \u0026amp;num_segs); for (n = 0; n \u0026lt; num_segs; n++) { ... /* n == 0时进入该分支 */ if (!n) { elf-\u0026gt;load_addr = segs[0].va; /*elf-\u0026gt;load_addr将指向.ta_head段*/ DMSG(\u0026#34;ELF load address %#\u0026#34; PRIxVA, elf-\u0026gt;load_addr); } } ... } TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *uuid, struct tee_ta_session *s) { ta_head = (struct ta_head *)(vaddr_t)utc-\u0026gt;load_addr; /* 此处比较elf中被签名UUID与TA文件名UUID，保证文件名UUID没有被篡改 */ if (memcmp(\u0026amp;ta_head-\u0026gt;uuid, uuid, sizeof(TEE_UUID)) != 0) { res = TEE_ERROR_SECURITY; goto err; } ... utc-\u0026gt;ctx.flags = ta_head-\u0026gt;flags; utc-\u0026gt;ctx.uuid = ta_head-\u0026gt;uuid; utc-\u0026gt;entry_func = ta_head-\u0026gt;entry.ptr64; /* 即__utee_entry */ ... } 可以看到TA的入口为__utee_entry，之后我们将关注TEE_kernel怎么进行层级切换进入sel0的TA.\nTEE_kernel -\u0026gt; TA 我们回到tee_ta_open_session函数，完成session建立和TA加载后，开始准备进入sel0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /* core/kernel/tee_ta_manager.c */ TEE_Result tee_ta_open_session(TEE_ErrorOrigin *err, struct tee_ta_session **sess, struct tee_ta_session_head *open_sessions, const TEE_UUID *uuid, const TEE_Identity *clnt_id, uint32_t cancel_req_to, struct tee_ta_param *param) { TEE_Result res; struct tee_ta_session *s = NULL; struct tee_ta_ctx *ctx; bool panicked; bool was_busy = false; res = tee_ta_init_session(err, open_sessions, uuid, \u0026amp;s); if (res != TEE_SUCCESS) { DMSG(\u0026#34;init session failed 0x%x\u0026#34;, res); return res; } ... if (tee_ta_try_set_busy(ctx)) { set_invoke_timeout(s, cancel_req_to); res = ctx-\u0026gt;ops-\u0026gt;enter_open_session(s, param, err); /* 此处开始准备切换层级 */ tee_ta_clear_busy(ctx); } else { /* Deadlock avoided */ res = TEE_ERROR_BUSY; was_busy = true; } ... }   ctx-\u0026gt;ops在tee_ta_init_user_ta_session中已经完成挂载:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  /* core/arch/arm/kernel/user_ta.c */ TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *uuid, struct tee_ta_session *s) { ... /* * Set context TA operation structure. It is required by generic * implementation to identify userland TA versus pseudo TA contexts. */ set_ta_ctx_ops(\u0026amp;utc-\u0026gt;ctx); ... } static const struct tee_ta_ops user_ta_ops __rodata_unpaged = { .enter_open_session = user_ta_enter_open_session, /* enter_open_session 挂载点 */ .enter_invoke_cmd = user_ta_enter_invoke_cmd, .enter_close_session = user_ta_enter_close_session, .dump_state = user_ta_dump_state, .destroy = user_ta_ctx_destroy, .get_instance_id = user_ta_get_instance_id, }; /* * Break unpaged attribute dependency propagation to user_ta_ops structure * content thanks to a runtime initialization of the ops reference. */ static struct tee_ta_ops const *_user_ta_ops; static TEE_Result init_user_ta(void) { _user_ta_ops = \u0026amp;user_ta_ops; return TEE_SUCCESS; } service_init(init_user_ta); /* optee启动时将初始化user_ta_ops */ static void set_ta_ctx_ops(struct tee_ta_ctx *ctx) { ctx-\u0026gt;ops = _user_ta_ops; } /* res = ctx-\u0026gt;ops-\u0026gt;enter_open_session(s, param, err)的入口 */ static TEE_Result user_ta_enter_open_session(struct tee_ta_session *s, struct tee_ta_param *param, TEE_ErrorOrigin *eo) { return user_ta_enter(eo, s, UTEE_ENTRY_FUNC_OPEN_SESSION, 0, param); } static TEE_Result user_ta_enter(TEE_ErrorOrigin *err, struct tee_ta_session *session, enum utee_entry_func func, uint32_t cmd, struct tee_ta_param *param) { TEE_Result res; struct utee_params *usr_params; uaddr_t usr_stack; struct user_ta_ctx *utc = to_user_ta_ctx(session-\u0026gt;ctx); TEE_ErrorOrigin serr = TEE_ORIGIN_TEE; struct tee_ta_session *s __maybe_unused; void *param_va[TEE_NUM_PARAMS] = { NULL }; /* Map user space memory */ res = tee_mmu_map_param(utc, param, param_va); if (res != TEE_SUCCESS) goto cleanup_return; /* Switch to user ctx */ tee_ta_push_current_session(session); /* Make room for usr_params at top of stack */ usr_stack = utc-\u0026gt;stack_addr + utc-\u0026gt;mobj_stack-\u0026gt;size; usr_stack -= ROUNDUP(sizeof(struct utee_params), STACK_ALIGNMENT); usr_params = (struct utee_params *)usr_stack; init_utee_param(usr_params, param, param_va); /* 将用户空间和内核空间都准备好后，开始层级切换 */ res = thread_enter_user_mode(func, tee_svc_kaddr_to_uref(session), (vaddr_t)usr_params, cmd, usr_stack, utc-\u0026gt;entry_func, utc-\u0026gt;is_32bit, \u0026amp;utc-\u0026gt;ctx.panicked, \u0026amp;utc-\u0026gt;ctx.panic_code); ... } uint32_t thread_enter_user_mode(unsigned long a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long user_sp, unsigned long entry_func, bool is_32bit, uint32_t *exit_status0, uint32_t *exit_status1) { uint32_t spsr; tee_ta_update_session_utime_resume(); if (!get_spsr(is_32bit, entry_func, \u0026amp;spsr)) { *exit_status0 = 1; /* panic */ *exit_status1 = 0xbadbadba; return 0; } /* a0: 指示进入TA的操作，如open_Session就是UTEE_ENTRY_FUNC_OPEN_SESSION * a1: session结构体地址 * a2: 用户态传递过来的param * a3: invoke_cmd使用的cmd， open_session时为0 * sp: kernel给TA分配的栈空间 * entry_func: sel0 TA入口 * spsr:之前保存下来的sel0的CPU状态寄存器的值 */ return __thread_enter_user_mode(a0, a1, a2, a3, user_sp, entry_func, spsr, exit_status0, exit_status1); }   __thread_enter_user_mode进入一段汇编，层级切换基本思路相同，保存当前CPU状态寄存器，加载sel0的寄存器上下文，同时指定eret的地址，触发eret\n/* core/arch/arm/kernel/thread_a64.S */ FUNC __thread_enter_user_mode , : ldr\tx8, [sp] /* * Create the and fill in the struct thread_user_mode_rec */ sub\tsp, sp, #THREAD_USER_MODE_REC_SIZE store_xregs sp, THREAD_USER_MODE_REC_EXIT_STATUS0_PTR, 7, 8 store_xregs sp, THREAD_USER_MODE_REC_X19, 19, 30 /* * Switch to SP_EL1 * Disable exceptions * Save kern sp in x19 */ msr\tdaifset, #DAIFBIT_ALL mov\tx19, sp msr\tspsel, #1 /* * Save the kernel stack pointer in the thread context */ /* get pointer to current thread context */ get_thread_ctx sp, 21, 20, 22 /* * Save kernel stack pointer to ensure that el0_svc() uses * correct stack pointer */ str\tx19, [x21, #THREAD_CTX_KERN_SP] /* * Initialize SPSR, ELR_EL1, and SP_EL0 to enter user mode */ msr\tspsr_el1, x6 /* Set user sp */ mov\tx13, x4\t/* Used when running TA in Aarch32 */ msr\tsp_el0, x4\t/* Used when running TA in Aarch64 */ /* Set user function */ /* ta entry_func */ msr\telr_el1, x5 /* Set frame pointer (user stack can\u0026#39;t be unwound past this point) */ mov x29, #0 /* Jump into user mode */ store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1 /* 切换页表，TEE为每个TA提供ttbr0中的一段作为内存映射空间(L1); eret层级切换 */ b eret_to_el0 /* 进入TA， 即上文所说ta entry_func： __utee_entry */ END_FUNC __thread_enter_user_mode TA入口 这一段就非常简单了，直接看代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  /* lib/libutee/arch/arm/user_ta_entry.c */ void __noreturn __utee_entry(unsigned long func, unsigned long session_id, struct utee_params *up, unsigned long cmd_id) { TEE_Result res; switch (func) { /* 即寄存器r0的值， UTEE_ENTRY_FUNC_OPEN_SESSION*/ case UTEE_ENTRY_FUNC_OPEN_SESSION: res = entry_open_session(session_id, up); break; case UTEE_ENTRY_FUNC_CLOSE_SESSION: res = entry_close_session(session_id); break; case UTEE_ENTRY_FUNC_INVOKE_COMMAND: res = entry_invoke_command(session_id, up, cmd_id); break; default: res = 0xffffffff; TEE_Panic(0); break; } ta_header_save_params(0, NULL); utee_return(res); } static TEE_Result entry_open_session(unsigned long session_id, struct utee_params *up) { TEE_Result res; struct ta_session *session; uint32_t param_types; TEE_Param params[TEE_NUM_PARAMS]; /* 为TA指定上session， 注意一个TA可能被多个CA调用，有多个session */ res = ta_header_add_session(session_id); if (res != TEE_SUCCESS) return res; session = ta_header_get_session(session_id); if (!session) return TEE_ERROR_BAD_STATE; /* 经过漫长过程终于传递到TA的， CA写下的param */ __utee_to_param(params, \u0026amp;param_types, up); ta_header_save_params(param_types, params); /* 最上层所说的GP接口， 在TA的SDK中， 由用户实现此接口 */ res = TA_OpenSessionEntryPoint(param_types, params, \u0026amp;session-\u0026gt;session_ctx); __utee_from_param(up, param_types, params); if (res != TEE_SUCCESS) ta_header_remove_session(session_id); return res; }   完成操作后，将一步步返回到CA，基本原路返回所以构成类似不细说了。 终于一段漫长的open_session的过程结束了。\nTA中GP标准实现接口 参考官方文档：https://optee.readthedocs.io/en/latest/architecture/globalplatform_api.html\nTEE-\u0026gt;tee-supplicant-\u0026gt;TEE(RPC请求) 首先我们要知道tee-supplicant是啥：\n tee_supplicant的主要作用是使OP-TEE能够通过tee_supplicant来访问REE端文件系统中的资源，例如加载存放在文件系统中的TA镜像到TEE中，对REE端数据库的操作，对EMMC中RPMB分区的操作，提供socket通信等。 其源代码optee_client/tee-supplicant目录中。编译之后会生成一个名字为tee_supplicant的可执行文件，该可执行文件在REE启动的时候会作为一个后台程序被自动启动，而且常驻于系统中。\n原文链接：https://blog.csdn.net/shuaifengyun/java/article/details/72912238\n 其实就是一个常驻在非安全侧，用于响应TEE一些需要在非安全侧完成的请求的一个用户态服务守护进程。既然是在运行在用户态，想必中间又要经过ATF-\u0026gt;tee_driver-\u0026gt;tee_supplicant的流程。\nTEE的官方文档有一个TEE发送请求加载TA的流程图（OPTEE中通常把这种请求叫做RPC），我们首先留下一个完整的印象：\n我们还是从TA加载部分开始说起，第一步探查TEE发送rpc命令到非安全侧tee_driver的操作：\nTEE-\u0026gt;tee_driver 一切要从ta_store-\u0026gt;open(uuid, \u0026amp;handle)上挂载的ree_fs_ta_open函数说起：他将调用rpc_load, 这是TEE发送rpc请求到非安全侧的起点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  /* core/arch/arm/kernel/ree_fs_ta.c */ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid, struct user_ta_store_handle **h) { ... /* Request TA from tee-supplicant */ res = rpc_load(uuid, \u0026amp;ta, \u0026amp;ta_size, \u0026amp;mobj); if (res != TEE_SUCCESS) goto error; ... } static TEE_Result rpc_load(const TEE_UUID *uuid, struct shdr **ta, size_t *ta_size, struct mobj **mobj) { TEE_Result res; struct thread_param params[2]; if (!uuid || !ta || !mobj || !ta_size) return TEE_ERROR_BAD_PARAMETERS; memset(params, 0, sizeof(params)); params[0].attr = THREAD_PARAM_ATTR_VALUE_IN; /* 将请求的UUID写入参数中 */ tee_uuid_to_octets((void *)\u0026amp;params[0].u.value, uuid); params[1].attr = THREAD_PARAM_ATTR_MEMREF_OUT; /* 发送第一个rpc，有下面可以看到请求到的是TA文件的size */ res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params); if (res != TEE_SUCCESS) return res; /* 发送第二个rpc，根据读取到的TA size申请共享内存 */ *mobj = thread_rpc_alloc_payload(params[1].u.memref.size); if (!*mobj) return TEE_ERROR_OUT_OF_MEMORY; if ((*mobj)-\u0026gt;size \u0026lt; params[1].u.memref.size) { res = TEE_ERROR_SHORT_BUFFER; goto exit; } *ta = mobj_get_va(*mobj, 0); /* We don\u0026#39;t expect NULL as thread_rpc_alloc_payload() was successful */ assert(*ta); *ta_size = params[1].u.memref.size; params[0].attr = THREAD_PARAM_ATTR_VALUE_IN; tee_uuid_to_octets((void *)\u0026amp;params[0].u.value, uuid); params[1].attr = THREAD_PARAM_ATTR_MEMREF_OUT; params[1].u.memref.offs = 0; params[1].u.memref.mobj = *mobj; /* 发送第三个rpc，将TA首先加载如共享内存当中 */ res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params); exit: if (res != TEE_SUCCESS) thread_rpc_free_payload(*mobj); return res; }   可以看到thread_rpc_cmd是发送rpc请求的接口，直接分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* core/arch/arm/kernel/thread.c */ uint32_t thread_rpc_cmd(uint32_t cmd, size_t num_params, struct thread_param *params) { uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD }; void *arg = NULL; uint64_t carg = 0; uint32_t ret = 0; /* 套路和driver进入TEE驱动基本一致，还是使用optee_msg_arg结构体， * 准备好cmd填在msg-\u0026gt;cmd， params复制到msg-\u0026gt;params; * 然后获取结构体的地址的mobj描述块的物理地址，后续将填入r1, r2, r0填入OPTEE_SMC_RETURN_RPC_CMD */ /* The source CRYPTO_RNG_SRC_JITTER_RPC is safe to use here */ plat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_RPC, \u0026amp;thread_rpc_pnum); /* 事实上，当第一次调用带有params的thread_rpc_cmd需要完成两次安全与非安全的切换 * 首先需要获取一块共享内存描述块的物理地址，用于params的通讯。 */ ret = get_rpc_arg(cmd, num_params, params, \u0026amp;arg, \u0026amp;carg); if (ret) return ret; reg_pair_from_64(carg, rpc_args + 1, rpc_args + 2); /* 很明显thread_rpc是一段汇编，将触发smc，进入ATF后切换回tee_driver */ thread_rpc(rpc_args); return get_rpc_arg_res(arg, num_params, params); }   /* core/arch/arm/kernel/thread_a64.S */ /* 操作也是类似， 保存好寄存器上下文，触发smc, 进入ATF， ATF将引导进入tee_driver入口 */ /* void thread_rpc(uint32_t rv[THREAD_RPC_NUM_ARGS]) */ FUNC thread_rpc , : /* Read daif and create an SPSR */ mrs\tx1, daif orr\tx1, x1, #(SPSR_64_MODE_EL1 \u0026lt;\u0026lt; SPSR_64_MODE_EL_SHIFT) /* Mask all maskable exceptions before switching to temporary stack */ msr\tdaifset, #DAIFBIT_ALL push\tx0, xzr push\tx1, x30 bl\tthread_get_ctx_regs ldr\tx30, [sp, #8] /* 恢复rpc返回的地址 */ store_xregs x0, THREAD_CTX_REGS_X19, 19, 30 /* 返回地址在thread.reg[30] */ mov\tx19, x0 bl\tthread_get_tmp_sp pop\tx1, xzr\t/* Match \u0026#34;push x1, x30\u0026#34; above */ mov\tx2, sp str\tx2, [x19, #THREAD_CTX_REGS_SP] ldr\tx20, [sp]\t/* Get pointer to rv[] */ mov\tsp, x0\t/* Switch to tmp stack */ /* * We need to read rv[] early, because thread_state_suspend * can invoke virt_unset_guest() which will unmap pages, * where rv[] resides */ load_wregs x20, 0, 21, 23\t/* Load rv[] into w20-w22 */ adr\tx2, .thread_rpc_return /* 注意，此处有一处重要的点，这里指定上的rpc返回tee后thread的入口 */ mov\tw0, #THREAD_FLAGS_COPY_ARGS_ON_RETURN bl\tthread_state_suspend mov\tx4, x0\t/* Supply thread index */ ldr\tw0, =TEESMC_OPTEED_RETURN_CALL_DONE mov\tx1, x21 mov\tx2, x22 mov\tx3, x23 smc\t#0 /* CPU进入el3，之后切回非安全侧el1，进入tee_driver */ b\t.\t/* SMC should not return */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* core/arch/arm/kernel/thread.c */ int thread_state_suspend(uint32_t flags, uint32_t cpsr, vaddr_t pc) { struct thread_core_local *l = thread_get_core_local(); int ct = l-\u0026gt;curr_thread; ... assert(threads[ct].state == THREAD_STATE_ACTIVE); /* 恢复thread后的pc此处指定：thread_rpc_return*/ threads[ct].flags |= flags; threads[ct].regs.cpsr = cpsr; threads[ct].regs.pc = pc; threads[ct].state = THREAD_STATE_SUSPENDED; ... }   tee-supplicant与tee_driver的协同  当libteec调用驱动来与OP-TEE进行数据的交互的时候，最终会调用optee_do_call_with_arg函数完成完成smc的操作，而该函数中有一个loop循环，每次触发smc操作之后会对从secure world中返回的参数res.a0进行判断，判定当前从secure world返回的数据是要执行RPC操作还是直接返回到CA。如果是来自TEE的RPC请求，则会将请求存放到请求队列req中。然后block住，直到tee_supplicant处理完请求并将req-\u0026gt;c标记为完成之后才会进入下一个loop，重新出发smc操作，将处理结果返回给TEE。\n原文链接：https://blog.csdn.net/shuaifengyun/java/article/details/73061002\n 所以第一步我们找到第一次发送smc_call的地方，看他之后做了啥：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* driver/tee/optee/call.c */ u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg) { ... while (true) { struct arm_smccc_res res; optee_bm_timestamp(); /* smc调用点 */ optee-\u0026gt;invoke_fn(param.a0, param.a1, param.a2, param.a3, param.a4, param.a5, param.a6, param.a7, \u0026amp;res); optee_bm_timestamp(); if (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) { /* * Out of threads in secure world, wait for a thread * become available. */ optee_cq_wait_for_completion(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); } else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) { /* 此处的r0由tee填写，处理rpc进入*/ might_sleep(); param.a0 = res.a0; param.a1 = res.a1; param.a2 = res.a2; param.a3 = res.a3; /* 处理rpc函数 */ optee_handle_rpc(ctx, \u0026amp;param, \u0026amp;call_ctx); } else { ret = res.a0; break; } } }   后续流程就不上源码了，通过几个很简单的几个switch找到对应的处理函数, 并且通过物理r1和r2传递过来的物理地址获取的共享内存块，结构体中可以取到params写入的在非安全侧映射的虚拟地址：\noptee_handle_rpc-\u0026gt;handle_rpc_func_cmd(在内核能解决掉的请求都在这里处理完成了)-\u0026gt;handle_rpc_supp_cmd（需要动用到tee-supplicant的请求到这里）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  /* driver/tee/optee/rpc.c */ static void handle_rpc_supp_cmd(struct tee_context *ctx, struct optee_msg_arg *arg) { struct tee_param *params; arg-\u0026gt;ret_origin = TEEC_ORIGIN_COMMS; params = kmalloc_array(arg-\u0026gt;num_params, sizeof(struct tee_param), GFP_KERNEL); if (!params) { arg-\u0026gt;ret = TEEC_ERROR_OUT_OF_MEMORY; return; } /* 将params从共享内存中拷贝到非安全侧driver的内存中 */ if (optee_from_msg_param(params, arg-\u0026gt;num_params, arg-\u0026gt;params)) { arg-\u0026gt;ret = TEEC_ERROR_BAD_PARAMETERS; goto out; } /* 将cmd送入tee-supplicant的处理队列中 */ arg-\u0026gt;ret = optee_supp_thrd_req(ctx, arg-\u0026gt;cmd, arg-\u0026gt;num_params, params); if (optee_to_msg_param(arg-\u0026gt;params, arg-\u0026gt;num_params, params)) arg-\u0026gt;ret = TEEC_ERROR_BAD_PARAMETERS; out: kfree(params); } /* driver/tee/optee/supp.c */ u32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params, struct tee_param *param) { struct optee *optee = tee_get_drvdata(ctx-\u0026gt;teedev); struct optee_supp *supp = \u0026amp;optee-\u0026gt;supp; struct optee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL); bool interruptable; u32 ret; if (!req) return TEEC_ERROR_OUT_OF_MEMORY; /* 初始化该请求消息的c成员并配置请求数据 */ init_completion(\u0026amp;req-\u0026gt;c); req-\u0026gt;func = func; req-\u0026gt;num_params = num_params; req-\u0026gt;param = param; /* Insert the request in the request list */ /* 将接受到的请求添加到驱动的TEE请求消息队列中 */ mutex_lock(\u0026amp;supp-\u0026gt;mutex); list_add_tail(\u0026amp;req-\u0026gt;link, \u0026amp;supp-\u0026gt;reqs); mutex_unlock(\u0026amp;supp-\u0026gt;mutex); /* Tell an eventual waiter there\u0026#39;s a new request */ /* 将supp-\u0026gt;reqs_c置位，通知tee_supplicant的receive操作，当前驱动中 有一个来自TEE的请求 */ complete(\u0026amp;supp-\u0026gt;reqs_c); /* * Wait for supplicant to process and return result, once we\u0026#39;ve * returned from wait_for_completion(\u0026amp;req-\u0026gt;c) successfully we have * exclusive access again. */ /* block在这里，通过判定req-\u0026gt;c是否被置位来判定当前请求是否被处理完毕， 而req-\u0026gt;c的置位是有tee_supplicant的send调用来完成的，如果被置位，则进入到 while循环中进行返回值的设定并跳出while*/ while (wait_for_completion_interruptible(\u0026amp;req-\u0026gt;c)) { mutex_lock(\u0026amp;supp-\u0026gt;mutex); interruptable = !supp-\u0026gt;ctx; if (interruptable) { /* * There\u0026#39;s no supplicant available and since the * supp-\u0026gt;mutex currently is held none can * become available until the mutex released * again. * * Interrupting an RPC to supplicant is only * allowed as a way of slightly improving the user * experience in case the supplicant hasn\u0026#39;t been * started yet. During normal operation the supplicant * will serve all requests in a timely manner and * interrupting then wouldn\u0026#39;t make sense. */ interruptable = !req-\u0026gt;busy; if (!req-\u0026gt;busy) list_del(\u0026amp;req-\u0026gt;link); } mutex_unlock(\u0026amp;supp-\u0026gt;mutex); if (interruptable) { req-\u0026gt;ret = TEEC_ERROR_COMMUNICATION; break; } } ret = req-\u0026gt;ret; kfree(req); return ret; }   来看看tee-supplicant是如何接收到这个request的，先来一个tee-supplicant的总体流程：\ntee-supplicant在系统启动时就将启动起来，常驻在用户态，陷入一个无限循环等待接收request：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  /* optee_client/tee-supplicant/src/tee_supplicant.c */ int main(int argc, char *argv[]) { struct thread_arg arg = { .fd = -1 }; int e; /* 初始化互斥体 */ e = pthread_mutex_init(\u0026amp;arg.mutex, NULL); if (e) { EMSG(\u0026#34;pthread_mutex_init: %s\u0026#34;, strerror(e)); EMSG(\u0026#34;terminating...\u0026#34;); exit(EXIT_FAILURE); } /* 判定是否带有启动参数，如果带有启动参数，则打开对应的驱动文件 如果没有带参数，则打开默认的驱动文件 */ if (argc \u0026gt; 2) return usage(); if (argc == 2) { arg.fd = open_dev(argv[1]); if (arg.fd \u0026lt; 0) { EMSG(\u0026#34;failed to open \\\u0026#34;%s\\\u0026#34;\u0026#34;, argv[1]); exit(EXIT_FAILURE); } } else { /*打开/dev/teepriv0设备，该设备为tee驱动设备文件，返回操作句柄*/ arg.fd = get_dev_fd(); if (arg.fd \u0026lt; 0) { EMSG(\u0026#34;failed to find an OP-TEE supplicant device\u0026#34;); exit(EXIT_FAILURE); } } if (tee_supp_fs_init() != 0) { EMSG(\u0026#34;error tee_supp_fs_init\u0026#34;); exit(EXIT_FAILURE); } if (sql_fs_init() != 0) { EMSG(\u0026#34;sql_fs_init() failed \u0026#34;); exit(EXIT_FAILURE); } /* 调用process_one_request函数接收来自TEE的请求，并加以处理 */ while (!arg.abort) { if (!process_one_request(\u0026amp;arg)) arg.abort = true; } close(arg.fd); return EXIT_FAILURE; }   之后的处理，大佬的博客总结的已经很完整了，直接自取吧：\nhttps://blog.csdn.net/shuaifengyun/article/details/72912238\n我们主要看write_response之后，tee_driver是怎么做的:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  /* optee_client/tee-supplicant/src/tee_supplicant.c */ static bool write_response(int fd, union tee_rpc_invoke *request) { struct tee_ioctl_buf_data data; /* 将需要返回给TA的数据存放在buffer中 */ data.buf_ptr = (uintptr_t)\u0026amp;request-\u0026gt;send; data.buf_len = sizeof(struct tee_iocl_supp_send_arg) + sizeof(struct tee_ioctl_param) * request-\u0026gt;send.num_params; /* 调用驱动中ioctl函数的TEE_IOC_SUPPL_SEND功能，进数据发送给TA */ if (ioctl(fd, TEE_IOC_SUPPL_SEND, \u0026amp;data)) { EMSG(\u0026#34;TEE_IOC_SUPPL_SEND: %s\u0026#34;, strerror(errno)); return false; } return true; /* driver/tee/tee_core.c */ static long tee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct tee_context *ctx = filp-\u0026gt;private_data; void __user *uarg = (void __user *)arg; switch (cmd) { ... case TEE_IOC_SUPPL_SEND: return tee_ioctl_supp_send(ctx, uarg); ... } } static int tee_ioctl_supp_send(struct tee_context *ctx, struct tee_ioctl_buf_data __user *ubuf) { long rc; struct tee_ioctl_buf_data buf; struct tee_iocl_supp_send_arg __user *uarg; struct tee_param *params; u32 num_params; u32 ret; /* Not valid for this driver */ ... rc = ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;supp_send(ctx, ret, num_params, params); out: kfree(params); return rc; } /* driver/tee/optee/core.c */ static const struct tee_driver_ops optee_supp_ops = { .get_version = optee_get_version, .open = optee_open, .release = optee_release, .supp_recv = optee_supp_recv, .supp_send = optee_supp_send, /* 挂载的函数 */ .shm_register = optee_shm_register_supp, .shm_unregister = optee_shm_unregister_supp, }; /* driver/tee/optee/supp.c */ int optee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params, struct tee_param *param) { struct tee_device *teedev = ctx-\u0026gt;teedev; struct optee *optee = tee_get_drvdata(teedev); struct optee_supp *supp = \u0026amp;optee-\u0026gt;supp; struct optee_supp_req *req; size_t n; size_t num_meta; mutex_lock(\u0026amp;supp-\u0026gt;mutex); /* 驱动中请求队列的pop操作 */ req = supp_pop_req(supp, num_params, param, \u0026amp;num_meta); mutex_unlock(\u0026amp;supp-\u0026gt;mutex); if (IS_ERR(req)) { /* Something is wrong, let supplicant restart. */ return PTR_ERR(req); } /* Update out and in/out parameters */ /* 使用传入的参数，更新请求的参数区域，将需要返回给TEE侧的数据填入到对应的位置 */ for (n = 0; n \u0026lt; req-\u0026gt;num_params; n++) { struct tee_param *p = req-\u0026gt;param + n; switch (p-\u0026gt;attr \u0026amp; TEE_IOCTL_PARAM_ATTR_TYPE_MASK) { case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT: p-\u0026gt;u.value.a = param[n + num_meta].u.value.a; p-\u0026gt;u.value.b = param[n + num_meta].u.value.b; p-\u0026gt;u.value.c = param[n + num_meta].u.value.c; break; case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT: p-\u0026gt;u.memref.size = param[n + num_meta].u.memref.size; break; default: break; } } req-\u0026gt;ret = ret; /* Let the requesting thread continue */ /* 通知optee_supp_thrd_req函数，一个来自TEE侧的请求已经被处理完毕， 可以继续往下执行 */ complete(\u0026amp;req-\u0026gt;c); return 0; }   optee_supp_thrd_reqblock将结束，继续往下执行，返回TEE\ntee-supplicant 我们还是以TA_load这个命令为例：\nprocess_one_request中的read_request从队列中读取到请求和TEE过来的param后，获取请求cmd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  /* optee_client/tee-supplicant/src/tee_supplicant.c */ static bool process_one_request(struct thread_arg *arg) { size_t num_params = 0; size_t num_meta = 0; struct tee_ioctl_param *params = NULL; uint32_t func = 0; uint32_t ret = 0; union tee_rpc_invoke request; memset(\u0026amp;request, 0, sizeof(request)); DMSG(\u0026#34;looping\u0026#34;); request.recv.num_params = RPC_NUM_PARAMS; /* Let it be known that we can deal with meta parameters */ params = (struct tee_ioctl_param *)(\u0026amp;request.send + 1); params-\u0026gt;attr = TEE_IOCTL_PARAM_ATTR_META; num_waiters_inc(arg); /* 阻塞点，陷入内核中等待事件 */ if (!read_request(arg-\u0026gt;fd, \u0026amp;request)) return false; if (!find_params(\u0026amp;request, \u0026amp;func, \u0026amp;num_params, \u0026amp;params, \u0026amp;num_meta)) return false; if (num_meta \u0026amp;\u0026amp; !num_waiters_dec(arg) \u0026amp;\u0026amp; !spawn_thread(arg)) return false; switch (func) { case OPTEE_MSG_RPC_CMD_LOAD_TA: /* load_ta使我们的目标函数 */ ret = load_ta(num_params, params); break; ... } static uint32_t load_ta(size_t num_params, struct tee_ioctl_param *params) { int ta_found = 0; size_t size = 0; TEEC_UUID uuid; struct tee_ioctl_param_value *val_cmd; TEEC_SharedMemory shm_ta; memset(\u0026amp;shm_ta, 0, sizeof(shm_ta)); /* 解析出需要加载的TA镜像的UUID以及配置将读取到的TA镜像的内容存放位置 */ if (num_params != 2 || get_value(num_params, params, 0, \u0026amp;val_cmd) || get_param(num_params, params, 1, \u0026amp;shm_ta)) return TEEC_ERROR_BAD_PARAMETERS; /* 将UUID的值转换成TEEC_UUID格式 */ uuid_from_octets(\u0026amp;uuid, (void *)val_cmd); /* 从ta_dir变量指定的目录中查找与UUID相符的TA镜像，并将其内容读取到共享内存中 */ size = shm_ta.size; /* 此函数在一次加载TA流程中将经过两次调用， * 第一次在shm_ta.buffer为空时，将只获取ta文件的大小，回给TEE侧 * 第二次才会去将TA加载进共享内存中 */ ta_found = TEECI_LoadSecureModule(ta_dir, \u0026amp;uuid, shm_ta.buffer, \u0026amp;size); if (ta_found != TA_BINARY_FOUND) { EMSG(\u0026#34; TA not found\u0026#34;); return TEEC_ERROR_ITEM_NOT_FOUND; } /* 设定读取到的TA镜像的大小到返回参数的size成员中 */ params[1].u.memref.size = size; return TEEC_SUCCESS; }   tee_driver-\u0026gt;TEE 调用点没有变化，还是optee-\u0026gt;invoke, 进入ATF，确定入口，进入thread_resume恢复线程，以前的流程区别不大，只是恢复线程之后的pc指针是上文提到的thread_rpc_return\nvoid thread_handle_std_smc(struct thread_smc_args *args) { thread_check_canaries(); #ifdef CFG_VIRTUALIZATION if (!virt_set_guest(args-\u0026gt;a7)) { args-\u0026gt;a0 = OPTEE_SMC_RETURN_ENOTAVAIL; return; } #endif if (args-\u0026gt;a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC) /* 走这个分支 */ thread_resume_from_rpc(args); else thread_alloc_and_run(args); #ifdef CFG_VIRTUALIZATION virt_unset_guest(); #endif ... } static void thread_resume_from_rpc(struct thread_smc_args *args) { size_t n = args-\u0026gt;a3; /* thread id */ struct thread_core_local *l = thread_get_core_local(); uint32_t rv = 0; assert(l-\u0026gt;curr_thread == -1); lock_global(); /* 挂起状态的线程恢复active */ if (n \u0026lt; CFG_NUM_THREADS \u0026amp;\u0026amp; threads[n].state == THREAD_STATE_SUSPENDED \u0026amp;\u0026amp; args-\u0026gt;a7 == threads[n].hyp_clnt_id) threads[n].state = THREAD_STATE_ACTIVE; else rv = OPTEE_SMC_RETURN_ERESUME; unlock_global(); if (rv) { args-\u0026gt;a0 = rv; return; } l-\u0026gt;curr_thread = n; if (is_user_mode(\u0026amp;threads[n].regs)) tee_ta_update_session_utime_resume(); if (threads[n].have_user_map) core_mmu_set_user_map(\u0026amp;threads[n].user_map); /* * Return from RPC to request service of a foreign interrupt must not * get parameters from non-secure world. */ if (threads[n].flags \u0026amp; THREAD_FLAGS_COPY_ARGS_ON_RETURN) { copy_a0_to_a5(\u0026amp;threads[n].regs, args); threads[n].flags \u0026amp;= ~THREAD_FLAGS_COPY_ARGS_ON_RETURN; } thread_lazy_save_ns_vfp(); /* 线程恢复，返回thread_rpc_return */ thread_resume(\u0026amp;threads[n].regs); } thread_resume先eret回到加载回的el1_elr中，对应thread.regs.pc, 即thread_rpc_return，同时此时ret指令对应的跳转地址寄存器为r30, 也从thread.regs.x[30]中回复(具体可以参看上文thread_resume，有注释)\n.thread_rpc_return: /* * At this point has the stack pointer been restored to the value * stored in THREAD_CTX above. * * Jumps here from thread_resume above when RPC has returned. The * IRQ and FIQ bits are restored to what they where when this * function was originally entered. */ pop\tx16, xzr\t/* Get pointer to rv[] */ store_wregs x16, 0, 0, 5\t/* Store w0-w5 into rv[] */ /* 此处调用ret， 返回x30地址， 即thread_rpc函数的下一句地址，整个rpc流程走完 */ ret END_FUNC thread_rpc 至此rpc流程历经一大堆状态切换终于完成，重新回到业务流程thread_rpc_cmd函数中。\n其他补充 以上流程看起来已经相当复杂，然而这才只是冰山一角, 还有很多有关内存管理，安全存储相关的资料，在此处总结一下\nQEMU环境搭建 官方v7: https://optee.readthedocs.io/en/latest/building/devices/qemu.html\n博客关于v8：https://blog.csdn.net/shuaifengyun/article/details/99855105\noptee的密码库 主要使用的是libtomcrypt与libmbed，都运行在TEE_kernel中\nlibtomcrypt\nlibmbedtls\n安全存储相关 https://blog.csdn.net/shuaifengyun/article/list/1 36-42\noptee内部system call https://blog.csdn.net/shuaifengyun/article/details/73326870\n内存管理 暂无比较完整的资料，后续自己补充。\n最后 本文图片主要来自GP和optee官方文档，以及博客：https://icyshuai.blog.csdn.net/\n水平很菜，欢迎指正\n","description":"Trustzone入门与OPTEE的通讯原理分析","id":5,"section":"posts","tags":["OPTEE","Trustzone"],"title":"OPTEE","uri":"https://summersummer3.github.io/posts/optee/"},{"content":"X.509系列（一）：X.509 v3格式下的证书 目前手头上接到了一个新的任务，刚好又是和X.509证书打交道的工作，想到刚入职的时候第一份正正经经的开发任务就是写证书签发工具，感觉这部分确实应该踏踏实实做一下总结了。很难说以笔者现在的水平能不能证书这么一个基础工具讲清楚，尽力而为吧。目前规划为三部分内容，本文第一篇，剩下两部分分别为：\n  ASN.1详解\n  密码库源码分析(基于mbedtls库)\n  证书的目的 我们公钥证书可以说是PKI(Public Key Infrastructure)中非常核心的组件之一，而PKI可以说是当代互联网文明安全的基石了。如果这方面的协议出现了漏洞，可以说会对整个世界互联网都造成非常严重的冲击。笔者知识有限，所以本文对CA(Certificate Authority)将简单抽象为单层级的一个证书颁发者。\n证书(Certificate) 里面主要包含三个部分：证书信息(TBS Certificate)(TBS = To Be Signed)，证书签名算法(signature Algorithm)和证书签名 (signatureValue). 证书信息里包含了证书的ID，证书拥有者的信息，签发者信息与最关键的，证书拥有者公钥信息。而证书的核心功能也是基于该公钥信息展开。\n想象两个场景：\n Alice和Bob进行通信，想要使用一条得到加密的数据传输通道，防止第三方窃听 Alice给Bob发了个消息，但是他想要向Bob证明这条消息是自己发出的，且没有被别人篡改过  场景1：秘钥协商 第一个场景下，可以把问题简单的规约为Alice和Bob需要拥有同样的对称秘钥，数据传输的通道上只传输由该秘钥加密过的数据。但是对称的秘钥如何传输呢？非对称密码体系解决了这个问题。在完成普通的握手之后：\n  Alice和Bob分别将自己的证书发给对方\n  Alice验证Bob的证书，验证成功后提取Bob公钥$ PUBKEY_B $, 之后取随机数 $ r_A $, 计算 $ s_A := PUBKEY_B(r_A) $发送给Alice. $ PUBKEY_X(n) $指使用$ X $的公钥对$ n $完成加密/验签操作. 对应ECC可以视为$ n(PUBKEY_X) $, RSA可以视为$ n^{PUBKEY_X} \\mod N$\n  Bob验证Alice的证书，验证成功后提取Alice公钥$ PUBKEY_A $, 之后取随机数 $ r_B $, 计算 $ s_B := PUBKEY_A(r_B) $ 发送给Alice\n  Alice和Bob分别用自己的私钥从$ s_B/s_A $中解出对应的$ r_B/r_A $, $ r_B := PRIKEY_A(s_B) $, $ r_A := PRIKEY_B(s_A) $，由于私钥都是仅Alice和Bob各自拥有的，网络上其他人无法解出，中间人的窃听将失效（但是中间人攻击依然是可能的，许多https的抓包软件就是基于中间人的攻击。想想为啥）\n  Alice和Bob拼接随机数串 $ r = r_A | r_B $，使用协定好的秘钥派生算法，将$ r $ 作为派生秘钥的种子派生出相同的秘钥，后期将使用该派生的秘钥作为加密通信的秘钥\n  其实上面的协议就是一个比较简化版的SSL/TLS的握手阶段，当然秘钥协商(DH: Diffie–Hellman key exchange)的方式还有很多, 但原理相差不多，会比直接加密简单一点。包括当前几乎已经是标配的HTTPS协议，底层的安全基础很大程度也是基于SSL的协议。\n场景2：数字签名 第二个场景就比较简单了：\n Alice会计算自己信息$M$的摘要值(Digest)，选择合适的padding方式，使用自己的私钥对信息的摘要值计算签名值$ Sig := PRIKEY_A(Pad(DIGEST(M))) $. 传输阶段将自己的证书，签名值与消息(Cert+Sig+M)一起打包发给Bob Bob拿到这个包后首先需要验证Alice的证书，验证成功后提取Alice的公钥；之后计算M的摘要值$D$，之后使用公钥计算$ D\u0026rsquo; := Depad(PUBKEY_A(Sig)) $, 最后判断 $ D\u0026rsquo; ?= D$，完成验签操作  简单来看，消息的摘要值保证了消息的完整性Integrity，而签名的验证保证了消息是来自Alice的不可抵赖性Non-repudiation\n好了，看完了上面的问题，有没有一点疑问：那看起来证书好像只是个公钥的壳子而已，为啥不直接发公钥就完事了？还有验证证书是什么意思？\n有没有想过，上述的Bob和Alice都是所谓的\u0026quot;好人\u0026quot;而已，这网络上哪有这么多好人。本质上，公钥其实只是一个很大的数，传递时也就是个二进制流。假如互联网上只有裸着的公钥传输，我怎么知道这个公钥是谁发给我的，中间有没有被别人给替换了。\n现实中我们证明自己是一个公民的办法通常是去公安局去获取自己的身份证，通过身份证证明我是我，因为身份证上有我的名字、唯一身份证号、照片等等，发证机关将在身份证盖上国家神圣的公章，证明身份证的真实性。那么在网络世界中，我们也需要一张这样的身份证，证明我是该公钥的拥有人，且公钥的信息很有限，所以我们需要打包更多公钥拥有者的信息，同时我们也需要一个组织来进行发证操作，起到公安局的作用，并对证书\u0026quot;盖上公章\u0026quot;。在这种场景下，网络世界的证书自然就呼之欲出了。\n证书的颁发 证书的申请文件 现实中我们去获取身份证时候，首先也要填一个申请表吧。我们在申请证书的时候同样需要一个申请文件来发给网络世界的公安局，CA。当然，这个申请文件也是需要遵循格式标准的RFC 2986 - PKCS #10: Certification Request Syntax Specification，缩写为.csr\n通过OpenSSL可以自己造一个合法格式的csr文件：\n正如申请身份证需要先造个人，首先我们需要自己造一个公钥，即制造一对公私钥对，以RSA-2048为例，生成pem格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  pwner@pwner:~$ openssl genrsa -out rsa_private.pem 2048 Generating RSA private key, 2048 bit long modulus (2 primes) .........................................+++++ .........................................................+++++ e is 65537 (0x010001) pwner@pwner:~$ openssl rsa -in rsa_private.pem -pubout -out rsa_public.pem pwner@pwner:~$ cat rsa_public.pem rsa_private.pem -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6A5bWFoO3bU8apnV6Q4r SmosNvx28JSLz5gdwtrAHTjzqLn7yXu56kp/j8wZEKhe0jgKNCAGIwbY3begyAav ixZY4XUa647L4wtJ9lJzUTVcFdZ2g/WsmQXVY3ssa3NYL7SDnlBxffdrT8s0yRV4 Ojo4CqgJ926qEZERUxnuv5cgf7l3cfbZUoZzgcdw5XF+Mu98y+yvnrqnihfO2DGU HTWCRI93NkCpZRngPWElT1XR8kxSIuquJW54RgFE1RK6v7S8RVHvtwIqpvYV4D/u OgxktmwAblxwF65uPklLgVlNfxKMhFnQoF77vSPdWWaB0x8CQsn+5q4KhGARaT5z fQIDAQAB -----END PUBLIC KEY----- -----BEGIN RSA PRIVATE KEY----- MIIEpgIBAAKCAQEA6A5bWFoO3bU8apnV6Q4rSmosNvx28JSLz5gdwtrAHTjzqLn7 yXu56kp/j8wZEKhe0jgKNCAGIwbY3begyAavixZY4XUa647L4wtJ9lJzUTVcFdZ2 g/WsmQXVY3ssa3NYL7SDnlBxffdrT8s0yRV4Ojo4CqgJ926qEZERUxnuv5cgf7l3 cfbZUoZzgcdw5XF+Mu98y+yvnrqnihfO2DGUHTWCRI93NkCpZRngPWElT1XR8kxS IuquJW54RgFE1RK6v7S8RVHvtwIqpvYV4D/uOgxktmwAblxwF65uPklLgVlNfxKM hFnQoF77vSPdWWaB0x8CQsn+5q4KhGARaT5zfQIDAQABAoIBAQCDaxYKLD59CtWj XWnKaa7UntpZbZMCXm3rbC92maHxKr67EFDq4zn/2J7zVdfgGipRDVGiAXzYO1l3 /zV78mVZ9JbzX/mV67HF7C+/4yPRmtGCwIkv5GMR6j7V7vzSAWmw4p8jelU7zHIm p2NGefUzrKLuTgoO6cpA1pIkKOyP7TclGp9vTGh1MoE2rZjLggo+ESQuLX/GKDAH pV3NamiAgJtrfqTKoI/AnDcGhhy46np/Cwb4ENkFFJ6oHOYgyXexlBCQmjXfaQyp T45uGjuKi45r9c5mvP0Z7uejCKWPs6LjXye3SN2XtWFRJdADBMH+YMqHax8N3IPm 4cUz3l+hAoGBAP+vkZ2+qSECMjudymz9yEiSrrIAnG2G5gCTNsnannXMNzBOOgIb mpvGY8okLeA7pHsOYdyvnCvbRuA6mhtL+tFn84PjQem6Z18KyqwCvHWzsnvrcjbx yiBnSwsyfbfXQqdGhfs62Vko+6OxXSDB10uyHGiga7C26N8HY1F791UlAoGBAOhX WtNx5xubEgGumKPNNdSD/5Toq+Cz+eIuLiTfR4zZYGcjBawcESzkV3EM6HN/LL8N bZ1DFKxIMsGAECmkImKtEkWEpeqJkatjsQbDvzSX0mUPrE4fFJQF3JzzauXKUayC 51S0GS9EN0FLYk0mjXyrJcHaHcFqgVW0eQ/7RNF5AoGBANuLFFy/hpfKO/nGrjbR 3rS6BnjfX3IIX9vkjCncpy18sXKv6M1AiIvzWGIMmLuuWrgzDEKjI1ThDsWgbAy+ O9qtCIKZk1Iu9W29ZXM3Uj06lCola8fT63vRVbWCoEJH+nqJaqfiyxfswc23kMB8 0PG1OQF5pZ5yIBjJTjV8XU5lAoGBAL+M3W2712x0AXlvh5psIfguRzVuSd38o4Rs zFBL4MJnqMn/HrsRfLuFGe4zVSV7cNmmaXuhBVcwQuAzA6BBGLQ/ufOkc+GUP4uM qjNIiMgEb0owjL7vctjCqGqhaL1Aeut+FNhJjwXf+KoVS1sN8NIajAtxFt0SQMT3 AGRDpS4JAoGBAK6hrYUVDDLEDfvfCH8ItOGYozPdDDvJbiZQMdK9tXSnpfoOGOXK 9ofPPSrBoAIt7O0RR5fBR3di8fZbVGJRd2NUsnbFhlj4KBVKusYRjeTl5PcNI6G0 P8wd5+pqIdwAVN77S5MeusApw8A2+L67odt6xzHGugR3pcBzGONUsD3C -----END RSA PRIVATE KEY-----   生成csr文件，输入自己的公钥与私钥，通常还会让你输入自己的个人信息。使用PKCS#10的标准将信息与公钥打包后，由自己私钥进行自签名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  pwner@pwner:~/X509_learning$ openssl req -new -in rsa_public.pem -key rsa_private.pem -out rsa_public.csr.pem You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Country Name (2 letter code) [AU]:CN State or Province Name (full name) [Some-State]:GD Locality Name (eg, city) []:SZ Organization Name (eg, company) [Internet Widgits Pty Ltd]:xxxx Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []:xxxx Email Address []:xxxx Please enter the following \u0026#39;extra\u0026#39; attributes to be sent with your certificate request A challenge password []: An optional company name []: pwner@pwner:~/X509_learning$ cat rsa_public.csr.pem -----BEGIN CERTIFICATE REQUEST----- MIICtTCCAZ0CAQAwcDELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkdEMQswCQYDVQQH DAJTWjEPMA0GA1UECgwGSFVBV0VJMREwDwYDVQQDDAhTSFVBSUhVQTEjMCEGCSqG SIb3DQEJARYUc2h1YWlodWEyQGh1YXdlaS5jb20wggEiMA0GCSqGSIb3DQEBAQUA A4IBDwAwggEKAoIBAQDoDltYWg7dtTxqmdXpDitKaiw2/HbwlIvPmB3C2sAdOPOo ufvJe7nqSn+PzBkQqF7SOAo0IAYjBtjdt6DIBq+LFljhdRrrjsvjC0n2UnNRNVwV 1naD9ayZBdVjeyxrc1gvtIOeUHF992tPyzTJFXg6OjgKqAn3bqoRkRFTGe6/lyB/ uXdx9tlShnOBx3DlcX4y73zL7K+euqeKF87YMZQdNYJEj3c2QKllGeA9YSVPVdHy TFIi6q4lbnhGAUTVErq/tLxFUe+3Aiqm9hXgP+46DGS2bABuXHAXrm4+SUuBWU1/ EoyEWdCgXvu9I91ZZoHTHwJCyf7mrgqEYBFpPnN9AgMBAAGgADANBgkqhkiG9w0B AQsFAAOCAQEA5FHk/AAEmiR58aHZJ9dAFMtxEAm4x9WYpxcfzFrXt1h35QFLK3D5 3SkZlTeRNfH3r4eNYit8Hm3efqsfQXfgcuO5RTS4lU7DcAdsgExddxd52NojfnxP qMfBQNZTuglVLGZ3o3O/HQ0YvJjkcLyIyFyU1YwVzWkts/QHKmU2mtyrLN4piolv nZlTSX3qeUio218nwEmXzztcZBR51Z3hriUSIP/+rBWJlZEP+0sTaOmG46gQwS7r jxif4CcoCwPDd8+GeiSSbWHZzNYRISVtQcLHVsUAq6iro3YiQygPBLF4bwa4c8kX bcqeI/q36J+2myc/alFWDGjEsE/6zh6c7w== -----END CERTIFICATE REQUEST-----   -in选项输入公钥，-key输入私钥，-out为输出csr文件名。-new表示新建一个csr。运行命令行后然后会让你输入的个人信息。此处拆分主要为了阐述csr的生成流程。\n1  pwner@pwner:~/X509_learning$ openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout rsa_private.pem -out rsa_public.csr.pem   但是上面的打印啥也看不出来，我们需要用解析完的方式来查看该文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  pwner@pwner:~/X509_learning$ openssl req -in rsa_public.csr.pem -noout -text Certificate Request: Data: Version: 1 (0x0) Subject: C = CN, ST = GD, L = SZ, O = xxxx, CN = xxxx, emailAddress = xxxx Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:e8:0e:5b:58:5a:0e:dd:b5:3c:6a:99:d5:e9:0e: 2b:4a:6a:2c:36:fc:76:f0:94:8b:cf:98:1d:c2:da: c0:1d:38:f3:a8:b9:fb:c9:7b:b9:ea:4a:7f:8f:cc: 19:10:a8:5e:d2:38:0a:34:20:06:23:06:d8:dd:b7: a0:c8:06:af:8b:16:58:e1:75:1a:eb:8e:cb:e3:0b: 49:f6:52:73:51:35:5c:15:d6:76:83:f5:ac:99:05: d5:63:7b:2c:6b:73:58:2f:b4:83:9e:50:71:7d:f7: 6b:4f:cb:34:c9:15:78:3a:3a:38:0a:a8:09:f7:6e: aa:11:91:11:53:19:ee:bf:97:20:7f:b9:77:71:f6: d9:52:86:73:81:c7:70:e5:71:7e:32:ef:7c:cb:ec: af:9e:ba:a7:8a:17:ce:d8:31:94:1d:35:82:44:8f: 77:36:40:a9:65:19:e0:3d:61:25:4f:55:d1:f2:4c: 52:22:ea:ae:25:6e:78:46:01:44:d5:12:ba:bf:b4: bc:45:51:ef:b7:02:2a:a6:f6:15:e0:3f:ee:3a:0c: 64:b6:6c:00:6e:5c:70:17:ae:6e:3e:49:4b:81:59: 4d:7f:12:8c:84:59:d0:a0:5e:fb:bd:23:dd:59:66: 81:d3:1f:02:42:c9:fe:e6:ae:0a:84:60:11:69:3e: 73:7d Exponent: 65537 (0x10001) Attributes: a0:00 Signature Algorithm: sha256WithRSAEncryption e4:51:e4:fc:00:04:9a:24:79:f1:a1:d9:27:d7:40:14:cb:71: 10:09:b8:c7:d5:98:a7:17:1f:cc:5a:d7:b7:58:77:e5:01:4b: 2b:70:f9:dd:29:19:95:37:91:35:f1:f7:af:87:8d:62:2b:7c: 1e:6d:de:7e:ab:1f:41:77:e0:72:e3:b9:45:34:b8:95:4e:c3: 70:07:6c:80:4c:5d:77:17:79:d8:da:23:7e:7c:4f:a8:c7:c1: 40:d6:53:ba:09:55:2c:66:77:a3:73:bf:1d:0d:18:bc:98:e4: 70:bc:88:c8:5c:94:d5:8c:15💿69:2d:b3:f4:07:2a:65:36: 9a:dc:ab:2c:de:29:8a:89:6f:9d:99:53:49:7d:ea:79:48:a8: db:5f:27:c0:49:97:cf:3b:5c:64:14:79:d5:9d:e1:ae:25:12: 20:ff:fe:ac:15:89:95:91:0f:fb:4b:13:68:e9:86:e3:a8:10: c1:2e:eb:8f:18:9f:e0:27:28:0b:03:c3:77:cf:86:7a:24:92: 6d:61:d9:cc:d6:11:21:25:6d:41:c2:c7:56:c5:00🆎a8🆎 a3:76:22:43:28:0f:04:b1:78:6f:06:b8:73:c9:17:6d:ca:9e: 23:fa:b7:e8:9f:b6:9b:27:3f:6a:51:56:0c:68:c4:b0:4f:fa: ce:1e:9c:ef   这就有那味儿了，简单解析一下，顺便对应着RFC的标准看一下。先看Data这段，对应的是 CertificationRequestInfo\n1 2 3 4 5 6  CertificationRequestInfo ::= SEQUENCE { version INTEGER { v1(0) } (v1,...), subject Name, subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }}, attributes [0] Attributes{{ CRIAttributes }} }   顺便提一下，RFC的标准都是使用ASN.1格式描述的，而日常使用中的证书等文件同样是基于ASN.1的BER格式，而PEM是对文件进行标识（如-----BEGIN CERTIFICATE REQUEST-----）后，进行base64编码的产物。ASN.1的具体细节将在(二)部分进行分析。\n可以发现生成的csr的data部分是可以和CertificationRequestInfo一一对应起来的：\nversion：csr的版本号，当前通常是version 1，即0\nsubject：以Name的格式保存，一般会保存证书持有者的国籍(C:Country 两个字母表示，如美国US，中国CN), 省级行政区(ST: State or Province)，城市(L:Locality), 公司组织名(O:Organization), 组织部门名(OU: Organization Unit), 通用名(CN: Common Name), email地址等等。其实具体的规范还是比较复杂的，具体标准参考X.501规范。此处不细说了\nsubjectPKInfo: 最关键的部分，包含了公钥的信息，由公钥算法与公钥值组成：\n1 2 3 4  SubjectPublicKeyInfo { ALGORITHM : IOSet} ::= SEQUENCE { algorithm AlgorithmIdentifier {{IOSet}}, subjectPublicKey BIT STRING }   顺便提一句，AlgorithmIdentifier的标识是ANS.1编码中最与众不同的方式，Object ID. 后续将提到。此处算法被标记为了rsaEncrypt\n最后是attributes，他主要提供了一些证书申请者的附加信息。PKCS#9中定义了一些在此可能使用的属性类型，典型的例子是challenge-password属性：它将指定一个密码，实体可以通过该密码请求吊销证书；另一个例子是X.509证书扩展中显示的信息（例如。从PKCS #9获取的extensionRequest属性等）。此处a0:00标识了NULL\n1 2 3 4  Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE { type ATTRIBUTE.\u0026amp;id({IOSet}), values SET SIZE(1..MAX) OF ATTRIBUTE.\u0026amp;Type({IOSet}{@type}) }   再看完整的csr结构：\n1 2 3 4 5  CertificationRequest ::= SEQUENCE { certificationRequestInfo CertificationRequestInfo, signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }}, signature BIT STRING }   certificationRequestInfo对应的就是上面的Data，已完成解释\nsignatureAlgorithm对应签名算法，此处为sha256WithRSAEncryption，指的是使用待签名的公钥对应的私钥，来完成自签名，签名的对象是certificationRequestInfo的sha256摘要值，签名算法为RSA\n最后signature对应的就是签名值了，bit string类型\n最后提一点，在证书申请的模式下，申请者只需要将公钥信息发至证书签发机构即可，保证了私钥的本地性与私密性。\nCA 完成了申请表的填写，就应该交给身份证办理人员了，类比下来csr文件生成之后，我们就要向CA发送证书申请文件，以获取证书。\nCA可以翻译为数字证书认证机构，是PKI体系中的基石。维基百科于是说：\n CA是证书的签发机构，它是PKI的核心。CA是负责签发证书、认证证书、管理已颁发证书的机关。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。\n 由上文可以推断，CA正是承担了公安局对身份证\u0026quot;盖章\u0026quot;这一工作，盖上的便是使用CA私钥完成的对证书的数字签名。但是公安局的信用是有国家背书的，所以CA也必须得到网络上所有人的信任。当然拥有CA资格的机构也是相当有限的。\nCA获取证书申请之后，首先就要检测csr的合法性，申请人信息的合法性，公钥的合法性等等。这些属于审批的范畴，技术范畴的话就是需要校验csr的签名，即certificationRequestInfo是否被篡改。过程为取出certificationRequestInfo中的公钥信息，计算certificationRequestInfo的待验证哈希值。利用提取的公钥与签名计算出签名哈希值，解padding后，判断是否与待验证哈希值一致，确定该csr的完整性与不可抵赖性。\nCA在完成验证后，将下发自己的CA证书以及签发的X.509证书。CA同样是一张X.509格式的证书，往往也是一张自签名的证书，即CA私钥签发CA公钥。事实上，当前网络通讯当中（特别是浏览器）将会内置上很多权威受信任的CA证书，若通信过程中使用的CA证书并不在内置名单中，往往程序会进行提醒：当前站点CA证书不受信任。而且现在CA往往由于需要加快签发速率等原因，会使用多级CA的模式，即CA证书由上级CA签发，最后将校验链上的证书一并发送给申请者，后续校验时将进行证书的逐级校验。\n还记得上面场景中提到的：Alice验证Bob的证书这一步吗？Alice正是通过CA证书中的公钥来校验Bob证书签名的。原因正是基于CA是Alice所信任的证书认证者。当然验证证书还需要对certificateInfo校验，确定Bob的身份，下章就会讲到。\nX.509 终于到了重头戏，我们的主角，X.509格式的证书。再强调一次，证书是功能性的描述，而X.509只是证书一种国际上通用的格式，基于RFC3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile(X.509 v3), 对应了PKCS#12。\n这次我们直接拿上一张Google的证书来看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  Certificate: Data: Version: 3 (0x2) Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT Subject: C = US, ST = California, L = Mountain View, O = Google LLC, CN = www.google.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:bc:1c:aa:96:6f:6f:99:48:79:56:61:4b:7f:ff: dc:39:08:3a:d4:4d:e2:d8:87:80:af:3d:18:5e:71: 2d:ce:09:70:57:39:38:5f:2a:ee:a8:35:f4:3a:86: 86:5a:1d:c7:31:32:1b:8d:ac:d0:46:ad:c3:fc:a5: d3:18:36:68:ab ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Authority Information Access: OCSP - URI:http://ocsp.pki.goog/gts1o1core CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt X509v3 Subject Alternative Name: DNS:www.google.com X509v3 Certificate Policies: Policy: 2.23.140.1.2.2 Policy: 1.3.6.1.4.1.11129.2.5.3 X509v3 CRL Distribution Points: Full Name: URI:http://crl.pki.goog/GTS1O1core.crl CT Precertificate SCTs: Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 5E:A7:73:F9:DF:56:C0:E7:B5:36:48:7D:D0:49:E0:32: 7A:91:9A:0C:84:A1:12:12:84:18:75:96:81:71:45:58 Timestamp : Aug 26 09:14:24.417 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:20:77:F3:D6:8B:51:4F:88:71:16:73:ED:36: 2F:64:F4:77:3E:92:D3:CE:97:1F:1C:53:FA:4E:FB:5B: D7:0A:4C:D6:02:21:00:9F:B9:FE:F1:F3:1C:0D:CF:20: 30:B1:1C:0A:01:65:AD:67:90:1F:B5:33:90:8D:49:4D: 2B:ED:1D:90:28:A1:6B Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 07:B7:5C:1B:E5:7D:68:FF:F1:B0:C6:1D:23:15:C7:BA: E6:57:7C:57:94:B7:6A:EE:BC:61:3A:1A:69:D3:A2:1C Timestamp : Aug 26 09:14:24.367 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:21:00:F4:67:8E:8B:ED:3F:B2:D4:EA:72:EB: 53:F1:52:57:98:D6:63:0E:C0:6B:68:46:CE:F3:AD:25: 52:AD:12:83:27:02:20:05:CA:04:76:D6:4F:2A:E5:D3: 96:85:79:A2:F3:85:29:9E:89:30:00:A7:20:99:2D:F7: C9:56:3C:4E:5D:5C:CF Signature Algorithm: sha256WithRSAEncryption 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: 32:99:29:f8:13:6b:72:af:16:79:63:d3:3f:76:56:57:19:78: 91:86:f8:7a:ee:26:67:98:dc:5e:e4:00:f5:87:a0:01:21:9d: cf:e5:9f:02:f3:2a:fd:0e:fd:78:af:2e:20:29:77:35:e2:c6: 30:ee:ef:be:f2:bb:26:02:52:a2:2d:27:78:ce:a9:8e:39:d0: a2:74:90:11:c5:92:58:3c:7a:88:1d:c7:5a:56:d4:1a:01:00: c3:9d:98:6f:41:02:1f:cb:e2:4d:99:6a:5c:d9:0f:c0:88:08: 15:c5:26:90:a2:a4:15:f6:71:e2:fe:a9:98:dc:40:2a:71:c1: 11:aa:00:73:52:24:74:aa:ae:72:55:2f:0d:31:b7:00:bb:1f: 87:4d:f5:05:ad:ff:7a:93:e0:cf:86:a5:1d:1b:7d:41:fa:10: 99:3b:00:7c:c9:dd:a9:52:5c:06:72:86:96:e7:05:97:77:12: 2f:26:bb:dc:65:c4:48:4d:9c:82:4b:7d:69:27:3f:85:00:2e: b1:5d:8d:dc   同样对照标准定义进行学习字段的意义：\n1 2 3 4  Certificate ::= SEQUENCE { tbsCertificate TBSCertificate, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING }   可以看到Data对应了tbsCertificate, 也是整张证书最关键的部分，该字段包含证书拥有者信息、颁发者信息、公钥信息、有效期信息等，后面单独拿出来详细解析。\n剩下的两个部分与csr完全一致，同样是表明了签名的算法与tbsCertificate的签名。这里要注意，签发者issuer信息表明了证书签发人，一般为受信任的CA。\nTBSCertificate 核心字段，一点点手撕；先看定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  TBSCertificate ::= SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, serialNumber CertificateSerialNumber, signature AlgorithmIdentifier, issuer Name, validity Validity, subject Name, subjectPublicKeyInfo SubjectPublicKeyInfo, issuerUniqueID [1] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version shall be v2 or v3 subjectUniqueID [2] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version shall be v2 or v3 extensions [3] EXPLICIT Extensions OPTIONAL -- If present, version shall be v3 } Version ::= INTEGER { v1(0), v2(1), v3(2) } CertificateSerialNumber ::= INTEGER Validity ::= SEQUENCE { notBefore Time, notAfter Time } Time ::= CHOICE { utcTime UTCTime, generalTime GeneralizedTime } UniqueIdentifier ::= BIT STRING SubjectPublicKeyInfo ::= SEQUENCE { algorithm AlgorithmIdentifier, subjectPublicKey BIT STRING }   这里顺便提一句ASN.1下的定义中SEQUENCE和SET的区别在于：通常SEQUENCE是一个有序集合，即编码时必须按照顺序排列，SET则可以为无序的集合。通常解析SEQUENCE时都将按序解析。\nversion：X.509标准下版本，例子中证书为0x2，即v3版本。注意证书存在extensions时，版本一定是v3版本，故extension通常也称为X.509 v3 extension。\nserialNumber：证书的序列号，它必须是一个唯一的整数。需要注意一点，他是一个大端数字，所以有时候他可能高位填一些0，但不影响其对比。比如例子中的证书，实际编码中高位填上了0：\n/* 解析结果 */ Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f /* 编码 */ Tag:[02] Length:[11] Value:[00 BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F] 序列号的作用主要在CRL中体现唯一标识的作用。可以对照到身份证上的身份证号:)\nsignature: 标记了证书的签名算法，与csr一样，不做赘述。\nissuer：标记证书签发者CA的信息，例子中可以看到为Google Trust Services签发。具体格式类似上面的subject。\nvalidity：标识了证书的生效时间，以起始时间与结束时间表述。可以看到例子中的证书的生效起始时间为格林威治时间的2020/08/26, 有效期至2020/11/18。时间的ASN.1通常以 YYMMDDHHMMSS来标识，结尾以Z或者时区差标识时区。Z是Zulu时间的意思，和格林威治时间同步。\nsubject：证书拥有者信息，同issuer。上面提到校验Bob的信息，也就是对这一段的验证。\nsubjectPublicKeyInfo：证书公钥信息，也和csr中的一致。\nUniqueID：可选字段，这个字段必须要v2及以上版本才有，主要是用来防止issuer与subject重名的情况。例子中的证书是没有的\nExtension extension是最重头戏的字段：\n1 2 3 4 5 6  Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension Extension ::= SEQUENCE { extnID OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING }   通过描述可以看到Extensions是一个可选字段，其内部可以有最多MAX个拓展字段，这里当然无法单独完成阐述，挑一些例子中的标准拓展字段描述。\nAuthority Key Identifier/Subject Key Identifier: 这两个字段主要是在多证书的场景提供一种快速确定所需要公钥的标记。Authority Key Identifier唯一标记了该证书签发私钥对应的公钥，而Subject Key Identifier则是唯一标记了当前证书中的公钥。举个例子，一个设备当中可能有好多个证书，但是每一个app可能只需要对应证书中的公钥，那么就可以将这一串ID内置在app中，证书也不需要完整解析，先去看看对应Key Identifier字段是不是匹配即可。通常计算方式为计算公钥的SHA1值，本例子中的Subject Key Identifier即为这种方式：\n1 2 3 4 5 6 7 8 9  X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 from hashlib import sha1 hash = sha1() hash.update(b\u0026#34;\\x04\\xbc\\x1c\\xaa\\x96\\x6f\\x6f\\x99\\x48\\x79\\x56\\x61\\x4b\\x7f\\xff\\xdc\\x39\\x08\\x3a\\xd4\\x4d\\xe2\\xd8\\x87\\x80\\xaf\\x3d\\x18\\x5e\\x71\\x2d\\xce\\x09\\x70\\x57\\x39\\x38\\x5f\\x2a\\xee\\xa8\\x35\\xf4\\x3a\\x86\\x86\\x5a\\x1d\\xc7\\x31\\x32\\x1b\\x8d\\xac\\xd0\\x46\\xad\\xc3\\xfc\\xa5\\xd3\\x18\\x36\\x68\\xab\u0026#34;) hash.hexdigest() \u0026gt;\u0026gt;\u0026gt;\u0026#39;af32a89d2098f3fd1441fef4c474477cd16c81b1\u0026#39;   Key Usage/Extended Key Usage: 确定证书中公钥的用途。以前一个为主，extended字段作为补充。例子中的证书主要就是用来做TLS通讯中的数字签名功能。Key Usage主要类型有以下几种，详细描述可以参考标准中的描述，这里不展开说了：\n1 2 3 4 5 6 7 8 9 10  KeyUsage ::= BIT STRING { digitalSignature (0), nonRepudiation (1), keyEncipherment (2), dataEncipherment (3), keyAgreement (4), keyCertSign (5), cRLSign (6), encipherOnly (7), decipherOnly (8) }   Certificate Policies：以OID格式体现，主要是表现申请证书时的缘由和预期的用途。例子中的2.23.140.1.2.2和1.3.6.1.4.1.11129.2.5.3是典型的OID格式，每个点隔开一个属性层级，可以通过 http://www.oid-info.com/ 进行Object的查询，如2.23.140.1.2.2表示为organization-validated，即\n Certificates issued in accordance with the CA/Browser Forum\u0026rsquo;s Baseline Requirements - Organization identity asserted\n Authority Information Access：标识了CA Issuer的信息，包括OCSP服务的网址与CA证书的下载地址。该部分在TLS很重要。OCSP服务会在后续CRL中提到。\nCRL Distribution Points：CRL(Certificate Revocation List), 标识了当前CA下吊销列表文件的下载地址，也是TLS握手阶段重要的过程。后续将继续分析。\nCT Precertificate SCTs：证书透明度(Certificate Transparency); 这个是标准中没有提到的一个比较新的拓展。CT主要搭配了CA服务器上公开的Log，将记录CA的行为日志，而每一个与当前证书相关的日志将被计入此字段，并被CA进行签名。校验阶段可以根据Log ID和timestamp查找日志中的对应操作，对证书进行审计以确定当前证书的合法性。该字段的提出主要就是防止CA被入侵者利用后获取大量非法签发证书，而透明性的日志保证了证书的签发是到受到严格监控的。\nCRL 证书的有效期似乎已经能够防止回退之内的攻击了，但是万一在有效期内发生了对应私钥的泄漏事件，该怎么取消掉证书的有效性呢？这时候就需要crl出场了。\n上面已经提到了CRL Distribution Points，直接从对应地址下载个crl：\nCertificate Revocation List (CRL): Version 2 (0x1) Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Last Update: Sep 19 02:13:00 2020 GMT Next Update: Sep 29 02:13:00 2020 GMT CRL extensions: X509v3 CRL Number: 1001 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Revoked Certificates: Serial Number: 049950FB5DD23C3502000000007A32AD Revocation Date: Sep 10 15:53:36 2020 GMT CRL entry extensions: X509v3 CRL Reason Code: Affiliation Changed Serial Number: 05303980A9456025080000000056050B Revocation Date: Sep 10 15:53:42 2020 GMT CRL entry extensions: X509v3 CRL Reason Code: Affiliation Changed ...... Signature Algorithm: sha256WithRSAEncryption 00:37:3c:7e:ba:71:d2:92:52:3a:f6:4d:86:c0:a2:c2:18:78: 34:0e:ea:80:41:08:82:32:54:42:f0:2c:d7:f7:e0:81:93:dc: 0d:e5:0b:71:1f:ae:7e:bf:1c:05:3c:3c:f8:2b:cb:99:20:21: 80:29:a9:81:1d:f4:33:f4:21:95:70:f1:4c:38:30:34:28:32: be:0a:0b:0d:09:5d:81:33:72:fb:40:16:db:26:a1:7d:e9:11: 56:74:11:58:e3:4d:37:93:23:68:6a:85:8c:89:05:7d:55:67: 8c:da:3c:02:cb:46:3b:4e:7d:c6:38:12:02:cc:a8:ff:57:04: 9d:0a:bf:07:30:36:5d:85:b7:4c:9e:a1:52:b8:2c:4a:ec:91: ba:ba:8f:74:60:f4:06:84:8b:d9:a7:08:3d:2a:cf:ee:66:c6: de:1e:ae:68:24:ed:0d:ca:d6:73:0e:40:b2:5c:91:00:dc:32: 72:04:8b:46:65:12:9c:56:9d:aa:76:89:7b:c2:74:a8:b0:a3: de:e6:d6:d1:12:87:16:34:98:9b:2e:bd:38:ea:1c:59:03:40: 0d:ba:0c:0c:f2:9e:31:64:33:1b:28:43:4e:3b:78:41:2e:d9: 82:21:39:97:fe:c0:ab:9f:82:8d:18:02:26:c4:b0:44:c5:74: 25:30:6a:50 还是先对应ASN.1对于crl格式的描述看一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  CertificateList ::= SEQUENCE { tbsCertList TBSCertList, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING } TBSCertList ::= SEQUENCE { version Version OPTIONAL, -- if present, MUST be v2 signature AlgorithmIdentifier, issuer Name, thisUpdate Time, nextUpdate Time OPTIONAL, revokedCertificates SEQUENCE OF SEQUENCE { userCertificate CertificateSerialNumber, revocationDate Time, crlEntryExtensions Extensions OPTIONAL -- if present, MUST be v2 } OPTIONAL, crlExtensions [0] EXPLICIT Extensions OPTIONAL -- if present, MUST be v2 }   可以看到这时候crl的解析出来的格式顺序已经和标准的定义略有区别，但是不影响，只要知道所有的吊销列表信息肯定都是被CA签名了的。\nsignatureAlgorithm和signatureValue 没啥好说的，和之前证书和申请文件没有区别。\nCertList 这一段可分为主要的两个部分：吊销文件信息和吊销证书列表，这也是解析出来crl没有按照顺序排列的原因，为了打印的好看，这一段被拆分成了两部分\n先看吊销文件信息：\nversion、signature和issuer 和之前完全一样，不再赘述。\nthisUpdate：指定了本次crl签发的的时间。主要用来保证crl证书的时效性\nnextUpdate：可选项，指定了下一次crl签发的时间\ncrlExtensions：包含了拓展信息，注意这个字段在实际的证书中是放在revokedCertificates后面的。在用例的google证书的crl中可以看到吊销证书的数量(CRL Number: 1001)和Authority Key Identifier,可以看到这个Authority Key Identifier和X.509证书中的相同字段是一模一样的。注意这个地方CRL Number是不一定等于revokedCertificates中被吊销列表数量的，其实为了加快查找效率，已经过期的被吊销证书是可以从列表中移除以减小列表的大小。\nrevokedCertificates 这是crl的核心部分，包含了被吊销证书的唯一序列号(userCertificate CertificateSerialNumber)，证书的吊销时间(revocationDate)，以及一些扩展，用例中包含了典型用例：吊销原因码(CRL Reason Code)。\n主要看一下唯一序列号这个段，这个段是刚好对应X.509证书中的serialNumber段，这也是为什么这个段需要唯一的原因：他标识了一张独一无二的证书。\n其实这时候查询一个列表是否吊销的流程已经很简单了：\n 握手阶段获取crl 通过CA证书校验crl签名 查询对端证书的序列号是否在revokedCertificates中  但是这是唯一的方法吗？如果碰到像当年heartbleed一样的大型泄漏事件，吊销列表是不是特别大，特别大会造成两个问题：下载慢、查询慢，最终导致握手超时。\n第二点问题是crl有更新不及时的问题：CA机构在吊销一张证书后，不会立刻去更新CRLs文件，客户端定期缓存的CRLs文件也不是及时更新的，所以会导致一种情况是，某张证书被吊销后，由于CRLs文件没有及时更新的缘故，身份校验通过了，认为该张证书没有问题。\n所以为了解决对应的问题，SSL中包含一种新协议\nOCSP OCSP（Online Certificate Status Protocol），即在线证书状态协议。同样是用来做服务器身份校验，由CA机构管理，使用数字签名技术保护，浏览器可以从中获得证书的吊销状态和吊销原因，方式是由身份校验方浏览器发送OCSP请求，等待响应来完成证书状态获取。当然OCSP的格式同样要遵照标准rfc6960。这里就不细解析OCSP格式了，可以参考标准文档。\n当然OCSP最为协议当然也有request和response(其实csr就是请求，申请下来的证书就是答复)，这里贴一下request的格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  OCSPRequest ::= SEQUENCE { tbsRequest TBSRequest, optionalSignature [0] EXPLICIT Signature OPTIONAL } TBSRequest ::= SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, requestorName [1] EXPLICIT GeneralName OPTIONAL, requestList SEQUENCE OF Request, requestExtensions [2] EXPLICIT Extensions OPTIONAL } Signature ::= SEQUENCE { signatureAlgorithm AlgorithmIdentifier, signature BIT STRING, certs [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL} Version ::= INTEGER { v1(0) } Request ::= SEQUENCE { reqCert CertID, singleRequestExtensions [0] EXPLICIT Extensions OPTIONAL } CertID ::= SEQUENCE { hashAlgorithm AlgorithmIdentifier, issuerNameHash OCTET STRING, -- Hash of issuer\u0026#39;s DN issuerKeyHash OCTET STRING, -- Hash of issuer\u0026#39;s public key serialNumber CertificateSerialNumber }   尾声 看起来X.509这一系列好像很简单的样子，然而这里打出来的其实都是完成解析之后的样子，那么解析之前的DER格式的证书是啥样子的呢：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  00000000: 3082 04c8 3082 03b0 a003 0201 0202 1100 0...0........... 00000010: bc01 4105 22d8 cc7f 0200 0000 0079 647f ..A.\u0026#34;........yd. 00000020: 300d 0609 2a86 4886 f70d 0101 0b05 0030 0...*.H........0 00000030: 4231 0b30 0906 0355 0406 1302 5553 311e B1.0...U....US1. 00000040: 301c 0603 5504 0a13 1547 6f6f 676c 6520 0...U....Google 00000050: 5472 7573 7420 5365 7276 6963 6573 3113 Trust Services1. 00000060: 3011 0603 5504 0313 0a47 5453 2043 4120 0...U....GTS CA 00000070: 314f 3130 1e17 0d32 3030 3832 3630 3831 1O10...200826081 00000080: 3432 335a 170d 3230 3131 3138 3038 3134 423Z..2011180814 00000090: 3233 5a30 6831 0b30 0906 0355 0406 1302 23Z0h1.0...U.... 000000a0: 5553 3113 3011 0603 5504 0813 0a43 616c US1.0...U....Cal 000000b0: 6966 6f72 6e69 6131 1630 1406 0355 0407 ifornia1.0...U.. 000000c0: 130d 4d6f 756e 7461 696e 2056 6965 7731 ..Mountain View1 000000d0: 1330 1106 0355 040a 130a 476f 6f67 6c65 .0...U....Google 000000e0: 204c 4c43 3117 3015 0603 5504 0313 0e77 LLC1.0...U....w 000000f0: 7777 2e67 6f6f 676c 652e 636f 6d30 5930 ww.google.com0Y0 00000100: 1306 072a 8648 ce3d 0201 0608 2a86 48ce ...*.H.=....*.H. 00000110: 3d03 0107 0342 0004 bc1c aa96 6f6f 9948 =....B......oo.H 00000120: 7956 614b 7fff dc39 083a d44d e2d8 8780 yVaK...9.:.M.... 00000130: af3d 185e 712d ce09 7057 3938 5f2a eea8 .=.^q-..pW98_*.. 00000140: 35f4 3a86 865a 1dc7 3132 1b8d acd0 46ad 5.:..Z..12....F. 00000150: c3fc a5d3 1836 68ab a382 025c 3082 0258 .....6h....\\0..X 00000160: 300e 0603 551d 0f01 01ff 0404 0302 0780 0...U........... 00000170: 3013 0603 551d 2504 0c30 0a06 082b 0601 0...U.%..0...+.. ...   啥啥啥，这是啥？？\n其实这就是反复提到的ASN.1格式。系列下一章就是手撕ASN.1, 做一个人肉decoder(想多了\u0026hellip;)\n","description":"X.509证书格式介绍","id":6,"section":"posts","tags":["OpenSSL"],"title":"X.509系列（一）：X.509 v3格式下的证书","uri":"https://summersummer3.github.io/posts/x509_1/"},{"content":"ASN.1编解码标准X.690 书接上文，我们有提到X.509格式的证书通常是使用ASN.1的格式编码的。那么ASN.1是个啥，如何进行编码解码呢。这篇文章主要用来解读ASN.1的标准，学习成为解码人柱力。\nASN.1与TLV 先看看wiki对于ANS.1格式的描述：\n 在电信和计算机网络领域，ASN.1（Abstract Syntax Notation One) 是一套标准，是描述数据的表示、编码、传输、解码的灵活的记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。\n 看起来很厉害，再看看其类别有哪些：\n ASN.1本身只定义了表示信息的抽象句法，但是没有限定其编码的方法。各种ASN.1编码规则提供了由ASN.1描述其抽象句法的数据的值的传送语法（具体表达）。标准的ASN.1编码规则有基本编码规则（BER，Basic Encoding Rules）、规范编码规则（CER，Canonical Encoding Rules）、唯一编码规则（DER，Distinguished Encoding Rules）、压缩编码规则（PER，Packed Encoding Rules）XML编码规则（XER，XML Encoding Rules）。\n 很显然，这种编码方法非常多。但是不要慌，大部分密码相关标准用到的编码方式都是BER/CER/DER，而后面两种则是对BER增加限制后的产物。至于PER/XER，至少在笔者目前工作中还没有接触到过，本文就不进行介绍了。\n为什么要把前三者归为一类呢，原因很简单，这三种编码方式是一种典型TLV的编码方法。TLV:Type-Length-Value, 是一种各类通讯协议中都非常常见的编码手段，他将一段数据分解使用Type描述了数据类型，用Length描述的数据长度，最后的Value表示了真正的data。其优点也非常明显，他可以将一段数据以二进制的格式编码，大量压缩了编码导致的报文体积膨胀的消耗，同时由于编码简单，解析速度也非常迅速。其结构很简单，通常如下：\nType | Length | Value\n以一个手机号码的编码为例18570917612：\n先看Type，假设用一个字节表示Type，如0x00表示手机号码，0x01表示固定电话号码，0x02表示传真号等等。当然此时还可以区分国家号、区号等等，都可以通过Type进行拓展，这里我们简单只考虑号码的类型。那显然可以编码为0x00, 编码的类型通过也称为Tag。\nLength就比较简单，通常标识字节数，而手机号码通常是使用ASCII码来标识，则每一个手机号码数字被编码为一个字节，总计就是11，长度被编码为0x0B.\n最后Value就是数据主体，使用ASCII编码则为：0x31 0x38 0x35 0x37 0x30 0x39 0x31 0x37 0x36 0x31 0x32\n最终这个手机号码将被编码为(去掉0x，直接看真实的二进制下表示)：\n   Tag Length Value     00 0B 31 38 35 37 30 39 31 37 36 31 32    当然，TLV是支持嵌套的，即Value同样是一个TLV编码的数据。后面也将会看到。\nX.690 既然ASN.1是一个通用的，和通信与密码强相关的编码记法，当然是需要一个明确的标准。而X.690是当前比较公认的标准。主要也是定义了BER/CER/DER这三种编码格式。下文的解析也是遵循该标准的(08/2015)版本 。\nBER 作为基础编码规则，我们首先学习它。BER通常把一个字节叫做Octets，而从低到高的比特位分别被叫做bit1 - bit8，和通常计算机对于最低比特称作bit0略有不同。\n先贴一下之前的X.509证书, 用于后文实例解析中的对比:\nCertificate: Data: Version: 3 (0x2) Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT Subject: C = US, ST = California, L = Mountain View, O = Google LLC, CN = www.google.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:bc:1c:aa:96:6f:6f:99:48:79:56:61:4b:7f:ff: dc:39:08:3a:d4:4d:e2:d8:87:80:af:3d:18:5e:71: 2d:ce:09:70:57:39:38:5f:2a:ee:a8:35:f4:3a:86: 86:5a:1d:c7:31:32:1b:8d:ac:d0:46:ad:c3:fc:a5: d3:18:36:68:ab ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Authority Information Access: OCSP - URI:http://ocsp.pki.goog/gts1o1core CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt X509v3 Subject Alternative Name: DNS:www.google.com X509v3 Certificate Policies: Policy: 2.23.140.1.2.2 Policy: 1.3.6.1.4.1.11129.2.5.3 X509v3 CRL Distribution Points: Full Name: URI:http://crl.pki.goog/GTS1O1core.crl CT Precertificate SCTs: Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 5E:A7:73:F9:DF:56:C0:E7:B5:36:48:7D:D0:49:E0:32: 7A:91:9A:0C:84:A1:12:12:84:18:75:96:81:71:45:58 Timestamp : Aug 26 09:14:24.417 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:20:77:F3:D6:8B:51:4F:88:71:16:73:ED:36: 2F:64:F4:77:3E:92:D3:CE:97:1F:1C:53:FA:4E:FB:5B: D7:0A:4C:D6:02:21:00:9F:B9:FE:F1:F3:1C:0D:CF:20: 30:B1:1C:0A:01:65:AD:67:90:1F:B5:33:90:8D:49:4D: 2B:ED:1D:90:28:A1:6B Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 07:B7:5C:1B:E5:7D:68:FF:F1:B0:C6:1D:23:15:C7:BA: E6:57:7C:57:94:B7:6A:EE:BC:61:3A:1A:69:D3:A2:1C Timestamp : Aug 26 09:14:24.367 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:21:00:F4:67:8E:8B:ED:3F:B2:D4:EA:72:EB: 53:F1:52:57:98:D6:63:0E:C0:6B:68:46:CE:F3:AD:25: 52:AD:12:83:27:02:20:05:CA:04:76:D6:4F:2A:E5:D3: 96:85:79:A2:F3:85:29:9E:89:30:00:A7:20:99:2D:F7: C9:56:3C:4E:5D:5C:CF Signature Algorithm: sha256WithRSAEncryption 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: 32:99:29:f8:13:6b:72:af:16:79:63:d3:3f:76:56:57:19:78: 91:86:f8:7a:ee:26:67:98:dc:5e:e4:00:f5:87:a0:01:21:9d: cf:e5:9f:02:f3:2a:fd:0e:fd:78:af:2e:20:29:77:35:e2:c6: 30:ee:ef:be:f2:bb:26:02:52:a2:2d:27:78:ce:a9:8e:39:d0: a2:74:90:11:c5:92:58:3c:7a:88:1d:c7:5a:56:d4:1a:01:00: c3:9d:98:6f:41:02:1f:cb:e2:4d:99:6a:5c:d9:0f:c0:88:08: 15:c5:26:90:a2:a4:15:f6:71:e2:fe:a9:98:dc:40:2a:71:c1: 11:aa:00:73:52:24:74:aa:ae:72:55:2f:0d:31:b7:00:bb:1f: 87:4d:f5:05:ad:ff:7a:93:e0:cf:86:a5:1d:1b:7d:41:fa:10: 99:3b:00:7c:c9:dd:a9:52:5c:06:72:86:96:e7:05:97:77:12: 2f:26:bb:dc:65:c4:48:4d:9c:82:4b:7d:69:27:3f:85:00:2e: b1:5d:8d:dc  Identifier Octets 标识字节，可以理解为TLV中的Type。BER中将其分解成三段如下：\n1 2 3 4  * Bit 8 7 6 5 1 * +-------+-----+------------+ * | Class | P/C | Tag number | * +-------+-----+------------+   先看Class段，两个比特bit7-bit8，定义了四种类型：\n   Class Bit 8 Bit 7     Universal (0x00) 0 0   Application (0x40) 0 1   Context-specific (0x80) 1 0   Private (0xC0) 1 1    其中Universal是最常用的，属于Native的类型都将属于该段。而Context-specific也比较多见，密码学相关编码较多。通常当字段的类型非标准类型时都将使用该类型作为Identifier Octets的高位。以X.509证书中标准ASN.1版本号为例，Type被描述为A0：\n1 2 3 4  Version ::= INTEGER { v1(0), v2(1), v3(2) } version [0] EXPLICIT Version DEFAULT v1, /* Tag is \u0026#39;A0\u0026#39;: 0x80 | 0x20 | 0 */   此时A0的高位比特即为1和0，对应Context-specific。Context-specific它只能使用在SEQUENCE、SET和CHOICE类型的组件中，而且可以看到有一个关键字EXPLICIT以及对应的关键字IMPLICIT用于配合使用。而中括号中间的0则标识了对应的Tag number, 注意该数字仅在该上下文中(即单独SEQUENCE、SET和CHOICE组成的内部)生效。\n其他两种使用很少，也不推荐使用，多用于某些应用和公司内部的私有协议，此处不讨论了。\n再看看P/C, 对应1个比特：0 = Primitive(0x00); 1 = Constructed(0x20)。通常该位标识后续的Value是一个原子值还是一个嵌套的TLV. 例如INTEGER只能为Primitive，而SEQUENCE 一定是Constructed；当然也有Both允许的类型，如BIT STRING，可能是嵌套的也可能是原子的，不过显然嵌套的情况比较少，X.509证书暂时没找到相关例子。\n最后是最关键的Tag Number，使用了5个比特(bit1 - bit5)标识了最基本的原生类型，下表将解释常用的类型：\n   Name Permitted Construction Decimal Tag number Hexadecimal Tag number     End-of-Content (EOC) Primitive 0 0   BOOLEAN Primitive 1 1   INTEGER Primitive 2 2   BIT STRING Both 3 3   OCTET STRING Both 4 4   NULL Primitive 5 5   OBJECT IDENTIFIER Primitive 6 6   UTF8String Both 12 C   SEQUENCE and SEQUENCE OF Constructed 16 10   SET and SET OF Constructed 17 11   PrintableString Both 19 13   T61String Both 20 14   IA5String Both 22 16   UTCTime Both 23 17   GeneralizedTime Both 24 18   UniversalString Both 28 1C   BMPString Both 30 1E    具体的在X.509所需的编码字段将在实例中进行讲解。需要特别提到的EOC通常用在TLV串结尾标识数据已结束，属于一种可选编码方式，X.509中未使用。\n一个问题在于，此时Tag Number是无法超过0x0F的，而根据X.690标准实际上是有超过0x0F种Tag的，此时该如何编码呢？ASN.1使用0b11111作为Tag Number进行拓展，此时接下来的字节为真实的Tag Number，其中当最高位比特bit8为标识位，0标识为最后一个字节，1标识为中间字节，最后进行比特串的拼接，大端编码。类似下面的标识：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  * Leading Octet Bit 8 7 6 5 1 * +-------+-----+---------+ * | Class | P/C | 0b11111 | * +-------+-----+---------+ * 2nd Octet Bit 8 7 1 * +---+------------+ * | 1 | 0bxxxxxxx | * +---+-----+------+ ... * Last Octet Bit 8 7 1 * +---+------------+ * | 0 | 0bxxxxxxx | * +---+-----+------+ * Example for tag number 0x80: 0b10000000 * binary : [class:P/C:11111][1:0000001][0:0000000] for 3-byte   不过这种情况比较少见，在密码学标准中基本不会出现。\nLength octets 标识了编码内容的长度，属于比较简单的字段。与Tag Number编码方式类似，也被区分为了短模式与长模式：\n短模式下，bit8将为0，剩下的比特将作为实际数据长度。例如上面的手机号码长度11，将被编码为0b00001011。显然这种情况下长度是有限的：不能超过127(0b01111111)个byte.\n超过127之后将使用长模式：第一个字节的最高比特bit8置1，剩下的比特将指示该长度将由多少个字节来表示，同样的将通过大端编码的方式形成一串比特串进行编码。以上一篇X.509的证书签名段为例：\n/* * Type 0x03 : Bit String * Length: * 1st Octet: 0b10000002(0x82): bit-8 = 1 stands for long form; * bit1-7 = 0x2 encode the number of subsequent octets in the length octets, bit-7 is the most significant bit; Note: 0xFF can\u0026#39;t be used. * 2nd and 3rd Octet: bit 8 of the first subsequent octet is the most significant bit; * 0b00000001|00000001(0x01 0x01) for content length 0x101. */ signatureValue BIT STRING (Encoded as: [03] [82 01 01] [Signature]) 这里有个疑问：为啥RSA-2048为啥出来需要0x101个字节，多了一个字节啊。其实看一下就知道，编码的最高字节为0x00。至于这个的用法如何将在后续对不同Type的内容做编码时讲到。\n此外ASN.1提供了另外一种灵活的编码方式：即当Length被编码为0b10000000(0x80)时，长度被定义为不定模式(Indefinite)，后续Contents octets的尾部则必须加上上节提到的EOC，标识内容结束。\nContents octets 编码内容，这个部分将对X.509系列所需常用的类型编码方式进行详述\nEOC EOC模式一定为以下格式:\n   Identifier Length Contents     0x00 0x00 NULL    Boolean 布尔类型非常简单，Type的Class为Universal ，非嵌套，Tag number为0x1, Length为0x1。当Value字节为全0时记为false, 否则为true；下表表示一种布尔类型的编码，共3字节。\n   Identifier Length Contents     0x01 0x01 0xFF    X.509中有一个标准的拓展字段用了该布尔类型：\n/* X509v3 Basic Constraints: critical CA:FALSE */ /* encode: */ [01] [01] [FF] Integer Type的Class为Universal ，非嵌套，Tag number为0x02, Length为编码的字节长度，content为大数编码的整数，即第一个字节的最高比特为MSB，直接以上一章证书中间的serialNumber, 很简单，标识了一个大数88比特、11字节的大数：\n1 2 3 4 5 6  CertificateSerialNumber ::= INTEGER serialNumber CertificateSerialNumber /* Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f */ [02] [11] [00 BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F]   其中数字的比较与普通数字比较没有差别，如上述数字与[02] [10] [BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F]比较是相等的。\nBitstring Type的Class为Universal，可以为primitive也可以为constructed. Tag number为0x3. Length为编码的字节长度；其content的组成，第一个字节将编码了最后一个字节中填充的0bit的个数, 故解码时也应该去除掉最后一个自己的对应比特数的0，该字节被称为Unused bits；通常可以使用多个primitive的Bitstring分段，组成一个constructed的Bitstring, 此时Length可以设置为不定长模式0x80. 通常不需要使用construct模式。看下面的例子：\n/* If of type BIT STRING, the value \u0026#39;0A3B5F291CD\u0026#39;H */ /* Primitive mode encode: 04 stands for the last byte include 4 bit padding */ [03] [07] [[04] 0A 3B 5F 29 1C D0] /* * Constructed mode encode: 23 stands for 0x00(class) | 0x20(constructed) | 0x03(Tag number) * The Bitstring consists of 2 sub-bitstrings: 0A3B, first byte 00 stands for 0 padding bits; * And 5F291CD0, first byte 04 last byte include 4 bit padding. */ [23] [0C] [[[03] [03] [[00] 0A 3B]] [[03] [05] [[04] 5F 29 1C D0]]] 解释一下X.509里签名段的编码：\nsignatureValue BIT STRING /* * Signature Algorithm: sha256WithRSAEncryption * 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: * 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: * 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: * ... */ /* The first byte 00 stands for 0 padding bits */ Encoded as: [03] [82 01 01] [[00] 7A 9A 76 80 C9 39 13 8E 60 B1 93 5D ...] Octetstring 与Bitstring基本类似，差别在于Tag number为0x3，且因为最小以字节为单位，无需第一个字节标识填充信息。通常在X.509使用在Extension中，标准下ASN.1的extnValue格式为Octetstring，同时由于此类型支持其他类型的嵌套，以之前证书authorityKeyIdentifier的extnValue为例：\n1 2 3 4 5 6 7 8  Extension ::= SEQUENCE { extnID OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING } /* X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B */ [04] [18] [30 16 80 14 98 D1 F8 6E 10 EB CF 9B EC 60 9F 18 90 1B A0 EB 7D 09 FD 2B]   NULL Type的Class为Universal，primitive. Tag number为0x5，Length一定为0. 不需要Content，即通常编码固定为05 00; X.509中在AlgorithmIdentifier会出现，如本文的例子中：\n1 2 3 4 5 6  AlgorithmIdentifier ::= SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINED BY algorithm OPTIONAL } /* parameters == NULL encoded in {} */ [30] [0D] [[[06] [09] [2A 86 48 86 F7 0D 01 01 0B]] {[05] [00]}]   Sequence/Sequence of 许多使用ASN.1定义的协议都是基于该类型定义的. Type的Class为Universal, Constructed, Tag number为0x10. 故Identifier通常为0x30。通过上一节就能看到，其实整张X.509证书就是一个sequence，它由 Version, CertificateSerialNumber, AlgorithmIdentifier等多个类型的字段组合而成。例子可以参考上面的AlgorithmIdentifier；同时可以看一下整张证书的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13  Certificate ::= SEQUENCE { tbsCertificate TBSCertificate, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING } /* Cert: length = 0x4C8 */ /* * TBSCertificate and signatureAlgorithm are also SEQUENCEs with length 0x3B0 and 0x0D * signatureValue is BIT STRING with length 0x101, bits padding number is 0 */ [30] [82 04 C8] [[[30] [82 03 B0] [A0 03 02 01 02 02 11 00 ...]] [[30] [0D] [30 0D 06 09 2A 86 48 86 ...]] [[03] [82 01 01] [[00] 7A 9A 76 80 C9 39 13 8E 60 B1 93 5D 99 49 1B 71 ...]]]   注意：证书中被签名的字段需要忽略掉Certificate编码中的Identifier和Length，本例中被签名段将忽略掉前两个中括号的内容, 即第三个中括号中的第一个中括号[[30] [82 03 B0] [A0 03 02 01 02 02 11 00 ...] 为被签名段.\nSet/Set of Type的Class为Universal, Constructed, Tag number为0x11. 故Identifier通常为0x31。与Sequence基本一致，区别在于此类型在定义、解析和编码时无需强制顺序，没有前后顺序，各成员体等价。在X.509中Name类型包含set类型.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  Name ::= CHOICE { -- only one possibility for now -- rdnSequence RDNSequence } RDNSequence ::= SEQUENCE OF RelativeDistinguishedName RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue AttributeTypeAndValue ::= SEQUENCE { type AttributeType, value AttributeValue } AttributeType ::= OBJECT IDENTIFIER AttributeValue ::= ANY -- DEFINED BY AttributeType /* The encoding of a choice value shall be the same as the encoding of a value of the chosen type. */ /* * Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 * Sequence { *\tSet { *\tSequence { *\ttype OBJECT IDENTIFIER, value AttributeValue *\t}, *\tSequence { *\ttype OBJECT IDENTIFIER, value AttributeValue *\t}, ... }, *\tSet { ... } * } */ /* Sequence 30 { set 31 { Sequence 30 {OID 06, Printable String 13 }} ... } */ [30] [42] [[[31] [0B] [[30] [09] [[[06] [03] [55 04 06]] [[13] [02] [55 53]]]]] ... ]   UTCTime Type的Class为Universal, Primitive和Constructed都可能, 通常为Primitive，Tag number为0x17。其编码为ascii码下的YYMMDDhhmm[ss]Z或YYMMDDhhmm[ss](+|-)hhmm。\nYY表示年，其中如果YY \u0026lt; 50则年份为20YY年，否则为19YY年，如YY = 50则标识1950年；MM表示月份，DD表示日；hhmmss表示时分秒，其中ss是可选项。\nZ则标识Zulu时间，而(+|-)hhmm则标识了与格林威治标准时间的时差, +标识标准时间提前，-标识推后。Z与时差不能共用。\n看看X.509中的例子：\n/* Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT */ /* ascii code, print as 200826081423Z */ [17] [0D] [32 30 30 38 32 36 30 38 31 34 32 33 5A] /* ascii code, print as 201118081423Z */ [17] [0D] [32 30 31 31 31 38 30 38 31 34 32 33 5A]  Restricted character string 标识一组收到限制的string类型，如NumericString/VisibleString/PrintableString等. X.509最主要使用的是PrintableString。以Set例子中的Name里可打印字符US为例，identifier = 0x13：\n /* * PrintableString * length = 2 * \u0026#34;US\u0026#34; : 0x55 0x53 */ [13] [02] [55 53] Object identifier 简称OID，是一个用来编码特殊意义字段的标准定义ID，属于ITU-T和ISO/IEC共同开发的一种广泛使用的机制来命名任何类型的对象、概念或事物，具有一个全局明确的名称和一个长生命周期的名称。\nType的Class为Universal, Primitive, Tag number为0x6.\n先看该OID解码的格式，通常为a.b.c.d....(被称为 dot notation). 其中每一个.将分割一个特殊意义的字符。\n a中比较典型的有iso(1)和joint-iso-itu-t(2) b中比较典型的有member-body(2); identified-organization(3); ds(5); country(16) c在X.509典型有certificateExtension(29); attributeType(4) d在X.509典型有countryName(6); organizationName(10)  当然还能延续。其中最典型的OID是算法ID，以上面证书为例子：sha256WithRSAEncryption的OID为1.2.840.113549.1.1.11; 对应{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha256WithRSAEncryption(11)}.\n具体查询OID含义可以查看网站http://oid-info.com，可以查到大部分符合标准定义下的OID的详细描述，以及每个OID下的child OID，非常方便。具体实现X.509功能相关所需的OID定义可以在下一部分的libmbedtls源码分析中看到oid.h中的定义。\n其content编码方式非常特殊：\n a和b将作为第一个字节进行编码，编码结果为：a * 40 + b。举个例子2.5的编码结果为0x55 = 85 = 2 * 40 + 5。 剩下的每个字节的编码相同，非常类似超过30之后的Tag number的编码方式：首先被分割为最少数量的没有头零数字的7位数字. 这些数字以big-endian格式进行组织, 并且一个接一个地组合成字节. 编码的最后一个字节j将为0,其他所有字节的最高位(位8)都为1。举个例子840 = 0b1101001000，编码为0b0000110 | 0b1001000，最后补充高位标记位0b10000110 | 0b01001000, 即0x86 0x48  看X.509中对sha256WithRSAEncryption的编码：\n/* 1.2.840.113549.1.1.11 */ /* * 0x2A = 42 = 1 * 40 + 2: \u0026#34;1.2\u0026#34; * 840 : 0x86 0x48 * 113549 = 0b (0000110 | 1110111 | 0001101): 0b10000110 0b11110111 0b00001101 = 0x86 0xF7 0x0D * Remained is simple encode as short integer. */ [06] [09] [2A 86 48 86 F7 0D 01 01 0B]  完成基础类型的学习，我们返回去看对于X.509 Version的编码就好理解了：\n1 2 3 4 5 6 7 8 9 10  version [0] EXPLICIT Version DEFAULT v1, Version ::= INTEGER { v1(0), v2(1), v3(2) } /* * EXPLICIT implies a context-specific(0x80) and construted by a integer; * [0] stands for the tag number; * so identifier: \u0026#39;A0\u0026#39;: 0x80 | 0x20 | 0 , length: 0x03, content: type integer; * Interger tag 0x02, length 0x01, content 0x02; */ [A0] [03] [[02] [01] [02]]   完成基础的BER编码规则的学习之后，CER和DER就很好理解了，他们对BER多加了一些可用性的限制。先看两者共有的与X.509相关的限制。\nCommon Restrictions  Bool FALSE所有比特应被编码1，即该字节为0xFF Bitstring不应该出现需要补充比特的情况，即Unused bits应该为0 Sequence/Set中被设置为默认值的成员不应编码 UTCTime仅有Z模式  CER  identifier为Construted时，长度应该指定为indefinite(此处有疑问，.cer格式下的证书constructed也有使用definite长度的) identifier为primitive时，长度应该指定为最短字节：例如长度0x10在BER中可以编码为0x81 0x10, CER增加了该限制  DER  长度只能使用definite模式 bitstring, octetstring 和 restricted character string不能使用construted Set中的组成值需与ASN.1定义的顺序一致  基本上看完此文就可以化身人肉解码器了，最后推荐一个工具：ASN.1 Editor, 很好用。\n将着重分析X.509的编码解码在libmbedtls中的源码分析，相当硬核。\n","description":"X.509证书编码介绍","id":7,"section":"posts","tags":["OpenSSL"],"title":"X.509系列（二）：ASN.1编解码标准X.690","uri":"https://summersummer3.github.io/posts/x509_2/"},{"content":"问题来源 OpenSSL Engine是啥，在这个地方就不细说了，资料很多，可以看看知乎这篇中文文档:\nhttps://zhuanlan.zhihu.com/p/70444766\n英文文档:\nhttps://wiki.openssl.org/index.php/Creating_an_OpenSSL_Engine_to_use_indigenous_ECDH_ECDSA_and_HASH_Algorithms#Author\n直接进入正题，我们首先查看一个OpenSSL Engine的例子：\nhttps://github.com/nibrunie/OSSL_EngineX\n直接查看bind代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static int bind(ENGINE* e, const char* id) { int ret = 0; if (!ENGINE_set_id(e, engine_id)) { fprintf(stderr, \u0026#34;ENGINE_set_id failed\\n\u0026#34;); goto end; } if (!ENGINE_set_name(e, engine_name)) { printf(\u0026#34;ENGINE_set_name failed\\n\u0026#34;); goto end; } if (!ENGINE_set_digests(e, digest_selector)) { printf(\u0026#34;ENGINE_set_digest failed\\n\u0026#34;); goto end; } ret = 1; end: return ret; } IMPLEMENT_DYNAMIC_BIND_FN(bind) IMPLEMENT_DYNAMIC_CHECK_FN()   可以看到OpenSSL去加载Engine的动态库时，需要动态库去调用 IMPLEMENT_DYNAMIC_BIND_FN 完成engine绑定初始化。\n基本上所以教你写engine的教程到这就结束了，但是内部到底是怎么要关联上这个函数，并且触发上面的bind函数的呢？我们先来看看这个宏的具体定义：\n1 2 3 4 5 6 7 8 9 10 11 12  \\# define IMPLEMENT_DYNAMIC_BIND_FN(fn) \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \\ if (ENGINE_get_static_state() == fns-\u0026gt;static_state) goto skip_cbs; \\ CRYPTO_set_mem_functions(fns-\u0026gt;mem_fns.malloc_fn, \\ fns-\u0026gt;mem_fns.realloc_fn, \\ fns-\u0026gt;mem_fns.free_fn); \\ skip_cbs: \\ if (!fn(e, id)) return 0; \\ /* 调用了上面例子中的bind函数 */ return 1; }   可以看到此处定义了函数bind_engine，他会去执行用宏包裹住的函数，以完成初始化。然而你去搜索这个函数在OpenSSL中调用你一定会很失望，肯定没有你想要的结果。果然不是这么简单的，又是什么钩子挂在了什么ctx上吧，应该也不难。\n我找了不少资料，基本没发现啥靠谱的分析，没办法自己看源码吧。结果经过分析，我深刻的理解了OpenSSL的魔鬼调用，钩子的挂载可以说是很魔幻。此处源码分析基于目前的主线master，应该也是未来OpenSSL 3.0的架构了。\n至于Engine是怎么设置上重置后的密码算法的，将在后续更新。\n从加载Engine的main函数分析起 还是上面的例子，我们查看执行engine加载的可执行程序的源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int main(void) { // initializing OpenSSL library  OPENSSL_load_builtin_modules(); ENGINE_load_dynamic(); // building OpenSSL\u0026#39;s configuration file path  char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { fprintf(stderr, \u0026#34;OpenSSL failed to load required configuration\\n\u0026#34;); ERR_print_errors_fp(stderr); return 1; } ENGINE* eng = ENGINE_by_id(\u0026#34;engineX\u0026#34;); if(NULL == eng) { printf(\u0026#34;failed to retrieve engine by id (mppa)\\n\u0026#34;); return 1; } printf(\u0026#34;EngineX has been successfully loaded \\n\u0026#34;); ... }   可以看到我们这个例子是从一个cnf配置文件去加载对应的engine的，这里提一句，加载engine有几个方式，如命令行加载，手动代码加载等。这里用配置文件加载做例子是因为这个场景更加接近实际业务场景，而且流程基本涵盖全流程，值得源码去分析。接下来我们按照调用顺序来分析这样一个漫长的调用过程。\nOPENSSL_load_builtin_modules 第一个函数，初始化了一个默认的conf_module, 且名字叫做\u0026rsquo;engines\u0026rsquo;。直接看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void OPENSSL_load_builtin_modules(void) { ... /* 我们其他的都不重要，直接看这个和Engine相关的 */ #ifndef OPENSSL_NO_ENGINE  ENGINE_add_conf_module(); #endif  ... } void ENGINE_add_conf_module(void) { CONF_module_add(\u0026#34;engines\u0026#34;, int_engine_module_init, int_engine_module_finish); }   来到我们的第一个大坑，OpenSSL的动态配置文件加载，但这里我们不需要细致了解，先简单分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  int CONF_module_add(const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { if (module_add(NULL, name, ifunc, ffunc)) return 1; else return 0; } /* 重要的结构体与全局变量 */ static STACK_OF(CONF_MODULE) *supported_modules = NULL; static STACK_OF(CONF_IMODULE) *initialized_modules = NULL; struct conf_module_st { /* DSO of this module or NULL if static */ DSO *dso; /* Name of the module */ char *name; /* Init function */ conf_init_func *init; /* Finish function */ conf_finish_func *finish; /* Number of successfully initialized modules */ int links; void *usr_data; }; typedef struct conf_module_st CONF_MODULE; static CONF_MODULE *module_add(DSO *dso, const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { CONF_MODULE *tmod = NULL; /* 若supported_modules为空， 则初始化此全局变量，即堆栈的初始化 */ if (supported_modules == NULL) supported_modules = sk_CONF_MODULE_new_null(); if (supported_modules == NULL) return NULL; /* 申请配置文件模块结构体conf_module_st的空间 */ if ((tmod = OPENSSL_zalloc(sizeof(*tmod))) == NULL) { CONFerr(CONF_F_MODULE_ADD, ERR_R_MALLOC_FAILURE); return NULL; } /* * 此处第一次调用，dso为NULL； * dso = dynamic shared object, 可以理解为是一个OpenSSL去加载动态库的结构体； */ tmod-\u0026gt;dso = dso; /* 此处记住，将初始化一个叫\u0026#34;engines\u0026#34;的conf_module */ tmod-\u0026gt;name = OPENSSL_strdup(name); /* 配置文件init函数， 此处即int_engine_module_init。这个函数是关键 */ tmod-\u0026gt;init = ifunc; /* 配置文件finish函数， 此处即int_engine_module_finish */ tmod-\u0026gt;finish = ffunc; if (tmod-\u0026gt;name == NULL) { OPENSSL_free(tmod); return NULL; } /* 将这个的conf_module结构体入栈进supported_modules这个全局变量栈中 */ if (!sk_CONF_MODULE_push(supported_modules, tmod)) { OPENSSL_free(tmod-\u0026gt;name); OPENSSL_free(tmod); return NULL; } return tmod; }   此处有一个OpenSSL的一个知识点，OpenSSL中可以定义任意类型的安全栈，并且生成操作这个类型栈的函数族。例如有一个结构体叫XX，则可以通过DEFINE_STACK_OF(XX)这个宏来定义XX结构体的栈和函数族，通过STACK_OF(XX)来声明一个栈。事实上，当我们看OpenSSL源码时看到sk_这种前缀的都是堆栈操作，而且是搜索不到实现的 (1.0.2版本应该可以找到，之后的版本都泛化了，代码写的秀，看代码的自闭)。\n详见官方文档：https://www.openssl.org/docs/man1.1.0/man3/DEFINE_STACK_OF.html\n此处有两个栈操作: 初始化时supported_modules为空，所以将调用sk_CONF_MODULE_new_null先建立上一个空容器。之后sk_CONF_MODULE_push使上面初始化的的CONF_MODULE入栈，之后想要取到这个module则需要通过supported_modules这个全局栈来取。\n此处多提一句，OpenSSL还有一个类似的结构体LHASH，它是OpenSSL内部的哈希表，如果这篇文章有下我们应该会碰到它，直接理解成是一个kv_map就好。所有lh_前缀开头的也都是哈希表操作。\nENGINE_load_dynamic 第二个函数，比较绕，简单理解就是：初始化了一个engine, 名字叫做dynamic，OpenSSL用这个engine来动态加载别的engine\u0026hellip;\n顺便提一句，ENGINE_load_dynamic 在1.1.x版本已经废弃了，统一都是调用OPENSSL_init_crypto这个函数，opts = OPENSSL_INIT_ENGINE_DYNAMIC。这又是OpenSSL非常恶心的地方了，版本兼容可以说是相当emmmmmmmm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \\# define ENGINE_load_dynamic() \\ OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_DYNAMIC, NULL) int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings) { ... /* * RUN_ONCE是多线程时需要关心的，我们这里不关心，就等于调用ossl_init_engine_dynamic * 最后一波宏展开，调用的是 engine_load_dynamic_int 这个函数 */ if ((opts \u0026amp; OPENSSL_INIT_ENGINE_DYNAMIC) \u0026amp;\u0026amp; !RUN_ONCE(\u0026amp;engine_dynamic, ossl_init_engine_dynamic)) return 0; ... } void engine_load_dynamic_int(void) { ENGINE *toadd = engine_dynamic(); /* 这命名真是绝了Orz */ if (!toadd) return; ENGINE_add(toadd); /* * If the \u0026#34;add\u0026#34; worked, it gets a structural reference. So either way, we * release our just-created reference. */ ENGINE_free(toadd); /* * If the \u0026#34;add\u0026#34; didn\u0026#39;t work, it was probably a conflict because it was * already added (eg. someone calling ENGINE_load_blah then calling * ENGINE_load_builtin_engines() perhaps). */ ERR_clear_error(); }   engine_dynamic 两个核心函数，第一个 engine_dynamic 新建了一个id叫做'dynamic'的engine，挂上了这个engine的具体处理函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static ENGINE *engine_dynamic(void) { /* OpenSSL申请结构体空间经常使用的xx_new */ ENGINE *ret = ENGINE_new(); if (ret == NULL) return NULL; if (!ENGINE_set_id(ret, engine_dynamic_id) || !ENGINE_set_name(ret, engine_dynamic_name) || !ENGINE_set_init_function(ret, dynamic_init) || !ENGINE_set_finish_function(ret, dynamic_finish) || !ENGINE_set_ctrl_function(ret, dynamic_ctrl) || !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) || !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) { ENGINE_free(ret); return NULL; } return ret; }   我们扫一眼ENGINE结构体，首先要有一个概念，ENGINE_set_xx 就是去设置这个结构体的相应字段，所以可以记录一下这个结构体被初始化成啥样了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct engine_st { const char *id; const char *name; const RSA_METHOD *rsa_meth; const DSA_METHOD *dsa_meth; const DH_METHOD *dh_meth; const EC_KEY_METHOD *ec_meth; const RAND_METHOD *rand_meth; /* Cipher handling is via this callback */ ENGINE_CIPHERS_PTR ciphers; /* Digest handling is via this callback */ ENGINE_DIGESTS_PTR digests; /* Public key handling via this callback */ ENGINE_PKEY_METHS_PTR pkey_meths; /* ASN1 public key handling via this callback */ ENGINE_PKEY_ASN1_METHS_PTR pkey_asn1_meths; ENGINE_GEN_INT_FUNC_PTR destroy; ENGINE_GEN_INT_FUNC_PTR init; ENGINE_GEN_INT_FUNC_PTR finish; ENGINE_CTRL_FUNC_PTR ctrl; ENGINE_LOAD_KEY_PTR load_privkey; ENGINE_LOAD_KEY_PTR load_pubkey; ENGINE_SSL_CLIENT_CERT_PTR load_ssl_client_cert; const ENGINE_CMD_DEFN *cmd_defns; int flags; /* reference count on the structure itself */ CRYPTO_REF_COUNT struct_ref; /* * reference count on usability of the engine type. NB: This controls the * loading and initialisation of any functionality required by this * engine, whereas the previous count is simply to cope with * (de)allocation of this structure. Hence, running_ref \u0026lt;= struct_ref at * all times. */ int funct_ref; /* A place to store per-ENGINE data */ CRYPTO_EX_DATA ex_data; /* Used to maintain the linked-list of engines. */ struct engine_st *prev; struct engine_st *next; }   整理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  static const char *engine_dynamic_id = \u0026#34;dynamic\u0026#34;; static const char *engine_dynamic_name = \u0026#34;Dynamic engine loading support\u0026#34;; static const ENGINE_CMD_DEFN dynamic_cmd_defns[] = { {DYNAMIC_CMD_SO_PATH, \u0026#34;SO_PATH\u0026#34;, \u0026#34;Specifies the path to the new ENGINE shared library\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_NO_VCHECK, \u0026#34;NO_VCHECK\u0026#34;, \u0026#34;Specifies to continue even if version checking fails (boolean)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_ID, \u0026#34;ID\u0026#34;, \u0026#34;Specifies an ENGINE id name for loading\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LIST_ADD, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_LOAD, \u0026#34;DIR_LOAD\u0026#34;, \u0026#34;Specifies whether to load from \u0026#39;DIR_ADD\u0026#39; directories (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_ADD, \u0026#34;DIR_ADD\u0026#34;, \u0026#34;Adds a directory from which ENGINEs can be loaded\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LOAD, \u0026#34;LOAD\u0026#34;, \u0026#34;Load up the ENGINE specified by other settings\u0026#34;, ENGINE_CMD_FLAG_NO_INPUT}, {0, NULL, NULL, 0} }; /* 加载动态engine时的命令 */ # define ENGINE_FLAGS_BY_ID_COPY (int)0x0004  ENGINE dynamic = {.id = engine_dynamic_id, .name = engine_dynamic_name, .init = dynamic_init, /* 空函数，直接return 0 */ .finish = dynamic_finish, /* 空函数，直接return 0 */ .ctrl = dynamic_ctrl, /* 最重要的函数，后文将分析如何调用到这来 */ .flags = ENGINE_FLAGS_BY_ID_COPY， .cmd_defns = dynamic_cmd_defns /*定义了dynamic这个engine ctrl下的合法cmd*/ .prev = NULL, .next = NULL /* 说明engine都是以双向链表形式管理 */ };   完成初始化后，将返回上这个new出来的ENGINE结构体。随后丢到ENGINE_add 里。\nENGINE_add 上面结构体分析其实已经可以看到，所有的engine都将以双向链表形式管理，链表建立简单粗暴，直接定义全局变量一头一尾，添加时就往尾巴加，搜索就从头结点开始搜索：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  static ENGINE *engine_list_head = NULL; static ENGINE *engine_list_tail = NULL; /* Add another \u0026#34;ENGINE\u0026#34; type into the list. */ int ENGINE_add(ENGINE *e) { int to_return = 1; /* 一些入参检查，omit */ ... /* 全局变量操作时需要加锁以支持多线程 */ CRYPTO_THREAD_write_lock(global_engine_lock); /* 核心函数，将刚刚new出来的dynamic加入全局链表中 */ if (!engine_list_add(e)) { ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR); to_return = 0; } CRYPTO_THREAD_unlock(global_engine_lock); return to_return; } static int engine_list_add(ENGINE *e) { int conflict = 0; ENGINE *iterator = NULL; if (e == NULL) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER); return 0; } /* 从链表头开始迭代 */ iterator = engine_list_head; /* 直接遍历到尾部查看有没有重id的情况，重id直接报错退出 */ while (iterator \u0026amp;\u0026amp; !conflict) { conflict = (strcmp(iterator-\u0026gt;id, e-\u0026gt;id) == 0); iterator = iterator-\u0026gt;next; } if (conflict) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } if (engine_list_head == NULL) { /* We are adding to an empty list. */ if (engine_list_tail) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* engine_list为空的话则链表头为新建的engine */ engine_list_head = e; e-\u0026gt;prev = NULL; /* * The first time the list allocates, we should register the cleanup. */ engine_cleanup_add_last(engine_list_cleanup); } else { /* We are adding to the tail of an existing list. */ if ((engine_list_tail == NULL) || (engine_list_tail-\u0026gt;next != NULL)) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* 将新engine加到队尾的后面 */ engine_list_tail-\u0026gt;next = e; e-\u0026gt;prev = engine_list_tail; } /* * Having the engine in the list assumes a structural reference. */ e-\u0026gt;struct_ref++; engine_ref_debug(e, 0, 1); /* 将队尾指向新engine */ engine_list_tail = e; e-\u0026gt;next = NULL; return 1; }   这样，id为'dynamic'被加入了全局engine列表当中，被管理起来。\nCONF 我们这里对OpenSSL的动态配置conf不需要细致分析，随着代码分析即可。官方文档其实对conf格式讲解的很清楚，可以学习:\nhttps://www.openssl.org/docs/man1.1.1/man5/config.html\nEngine Configuration Module这个小节\n例子中conf文件 首先我们来看engineX例子中的conf是怎么写的：\nopenssl_conf = openssl_def [openssl_def] engines = engine_section [engine_section] engine_x = engine_x_section [engine_x_section] engine_id = engineX dynamic_path = ${ENV::PWD}/build/engine_ex.so default_algorithms = ALL init = 1 简单学习一下conf之后，我们之后这个配置文件核心的section就是engine_section，其中dynamic_path定义上了该engine共享库的路径。我们看看例子中是如何根据这个配置文件去加载对应的engine的\nCONF_modules_load_file 1 2 3 4 5 6 7 8  ... char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { ... } ...   CONF_modules_load_file是去加载配置并使能配置的接口，这里我们主要关心如何去根据配置文件去加载动态库，具体怎么完成配置文件解析的流程这里不讨论。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  int CONF_modules_load_file(const char *filename, const char *appname, unsigned long flags) { return CONF_modules_load_file_with_libctx(NULL, filename, appname, flags); } int CONF_modules_load_file_with_libctx(OPENSSL_CTX *libctx, const char *filename, const char *appname, unsigned long flags) { char *file = NULL; CONF *conf = NULL; int ret = 0; conf = NCONF_new_with_libctx(libctx, NULL); if (conf == NULL) goto err; if (filename == NULL) { file = CONF_get1_default_config_file(); if (file == NULL) goto err; } else { file = (char *)filename; } if (NCONF_load(conf, file, NULL) \u0026lt;= 0) { if ((flags \u0026amp; CONF_MFLAGS_IGNORE_MISSING_FILE) \u0026amp;\u0026amp; (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) { ERR_clear_error(); ret = 1; } goto err; } ret = CONF_modules_load(conf, appname, flags); err: if (filename == NULL) OPENSSL_free(file); NCONF_free(conf); if (flags \u0026amp; CONF_MFLAGS_IGNORE_RETURN_CODES) return 1; return ret; }   可以看到这里主要有三步操作NCONF_new_with_libctx、NCONF_load、CONF_modules_load，我们一个一个分析。\nNCONF_new_with_libctx 这个函数主要是初始化上了一个CONF结构体，同时将这个结构体的METHOD定义成了默认方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  /* 配置文件的method模板 */ struct conf_method_st { const char *name; CONF *(*create) (CONF_METHOD *meth); int (*init) (CONF *conf); int (*destroy) (CONF *conf); int (*destroy_data) (CONF *conf); int (*load_bio) (CONF *conf, BIO *bp, long *eline); int (*dump) (const CONF *conf, BIO *bp); int (*is_number) (const CONF *conf, char c); int (*to_int) (const CONF *conf, char c); int (*load) (CONF *conf, const char *name, long *eline); }; /* * 所有的 AA = BB 都会按照这个格式保存 * 如[openssl_def] engines = engine_section * 此时这个底下conf_st的哈希表中将保存上一份 * {.section = \u0026#34;openssl_def\u0026#34;, .name = \u0026#34;engines\u0026#34;, value = \u0026#34;engine_section\u0026#34;} */ typedef struct { char *section; char *name; char *value; } CONF_VALUE; struct conf_st { CONF_METHOD *meth; /* 动态配置的方法，这里使用default */ void *meth_data; LHASH_OF(CONF_VALUE) *data; /* 上文有提到的哈希表 */ unsigned int flag_dollarid:1; OPENSSL_CTX *libctx; }; /* * The following section contains the \u0026#34;New CONF\u0026#34; functions. They are * completely centralised around a new CONF structure that may contain * basically anything, but at least a method pointer and a table of data. * These functions are also written in terms of the bridge functions used by * the \u0026#34;CONF classic\u0026#34; functions, for consistency. */ CONF *NCONF_new_with_libctx(OPENSSL_CTX *libctx, CONF_METHOD *meth) { CONF *ret; if (meth == NULL) meth = NCONF_default(); ret = meth-\u0026gt;create(meth); if (ret == NULL) { CONFerr(0, ERR_R_MALLOC_FAILURE); return NULL; } /* 这个流程中是NULL，不需要分析 */ ret-\u0026gt;libctx = libctx; return ret; }   我们先看NCONF_default：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 标记上这些方法，相关定义后续会给出，且将会使用 */ static CONF_METHOD default_method = { \u0026#34;OpenSSL default\u0026#34;, def_create, def_init_default, def_destroy, def_destroy_data, def_load_bio, def_dump, def_is_number, def_to_int, def_load }; CONF_METHOD *NCONF_default(void) { return \u0026amp;default_method; }   第一个在default_method被使用的方法就是def_create, 很明显是去申请一块CONF结构体内存，之后调用def_init_default去初始化结构体 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  static CONF *def_create(CONF_METHOD *meth) { CONF *ret; ret = OPENSSL_malloc(sizeof(*ret)); if (ret != NULL) /* 这里调用`def_init_default` */ if (meth-\u0026gt;init(ret) == 0) { OPENSSL_free(ret); ret = NULL; } return ret; } static int def_init_default(CONF *conf) { if (conf == NULL) return 0; memset(conf, 0, sizeof(*conf)); /* 将新申请的CONF结构体的method字段设置为默认method */ conf-\u0026gt;meth = \u0026amp;default_method; /* meth_data的设置，这个是.conf文件字符解析时候使用的，我们这里不讲 */ conf-\u0026gt;meth_data = (void *)CONF_type_default; return 1; }   NCONF_load 初始化好CONF结构体，确定好对应配置文件名，开始对配置文件进行解析，NCONF_load （OpenSSL连配置文件格式都自己定义自己解析，硬核硬核）将调用到默认方法之 def_load\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  int NCONF_load(CONF *conf, const char *file, long *eline) { if (conf == NULL) { CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF); return 0; } return conf-\u0026gt;meth-\u0026gt;load(conf, file, eline); } static int def_load(CONF *conf, const char *name, long *line) { int ret; BIO *in = NULL; /* 这里通过BIO读入文件(Binary IO, openssl自己定义的io，简单理解就是一块内存Orz) */ #ifdef OPENSSL_SYS_VMS  in = BIO_new_file(name, \u0026#34;r\u0026#34;); #else  in = BIO_new_file(name, \u0026#34;rb\u0026#34;); #endif  ... /* 正式解析，按段解析； * 这里不分析咋解析的，很复杂很长，甚至能处理一些环境变量$(xxx)... 服 * 最后结果都存在哈希表data中 */ ret = def_load_bio(conf, in, line); BIO_free(in); return ret; }   CONF_modules_load 核心过程，从CONF去加载第一部分提到的'engines'这个module:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  int CONF_modules_load(const CONF *cnf, const char *appname, unsigned long flags) { STACK_OF(CONF_VALUE) *values; CONF_VALUE *vl; char *vsection = NULL; int ret, i; if (!cnf) return 1; /* 先获取到对应的section名，这里就是\u0026#34;openssl_conf\u0026#34; */ if (appname) vsection = NCONF_get_string(cnf, NULL, appname); if (!appname || (!vsection \u0026amp;\u0026amp; (flags \u0026amp; CONF_MFLAGS_DEFAULT_SECTION))) vsection = NCONF_get_string(cnf, NULL, \u0026#34;openssl_conf\u0026#34;); if (!vsection) { ERR_clear_error(); return 1; } OSSL_TRACE1(CONF, \u0026#34;Configuration in section %s\\n\u0026#34;, vsection); /* * 找到第一个段 openssl_conf * [openssl_def] * engines = engine_section */ values = NCONF_get_section(cnf, vsection); if (!values) return 0; for (i = 0; i \u0026lt; sk_CONF_VALUE_num(values); i++) { vl = sk_CONF_VALUE_value(values, i); /* 遍历所有的value，这里只有一个 \u0026#39;engines\u0026#39; */ ret = module_run(cnf, vl-\u0026gt;name, vl-\u0026gt;value, flags); OSSL_TRACE3(CONF, \u0026#34;Running module %s (%s) returned %d\\n\u0026#34;, vl-\u0026gt;name, vl-\u0026gt;value, ret); if (ret \u0026lt;= 0) if (!(flags \u0026amp; CONF_MFLAGS_IGNORE_ERRORS)) return ret; } return 1; } static int module_run(const CONF *cnf, const char *name, const char *value, unsigned long flags) { CONF_MODULE *md; int ret; if (!RUN_ONCE(\u0026amp;load_builtin_modules, do_load_builtin_modules)) return -1; /* 这里会在supported_modules这个栈上找到\u0026#39;engines\u0026#39;这个CONF_MODULE，开始魔幻表演 */ md = module_find(name); ... /* init这个module，这里将去调用到\u0026#39;dynamic\u0026#39;这个engine，下面将分析 */ ret = module_init(md, name, value, cnf); ... return ret; } /* initialize a module */ /* 此处将申请上一个所谓的initialized module， * 之后调用\u0026#39;engines\u0026#39;的init函数 * 若成功，将\u0026#39;engines\u0026#39; push进的全局变量栈 initialized_modules */ static int module_init(CONF_MODULE *pmod, const char *name, const char *value, const CONF *cnf) { int ret = 1; int init_called = 0; CONF_IMODULE *imod = NULL; /* Otherwise add initialized module to list */ imod = OPENSSL_malloc(sizeof(*imod)); if (imod == NULL) goto err; imod-\u0026gt;pmod = pmod; imod-\u0026gt;name = OPENSSL_strdup(name); /* 即\u0026#39;engines\u0026#39; */ imod-\u0026gt;value = OPENSSL_strdup(value); imod-\u0026gt;usr_data = NULL; if (!imod-\u0026gt;name || !imod-\u0026gt;value) goto memerr; /* Try to initialize module */ if (pmod-\u0026gt;init) { /* 调用engines的init，即第一部分提到的int_engine_module_init函数 */ ret = pmod-\u0026gt;init(imod, cnf); init_called = 1; /* Error occurred, exit */ if (ret \u0026lt;= 0) goto err; } if (initialized_modules == NULL) { initialized_modules = sk_CONF_IMODULE_new_null(); if (!initialized_modules) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } } /* 将\u0026#39;engines\u0026#39; push进的全局变量栈 initialized_modules */ if (!sk_CONF_IMODULE_push(initialized_modules, imod)) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } pmod-\u0026gt;links++; return ret; err: ... }   CONF的第一部分处理完毕，开始查看如何继续解析这个配置\nint_engine_module_init 这部分开始取engines这个section下的数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  static int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf) { STACK_OF(CONF_VALUE) *elist; CONF_VALUE *cval; int i; OSSL_TRACE2(CONF, \u0026#34;Called engine module: name %s, value %s\\n\u0026#34;, CONF_imodule_get_name(md), CONF_imodule_get_value(md)); /* Value is a section containing ENGINEs to configure */ elist = NCONF_get_section(cnf, CONF_imodule_get_value(md)); /* * 获取engine_section下的列表，这里就一个section叫做engine_x_section * [engine_section] * engine_x = engine_x_section */ if (!elist) { ENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT, ENGINE_R_ENGINES_SECTION_ERROR); return 0; } for (i = 0; i \u0026lt; sk_CONF_VALUE_num(elist); i++) { cval = sk_CONF_VALUE_value(elist, i); /* * name: engine_x, value: engine_x_section * 准备开始加载了 */ if (!int_engine_configure(cval-\u0026gt;name, cval-\u0026gt;value, cnf)) return 0; } return 1; }   int_engine_configure 是加载engine的主要流程，我们按顺序来一步一步分析内部的循环\nint_engine_configure  首先加载上value的section：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { int i; int ret = 0; long do_init = -1; STACK_OF(CONF_VALUE) *ecmds; CONF_VALUE *ecmd = NULL; const char *ctrlname, *ctrlvalue; ENGINE *e = NULL; int soft = 0; name = skip_dot(name); OSSL_TRACE1(CONF, \u0026#34;Configuring engine %s\\n\u0026#34;, name); /* Value is a section containing ENGINE commands */ /* 在conf的哈希表中找 叫做engine_x_section的section */ ecmds = NCONF_get_section(cnf, value); /* * 此时ecmds是一个栈，按顺序有以下CONF_VALUE (共有section = \u0026#34;engine_x_section\u0026#34;) * {.name = \u0026#34;engine_id\u0026#34;, .value = \u0026#34;engineX\u0026#34;} * {.name = \u0026#34;dynamic_path\u0026#34;, .value = \u0026#34;${ENV::PWD}/build/engine_ex.so\u0026#34;(这里已经通配符解析 * 了)} * {.name = \u0026#34;default_algorithms\u0026#34;, .value = \u0026#34;ALL\u0026#34;} * {.name = \u0026#34;init\u0026#34;, .value = \u0026#34;1\u0026#34;} */ if (!ecmds) { ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE, ENGINE_R_ENGINE_SECTION_ERROR); return 0; } ... }    按照顺序解析：\n第一个是engine_id:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { ... /* 开始对ecmds中栈上的CONF_VALUE遍历，这部分代码都在这个for循环中 */ for (i = 0; i \u0026lt; sk_CONF_VALUE_num(ecmds); i++) { ecmd = sk_CONF_VALUE_value(ecmds, i); /* 解析出ctrlname和ctrlvalue，对应结构体中.name和.value, 下同 */ ctrlname = skip_dot(ecmd-\u0026gt;name); ctrlvalue = ecmd-\u0026gt;value; OSSL_TRACE2(CONF, \u0026#34;ENGINE: doing ctrl(%s,%s)\\n\u0026#34;, ctrlname, ctrlvalue); /* First handle some special pseudo ctrls */ /* Override engine name to use */ if (strcmp(ctrlname, \u0026#34;engine_id\u0026#34;) == 0) /* 把name制成conf文件中engine_id */ name = ctrlvalue; ... } ... }   第二个是dynamic_path， 这个定义最关键，找到这个name，开始按照指定路径加载动态库engine:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  for(...) { ... else if (strcmp(ctrlname, \u0026#34;dynamic_path\u0026#34;) == 0) { /* * 看到这里是不是豁然开朗，首先找到第二部分初始化的叫做dynamic的engine * 但这个地方有个值得注意的点，底下分析ENGINE_by_id */ e = ENGINE_by_id(\u0026#34;dynamic\u0026#34;); /* 拿到\u0026#39;dynamic\u0026#39;这个ENGINE结构体后，进行三步操作，完成了engineX这个so的加载 */ /* 之后我们将单独把ENGINE_ctrl_cmd_string拿出来分析，观察它是如何去加载的*/ if (!e) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;SO_PATH\u0026#34;, ctrlvalue, 0)) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;2\u0026#34;, 0)) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;LOAD\u0026#34;, NULL, 0)) goto err; ... } /* * 完成这三步操作后，\u0026#39;dynamic\u0026#39;副本这个engine已经被重写成了 \u0026#39;engineX\u0026#39;！ * 同时这个engineX也加入了engines的队列中。 */ ENGINE *ENGINE_by_id(const char *id) { /* 入参检查和环境初始化检查 omit */ ... /* 加锁后开始遍历链表，匹配id = \u0026#34;dynamic\u0026#34; */ CRYPTO_THREAD_write_lock(global_engine_lock); iterator = engine_list_head; while (iterator \u0026amp;\u0026amp; (strcmp(id, iterator-\u0026gt;id) != 0)) iterator = iterator-\u0026gt;next; if (iterator != NULL) { /* * We need to return a structural reference. If this is an ENGINE * type that returns copies, make a duplicate - otherwise increment * the existing ENGINE\u0026#39;s reference count. */ /* 匹配成功后的小操作：看ENGINE_load_dynamic源码可以看到 dynamic-\u0026gt;flag 被设置成了 ENGINE_FLAGS_BY_ID_COPY */ if (iterator-\u0026gt;flags \u0026amp; ENGINE_FLAGS_BY_ID_COPY) { ENGINE *cp = ENGINE_new(); if (cp == NULL) iterator = NULL; else { /* 此处很重要！ */ /* 此处取出的dynamic，不是直接取出链表中的engine节点，而是复制了一个节点 */ engine_cpy(cp, iterator); iterator = cp; } } else { iterator-\u0026gt;struct_ref++; engine_ref_debug(iterator, 0, 1); } } CRYPTO_THREAD_unlock(global_engine_lock); if (iterator != NULL) /* 作为取出返回值，得到了一个dynamic的副本 */ return iterator; }     注意，此时e这个局部变量已经是一个id为'engineX'的ENGINE结构体了，也就是完成了动态加载的engine！\n第三步是default_algorithms:\n1 2 3 4 5  for (...) { else if (strcmp(ctrlname, \u0026#34;default_algorithms\u0026#34;) == 0) { if (!ENGINE_set_default_string(e, ctrlvalue)) ... }   第四步，完成Init:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  for (...) { if (strcmp(ctrlname, \u0026#34;init\u0026#34;) == 0) { if (!NCONF_get_number_e(cnf, value, \u0026#34;init\u0026#34;, \u0026amp;do_init)) goto err; if (do_init == 1) { /* * 此处为1，完成engine init, * 具体代码就是调用ENGINE_init去执行e-\u0026gt;init, 增加引用数之类的，我们这里其实是空的 * 之后去把这个engine同时加入initialized_engines这个全局变量栈中。代码不看了 */ if (!int_engine_init(e)) goto err; ... }   就此CONF_modules_load全部运行完成，engineX加载完毕。后续只需要像main函数中的使用ENGINE_by_id(\u0026quot;engineX\u0026quot;);就可以取得这个engine了。圆满。\n但是 bind_engine 在哪调用的呢，还是没看到，那必然是在ENGINE_ctrl_cmd_string流程中。所以下面重点讲讲这个函数。\nENGINE_ctrl_cmd_string 从cmd_name去获取cmd_num 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { int num, flags; long l; char *ptr; ... /* 宏的命名已经暴露了一切，通过cmd_name得到cmd_num */ if (e-\u0026gt;ctrl == NULL || (num = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FROM_NAME, 0, (void *)cmd_name, NULL)) \u0026lt;= 0) { ... } ... } int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... /* * Intercept any \u0026#34;root-level\u0026#34; commands before trying to hand them on to * ctrl() handlers. */ switch (cmd) { /* 这部分是通用的ctrl，范围为10 ~ 18, 全部进入int_ctrl_helper */ case ENGINE_CTRL_HAS_CTRL_FUNCTION: return ctrl_exists; case ENGINE_CTRL_GET_FIRST_CMD_TYPE: case ENGINE_CTRL_GET_NEXT_CMD_TYPE: case ENGINE_CTRL_GET_CMD_FROM_NAME: case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: case ENGINE_CTRL_GET_NAME_FROM_CMD: case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: case ENGINE_CTRL_GET_DESC_FROM_CMD: case ENGINE_CTRL_GET_CMD_FLAGS: /* * 这里dynamic的flag为ENGINE_FLAGS_BY_ID_COPY，0x0004 * ENGINE_FLAGS_MANUAL_CMD_CTRL = 0x0002，与的结果为0 */ if (ctrl_exists \u0026amp;\u0026amp; !(e-\u0026gt;flags \u0026amp; ENGINE_FLAGS_MANUAL_CMD_CTRL)) return int_ctrl_helper(e, cmd, i, p, f); if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); /* * For these cmd-related functions, failure is indicated by a -1 * return value (because 0 is used as a valid return in some * places). */ return -1; } default: break; } /* Anything else requires a ctrl() handler to exist. */ /* 这里是确定当前engine-\u0026gt;ctrl != NULL */ if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); return 0; } /* 调用上面看到的 dynamic-\u0026gt;ctrl = dynamic_ctrl, 后面会调用到这来 */ return e-\u0026gt;ctrl(e, cmd, i, p, f); } /* 这个函数也将反复调用（吐槽下openssl这鬼之设计），我们这里先看当前的cmd */ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { int idx; char *s = (char *)p; const ENGINE_CMD_DEFN *cdp; ... /* Now handle cmd_name -\u0026gt; cmd_num conversion */ if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) { /* 从dynamic的cmd_defns中去匹配cmd_name,假设是\u0026#34;SO_PATH\u0026#34;, 直接去查第二部分的dynamic_cmd_defns，刚好匹配上idx = 0 */ if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(e-\u0026gt;cmd_defns, s)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME); return -1; } /* 查idx = 0时的 cmd_num = 200 = DYNAMIC_CMD_SO_PATH */ return e-\u0026gt;cmd_defns[idx].cmd_num; } ... }   可以看到这里的num返回回来的DYNAMIC_CMD_SO_PATH，是靠dynamic.cmd_defns中的ENGINE_CMD_DEFN数组表查询得到的。往下接着看ENGINE_ctrl_cmd_string\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { /* 继续调用公用ctrl，进入到int_ctrl_helper (看底下开源的注释，两个函数做的ctrl操作一样的，为啥这么搞也许就是未解之谜吧) */ ... if (!ENGINE_cmd_is_executable(e, num)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_CMD_NOT_EXECUTABLE); return 0; } /* 顾名思义，拿到dynamic的flag，这里将得到idx = 0时，cmd_defns表中0处的第四个元素 */ flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL); if (flags \u0026lt; 0) { /* * Shouldn\u0026#39;t happen, given that ENGINE_cmd_is_executable() returned * success. */ ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } } static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e-\u0026gt;cmd_defns, (unsigned int)i)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER); return -1; } /* Now the logic splits depending on command type */ cdp = \u0026amp;e-\u0026gt;cmd_defns[idx]; switch (cmd) { ... case ENGINE_CTRL_GET_CMD_FLAGS: /* 可以查出来上面的是 ENGINE_CMD_FLAG_STRING = 0x0002 */ return cdp-\u0026gt;cmd_flags; } ... }   别问为啥不一次查出来，要多次遍历，问就是架构。继续看ENGINE_ctrl_cmd_string，终于要做真正的操作了， 可以看到，最后进入了dynamic_ctrl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { ... /* ENGINE_CMD_FLAG_NO_INPUT = 0x0004 */ if (flags \u0026amp; ENGINE_CMD_FLAG_NO_INPUT) { /* 如果命令查出来的flag应该没有arg_input, 但arg非空，直接退出???? */ if (arg != NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_NO_INPUT); return 0; } /* * We deliberately force the result of ENGINE_ctrl() to 0 or 1 rather * than returning it as \u0026#34;return data\u0026#34;. This is to ensure usage of * these commands is consistent across applications and that certain * applications don\u0026#39;t understand it one way, and others another. */ /* 最后\u0026#34;LOAD\u0026#34;命令走的这 */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* So, we require input */ if (arg == NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_INPUT); return 0; } /* 一定有更好的写法吧，这种判断也太迷惑了。。 */ /* If it takes string input, that\u0026#39;s easy */ if (flags \u0026amp; ENGINE_CMD_FLAG_STRING) { /* Same explanation as above */ /* 所以应该调用到这，注意此时num 将大于200, 肯定不是默认的流程， 这就走到了return e-\u0026gt;ctrl(e, cmd, i, p, f); 即 dynamic_ctrl */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* 此时arg是数字，需要从str转int，LIST_ADD走这 */ if (!(flags \u0026amp; ENGINE_CMD_FLAG_NUMERIC)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } l = strtol(arg, \u0026amp;ptr, 10); if ((arg == ptr) || (*ptr != \u0026#39;\\0\u0026#39;)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER); return 0; } /* * Force the result of the control command to 0 or 1, for the reasons * mentioned before. */ if (ENGINE_ctrl(e, num, l, NULL, NULL) \u0026gt; 0) return 1; ... }   所以这个函数的主要步骤就是根据输入的cmd_name从dynamic中挂载的cmd_defns取出对应的cmd_num和flag，之后用cmd_num调用到dynamic挂载的ctrl字段函数去做真正的操作。我们用一张表统计下三次取到的结果：\n   cmd_name cmd_num flag     \u0026ldquo;SO_PATH\u0026rdquo; DYNAMIC_CMD_SO_PATH = 200 ENGINE_CMD_FLAG_STRING 0x0002   \u0026ldquo;LIST_ADD\u0026rdquo; DYNAMIC_CMD_LIST_ADD = 203 ENGINE_CMD_FLAG_NUMERIC 0x0001   \u0026ldquo;LOAD\u0026rdquo; DYNAMIC_CMD_LOAD = 206 ENGINE_CMD_FLAG_NO_INPUT 0x0004    根据这个表，我们去看对于dynamic-\u0026gt;ctrl即dynamic_ctrl函数对这几个cmd的操作\ndynamic_ctrl 先看这个函数的公共部分，对相同的engine会初始化上一个ctx上下文：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156  /* 动态库加载的上下文 */ struct st_dynamic_data_ctx { /* The DSO object we load that supplies the ENGINE code */ DSO *dynamic_dso; /* * The function pointer to the version checking shared library function */ dynamic_v_check_fn v_check; /* * The function pointer to the engine-binding shared library function */ dynamic_bind_engine bind_engine; /* The default name/path for loading the shared library */ char *DYNAMIC_LIBNAME; /* Whether to continue loading on a version check failure */ int no_vcheck; /* If non-NULL, stipulates the \u0026#39;id\u0026#39; of the ENGINE to be loaded */ char *engine_id; /* * If non-zero, a successfully loaded ENGINE should be added to the * internal ENGINE list. If 2, the add must succeed or the entire load * should fail. */ int list_add_value; /* The symbol name for the version checking function */ const char *DYNAMIC_F1; /* The symbol name for the \u0026#34;initialise ENGINE structure\u0026#34; function */ const char *DYNAMIC_F2; /* * Whether to never use \u0026#39;dirs\u0026#39;, use \u0026#39;dirs\u0026#39; as a fallback, or only use * \u0026#39;dirs\u0026#39; for loading. Default is to use \u0026#39;dirs\u0026#39; as a fallback. */ int dir_load; /* A stack of directories from which ENGINEs could be loaded */ STACK_OF(OPENSSL_STRING) *dirs; }; static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { /* 这个函数将会初始化并保存动态库数据的ctx，这也是为什么可以反复调用这个接口的原因 */ dynamic_data_ctx *ctx = dynamic_get_data_ctx(e); int initialised; if (!ctx) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED); return 0; } /* 可以看到，加载完成的标志是dynamic_dso钩子已经挂上了 */ initialised = ((ctx-\u0026gt;dynamic_dso == NULL) ? 0 : 1); /* All our control commands require the ENGINE to be uninitialised */ if (initialised) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED); return 0; } /* cmd解析，底下逐个分析 */ ... } /* * This function retrieves the context structure from an ENGINE\u0026#39;s \u0026#34;ex_data\u0026#34;, * or if it doesn\u0026#39;t exist yet, sets it up. */ static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e) { dynamic_data_ctx *ctx; if (dynamic_ex_data_idx \u0026lt; 0) { /* * Create and register the ENGINE ex_data, and associate our \u0026#34;free\u0026#34; * function with it to ensure any allocated contexts get freed when * an ENGINE goes underground. */ int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, dynamic_data_ctx_free_func); if (new_idx == -1) { ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX); return NULL; } CRYPTO_THREAD_write_lock(global_engine_lock); /* Avoid a race by checking again inside this lock */ if (dynamic_ex_data_idx \u0026lt; 0) { /* Good, someone didn\u0026#39;t beat us to it */ dynamic_ex_data_idx = new_idx; new_idx = -1; } CRYPTO_THREAD_unlock(global_engine_lock); /* * In theory we could \u0026#34;give back\u0026#34; the index here if (new_idx\u0026gt;-1), but * it\u0026#39;s not possible and wouldn\u0026#39;t gain us much if it were. */ } ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx); /* Check if the context needs to be created */ if ((ctx == NULL) \u0026amp;\u0026amp; !dynamic_set_data_ctx(e, \u0026amp;ctx)) /* \u0026#34;set_data\u0026#34; will set errors if necessary */ return NULL; return ctx; } /* * 简单的说就是去查挂在engine-\u0026gt;ex_data， * 这个就是动态库加载的上下文，ex_data是个栈可能有多个上下文， * 根据一个全局变量dynamic_ex_data_idx确定当前使用上下文 * 当然第一次调用ctx是空的，所以需要调用一下dynamic_set_data_ctx初始化 */ static int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx) { /* 申请ctx的mem */ dynamic_data_ctx *c = OPENSSL_zalloc(sizeof(*c)); int ret = 1; if (c == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); return 0; } c-\u0026gt;dirs = sk_OPENSSL_STRING_new_null(); if (c-\u0026gt;dirs == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); OPENSSL_free(c); return 0; } /* 初始化一些字段，下面总结 */ c-\u0026gt;DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, ; c-\u0026gt;DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;; c-\u0026gt;dir_load = 1; CRYPTO_THREAD_write_lock(global_engine_lock); /* 第一次进来为NULL(然而正常是为ctx = NULL才会调用这个函数，可能是冗余校验)*/ if ((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx)) == NULL) { /* Good, we\u0026#39;re the first */ /* 把ctx挂在engine-\u0026gt;ex_data上 */ ret = ENGINE_set_ex_data(e, dynamic_ex_data_idx, c); if (ret) { *ctx = c; c = NULL; } } CRYPTO_THREAD_unlock(global_engine_lock); /* * If we lost the race to set the context, c is non-NULL and *ctx is the * context of the thread that won. */ if (c) sk_OPENSSL_STRING_free(c-\u0026gt;dirs); OPENSSL_free(c); return ret; } /* * 得到最后的结果 dynamic-\u0026gt;ex_data = ctx; * ctx = {.DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, .DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;, c-\u0026gt;dir_load = 1} * 惊奇的发现了 bind_engine 虽然他只是个字符串，但是我相信你已经知道原因了 * 他需要在动态库中去寻找这个符号 */   之后我们逐一分析这三个cmd\nDYNAMIC_CMD_SO_PATH和DYNAMIC_CMD_LIST_ADD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { /* 注意， p就是ctrlvalue，即从conf中取下来的值 */ case DYNAMIC_CMD_SO_PATH: /* a NULL \u0026#39;p\u0026#39; or a string of zero-length is the same thing */ if (p \u0026amp;\u0026amp; (strlen((const char *)p) \u0026lt; 1)) p = NULL; OPENSSL_free(ctx-\u0026gt;DYNAMIC_LIBNAME); if (p) /* 很明显只是做了个简单的复制，此时路径已经赋值上了 */ ctx-\u0026gt;DYNAMIC_LIBNAME = OPENSSL_strdup(p); else ctx-\u0026gt;DYNAMIC_LIBNAME = NULL; return (ctx-\u0026gt;DYNAMIC_LIBNAME ? 1 : 0); case DYNAMIC_CMD_LIST_ADD: if ((i \u0026lt; 0) || (i \u0026gt; 2)) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT); return 0; } /* 很简单，赋值而已 */ ctx-\u0026gt;list_add_value = (int)i; return 1; ... } }   这两个都很简单，最后难点都给了LOAD\nDYNAMIC_CMD_LOAD 最关键的函数，完成了全部的加载，解释都在注释里：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { case DYNAMIC_CMD_LOAD: return dynamic_load(e, ctx); ... } } static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx) { ENGINE cpy; dynamic_fns fns; /* * 先new一个DSO结构体，DSO这一套函数怎么玩的这里先不讲了， * 可以理解为内部也有一个加载钩子，有4个挂载点，估计再展开讲读者疯了 */ if (ctx-\u0026gt;dynamic_dso == NULL) ctx-\u0026gt;dynamic_dso = DSO_new(); if (ctx-\u0026gt;dynamic_dso == NULL) return 0; /* 此处检查DYNAMIC_LIBNAME不能为空，这个就是dso的加载地址 */ if (!ctx-\u0026gt;DYNAMIC_LIBNAME) { if (!ctx-\u0026gt;engine_id) return 0; DSO_ctrl(ctx-\u0026gt;dynamic_dso, DSO_CTRL_SET_FLAGS, DSO_FLAG_NAME_TRANSLATION_EXT_ONLY, NULL); ctx-\u0026gt;DYNAMIC_LIBNAME = DSO_convert_filename(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;engine_id); } /* 核心加载函数int_load，看下面分析 */ if (!int_load(ctx)) { ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_NOT_FOUND); DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; return 0; } /* We have to find a bind function otherwise it\u0026#39;ll always end badly */ /* * 此时engine动态库已经加载如内存，符号表与对应地址也准备完成 * 所以肯定是需要去寻找这个绑定engine完成加载的函数了，胜利的曙光 * DSO_bind_func会在符号表中去匹配第二个参数字符串，这里就是我们要的\u0026#34;bind_engine\u0026#34; * 并返回上它的函数地址，挂载在ctx-\u0026gt;bind_engine上 */ if (! (ctx-\u0026gt;bind_engine = (dynamic_bind_engine) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F2))) { ctx-\u0026gt;bind_engine = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE); return 0; } /* Do we perform version checking? */ if (!ctx-\u0026gt;no_vcheck) { unsigned long vcheck_res = 0; /* * Now we try to find a version checking function and decide how to * cope with failure if/when it fails. */ ctx-\u0026gt;v_check = (dynamic_v_check_fn) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F1); if (ctx-\u0026gt;v_check) vcheck_res = ctx-\u0026gt;v_check(OSSL_DYNAMIC_VERSION); /* * We fail if the version checker veto\u0026#39;d the load *or* if it is * deferring to us (by returning its version) and we think it is too * old. */ if (vcheck_res \u0026lt; OSSL_DYNAMIC_OLDEST) { /* Fail */ ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_VERSION_INCOMPATIBILITY); return 0; } } /* * First binary copy the ENGINE structure so that we can roll back if the * hand-over fails */ memcpy(\u0026amp;cpy, e, sizeof(ENGINE)); /* * Provide the ERR, \u0026#34;ex_data\u0026#34;, memory, and locking callbacks so the * loaded library uses our state rather than its own. FIXME: As noted in * engine.h, much of this would be simplified if each area of code * provided its own \u0026#34;summary\u0026#34; structure of all related callbacks. It * would also increase opaqueness. */ fns.static_state = ENGINE_get_static_state(); CRYPTO_get_mem_functions(\u0026amp;fns.mem_fns.malloc_fn, \u0026amp;fns.mem_fns.realloc_fn, \u0026amp;fns.mem_fns.free_fn); /* * Now that we\u0026#39;ve loaded the dynamic engine, make sure no \u0026#34;dynamic\u0026#34; * ENGINE elements will show through. */ engine_set_all_null(e); /* Try to bind the ENGINE onto our own ENGINE structure */ /* !!!!Attension, 终于调用成功了，我们的engineX终于被设置好了！ */ if (!ctx-\u0026gt;bind_engine(e, ctx-\u0026gt;engine_id, \u0026amp;fns)) { ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED); /* Copy the original ENGINE structure back */ memcpy(e, \u0026amp;cpy, sizeof(ENGINE)); return 0; } /* Do we try to add this ENGINE to the internal list too? */ /* 把这个engine的副本add进上面engine全局链表，大功告成！*/ if (ctx-\u0026gt;list_add_value \u0026gt; 0) { if (!ENGINE_add(e)) { /* Do we tolerate this or fail? */ if (ctx-\u0026gt;list_add_value \u0026gt; 1) { /* * Fail - NB: By this time, it\u0026#39;s too late to rollback, and * trying to do so allows the bind_engine() code to have * created leaks. We just have to fail where we are, after * the ENGINE has changed. */ ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } /* Tolerate */ ERR_clear_error(); } } return 1; } static int int_load(dynamic_data_ctx *ctx) { int num, loop; /* Unless told not to, try a direct load */ /* * DSO_load去打开ctx-\u0026gt;DYNAMIC_LIBNAME，把egine对应的lib库加载进内存 * 解析符号表和对应地址到上面申请好的ctx-\u0026gt;dynamic_dso结构体中 */ if ((ctx-\u0026gt;dir_load != 2) \u0026amp;\u0026amp; (DSO_load(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, NULL, 0)) != NULL) return 1; /* If we\u0026#39;re not allowed to use \u0026#39;dirs\u0026#39; or we have none, fail */ if (!ctx-\u0026gt;dir_load || (num = sk_OPENSSL_STRING_num(ctx-\u0026gt;dirs)) \u0026lt; 1) return 0; for (loop = 0; loop \u0026lt; num; loop++) { /* 还有链接的dso这里会处理递归的去加载，对应的需要在ctx-\u0026gt;dirs中 */ const char *s = sk_OPENSSL_STRING_value(ctx-\u0026gt;dirs, loop); char *merge = DSO_merge(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, s); if (!merge) return 0; if (DSO_load(ctx-\u0026gt;dynamic_dso, merge, NULL, 0)) { /* Found what we\u0026#39;re looking for */ OPENSSL_free(merge); return 1; } OPENSSL_free(merge); } return 0; }   终于终于终于，找到目标了，这个叫做'dynamic'的engine副本完成了变成engineX的蜕变。\n后续 难怪这么多人喷OpenSSL烂，这复杂的流程，这一个又一个的钩子。不过这一串源码读下来看明白的时候还是有神清气爽的感觉。\n有缘后面会分析密码算法具体挂载，如ENGINE_set_digests。\n我很菜，有错误的地方欢迎指正\n","description":"OpenSSL Engine插件的加载过程源码分析","id":8,"section":"posts","tags":["OpenSSL"],"title":"OpenSSL Engine加载","uri":"https://summersummer3.github.io/posts/openssl_engine/"},{"content":"椭圆曲线基本学习 文章：https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#elliptic-curves\n书籍：密码学原理与实践 第6章\n椭圆曲线方程 $$\n\\left\\lbrace (x, y) \\in \\mathbb{R}^2\\ |\\ y^2 = x^3 + ax + b,\\ 4 a^3 + 27 b^2 \\ne 0 \\right\\rbrace\\ \\cup\\ \\left\\lbrace 0 \\right\\rbrace\n$$\n群与阿贝尔群 ​\t$\\mathbb{G}$ 是一个 群 (Group) 如果该集合上定义了一种运算 $ + $:\n 封闭性: $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ ,则 $a + b \\in \\mathbb{G}$ ; 结合律: $a \\in \\mathbb{G}, b \\in \\mathbb{G}, c \\in \\mathbb{G}$, $ (a + b) + c = a + (b +c)$ ; 存在单位元 $0 \\in \\mathbb{G}$, 使得 $a \\in \\mathbb{G}$，$a + 0 = 0 + a = a$; 每一个元素存在逆元：对于集合内任意元素$a, \\exists b \\in \\mathbb{G}$ 满足 $a + b = 0$，记做$a = -b$  如果该群还满足:\n交换律： $a \\in \\mathbb{G}, b \\in \\mathbb{G}$， $a + b = b + a$  则该群被称为阿贝尔群.\n有限域 $\\mathbb{F}$ 是一个 域(Field) 如果该集合上定义了两种运算 $(\\cdot\\ ;+)$\n 封闭性: $a \\in \\mathbb{F}, b \\in \\mathbb{F}$，则 $a + b \\in \\mathbb{G}; a \\cdot b \\in \\mathbb{G}$ 结合律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$，$ (a + b) + c = a + (b +c);\\ (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ 存在加法单位元 $0 \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a + 0 = 0 + a = a$ 存在乘法单位元 $e \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a \\cdot e = e \\cdot a = a$ 交换律： $a \\in \\mathbb{F}, b \\in \\mathbb{F}$， $a + b = b + a$，$a \\cdot b = b \\cdot a$ 逆元: 对于集合内任意元素$a, \\exists b \\in \\mathbb{F}; \\exists c \\in \\mathbb{F}$ 满足 $a + b = 0; a \\cdot c = e$， 记做$a = -b;\\ a = c^{-1}$，$0^{-1}$无意义 分配律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$；$a \\cdot (b + c) = a \\cdot b + a \\cdot c$  注意：加法逆元定义减法，乘法逆元定义除法\n有限域指的是元素有限的域，属于计算机和密码学的基本数学原理之一\n典型的有限域例子：$\\mathbb{F}_p = {0, 1, \u0026hellip;, p-1}$, $p$为质数，\n定义 (+)：$a + b \\mod p$\n定义 ($\\cdot$)：$a \\cdot b \\mod p$\n计算 $a ^ {-1}$ : 拓展欧几里得算法\n椭圆曲线上的群  曲线上的点的集合组成群 $x$无穷远点为单位元$0$ 点$P$与它的逆$Q$关于直线$x = 0$对称 加法定义：$P + Q + R = 0$，如果这三点是非0点，且在同一条直线上(即一条直线与该曲线相交于三点，无穷远点为0) $=\u0026gt; P + Q = -R$  加法同样需要满足结合律.\n几何意义上的加法 最重要的情况:\n 如果 $P=Q, P + Q$，物理意义是切线, 与曲线交于另一点$R$, 满足：$2P = -R$ 如果$P, Q$直线的第三点刚好为$P\\ or\\ Q$，则也将包含一条切线，计算相同: $P + Q + P = 0\\ =\u0026gt; P + Q = -P$  代数意义上的加法 不同两点相加 $P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n曲线方程：$y^2 = x^3 +ax + b$\n  计算斜率 $k = \\frac{P_y - Q_y}{P_x - Q_x}$\n  曲线方程连立上直线方程 $y = kx + c$\n=\u0026gt; $ 0 = x^3 - k^2x^2 + (a - 2kc)x + b - c^2$\n  铭记三次求根公式之三根之和是二次项系数的相反数: $T_x = k^2 - P_x - Q_x$\n  由于斜率 $k = \\frac{T_y - P_y}{T_x - P_x}$，$T_y = k(T_x - P_x) + P_y$\n  相同两点相加 $P(P_x, P_y)$，求 $T(T_x,T_y) = P + P = 2P$\n和上面基本相同，但计算直线斜率需要根据切线计算\n对曲线方程两边求隐微分:\n$\\mathrm{d}(y^2) = \\mathrm{d}(x^3 +ax + b)$ =\u0026gt; $2y\\mathrm{d}y = (3x^2 + a)\\mathrm{d}x$\n将$P_x, P_y$带入，获得斜率:\n$k = \\frac{\\mathrm{d}y}{\\mathrm{d}x} = \\frac{3P_x^2 + a}{2P_y}$\n所以 $T_x = k^2 - 2P_x$，$T_y = k(T_x - P_x) + P_y$\n标量积 $P(P_x, P_y)$，求 $nP = \\underbrace{P + P + P + \u0026hellip; + P}_{\\text{n times}}$，$n \u0026gt; 2$\n  将 $n$ 用二进制表示；以151为例子，$151_{10} = 10010111_2 = 2^0 + 2^1 + 2^2 + 2^4 + 2^7$\n  $nP = P + 2P + 2^2P + 2^4P + 2^7P$\n  根据上面两项计算规则，分别计算$P, 2P，P + 2P$\n  计算$2^2P = 4P = 2 \\cdot 2P$，对$2P$做相同点相加即可\n  同理计算$2^3P = 8P = 2 \\cdot 4P$，$2^4P = 16P = 2 \\cdot 8P$, 依次类推，每计算到一个二进制中为$1$的阶数， 完成一次两点相加即可\n  曲线上的有限域 取几何曲线上的坐标$(x, y)$，$x, y \\in \\mathbb{F}_p$, $p$ 是一个质数，形成一条离散曲线：\n$$\n\\begin{array}{rcl}\n\\left\\lbrace(x, y) \\in (\\mathbb{F}_p)^2 \\right. \u0026amp; \\left. | \\right. \u0026amp; \\left. y^2 \\equiv x^3 + ax + b \\pmod{p}, \\right.\n\\left. 4a^3 + 27b^2 \\not\\equiv 0 \\pmod{p}\\right\\rbrace\\ \\cup\\ \\left\\lbrace0\\right\\rbrace\n\\end{array}\n$$\n从连续曲线上的加法可以推出有限域上的加法公式：\n$P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n$$\n\\begin{array}{rcl}\nk \u0026amp; = \u0026amp;(P_y - Q_y)(P_x - Q_x)^{-1} \\bmod{p} \\\nT_x \u0026amp; = \u0026amp; (k^2 - P_x - Q_x) \\bmod{p} \\\nT_y \u0026amp; = \u0026amp; [P_y + k(T_x - P_x)] \\bmod{p} \\\n\\end{array}\n$$\n若$P\\ = Q$\n$$\nk = (3 P_x^2 + a)(2 P_y)^{-1} \\bmod{p}\n$$\n曲线上的循环子群 循环子群的阶 对于离散曲线上的任意点$P$, 存在最小的 $n$ 使得 $nP = 0$, 此时 $n$ 称作以 $P$ 为基点的循环子群的阶\n找基点的方法  计算椭圆曲线的阶$N$ (Schoof\u0026rsquo;s algorithm: https://en.wikipedia.org/wiki/Schoof%27s_algorithm) 选择一个阶为$n$的子群。n必须是素数且必须是$N$的因子 计算辅因子 $h = N/n$ 在曲线上选择一个随机的点 $T$ 计算$G = hT$，点乘 如果$G = 0$, 返回4， 否则找到基点 $G$, 子群的阶为 $n$, $h$ 被称为辅因子  原理: 根据拉格朗日定理，$n$ 整除 $N$ 且 $n$ 为质因子，且任意点 $T$ 满足$NT = 0$， 则：$n(hT) = 0$ 恒成立, 那么若$hT\\ \\ne 0$，则 $hT$ 作为基点的阶一定为$n$. ($n$ 一定是素数, 否则不成立)\n曲线上的离散对数问题 对于曲线上的基点 $G$， 已知 $n$ 计算 $P = nG$ 是容易的\n但是已知$P, G$, 计算 $n$ 是很困难的\nECDH \u0026amp; ECDSA ECDH  CA选用共同曲线，并下发相同基点$G$，其阶数为 $n$, 则私钥的取值范围为$d \\in {1, \u0026hellip;, n - 1}$ Alice随机选择私钥$d_A$，计算 Pubkey: $P_A = d_AG$, 通过非安全信道传递给Bob Bob随机选择私钥$d_B$，计算 Pubkey: $P_B = d_BG$，通过非安全信道传递给Alice Alice和Bob分别计算$S = d_AP_b = d_BP_A = d_Ad_BG$， 共享秘密成功  秘密共享成功后可以每次通信时明文传递salt, 每次通过 $key = KDF(salt + S)$，得到具体通信对称秘钥，加密通讯(TLS/SSL)\n通过服务器动态生成的ECDH一般称作ECDHE\nECDSA 定义依然继承上文，$n$ 为 $G$ 作为基点的子群阶数\n定义 $bit(x)$ 为表示 $x$ 需要的比特数；注意计算DSA时，若摘要值的比特数 $bits(digest(plain_test)) \u0026gt; bits(n)$，则需要截取摘要值的低 $bits(n)$ 进行签名.\n符号标记 截取前n-bits函数 ： $trun_{bit(n)}(digest)$\n截取后的摘要值：$z = trun_{bit(n)}(digest(plain_test))$，$digest$ 需要选择安全摘要算法：内部要求SHA-256以上\n私钥：$d$\n公钥：$P = dG$\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x \\mod n$， 若$r = 0$则返回1\n  计算$s = k^{-1}(z + rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算 $u_1 = s^{-1}z \\mod n$ 计算 $u_2 = s^{-1}r \\mod n$ 计算 $T\u0026rsquo; = u_1G\\ +\\ u_2P$  若$T\u0026rsquo;_x = r \\mod n$，验签成功，否则失败\n正确性 我们尝试计算的其实还是$T = kG$，若此时 $z$ 是正确摘要值，则有:\n$k = s^{-1}(z + rd)\\ mod\\ n\\ =\u0026gt;\\ k = s^{-1}z + s^{-1}rd \\mod n$\n带入上式 $T = s^{-1}zG + s^{-1}rdG = u_1G + u_2(dG) = u1G + u_2P$\n所以若 $z$ 发生改变，则此时计算出来的 $T\u0026rsquo;_x\\ \\ne\\ r \\mod n$\n随机数相等下的私钥复原 若每次取出的随机数 $k$ 都相等：\n获取两份签名与摘要：$z_1, (r_1, s_1)$ 和 $z_2, (r_2, s_2)$\n容易得到: $r_1 = r_2 = (kG)_x \\mod n$\n之后通过 $s_1 - s_2$ 计算 $k$：\n$s_1 - s_2 = k^{-1}(z_1 + rd - z_2 - rd) \\mod n$\n$=\u0026gt; k = (z_1 - z_2)(s_1 - s_2)^{-1} \\mod n$\n之后计算 $d$ 就很简单了:\n$ d = r^{-1}(s_1k - z_1) \\mod n$\n通过签名恢复公钥 若已知曲线上 $x = r$ 对应的两点 $R, R\u0026rsquo;$，则可以从签名$(s, r)$中恢复公钥$P$:\n$s = k^{-1}(z + rd) \\mod n$\n$=\u0026gt; skG = (z + rd)G$\n注意 $kG = R$ 或者 $kG = R\u0026rsquo;$, 分别作为备选带入上式，同时$P = dG$:\n$=\u0026gt;\\ sR - zG = r(dG)\\ =\u0026gt; P = r^{-1}(sR - zG)$\nor $=\u0026gt;\\ P = r^{-1}(sR\u0026rsquo; - zG)$\n实现方法 点压缩：增加2bit来标识，一个用来标识 $R_x = r\\mod n$ 或者 $R_x = r$，另一个标识$R_y$是基数还是偶数：\n因为$R, R\u0026rsquo;$关于 $x$ 轴对称，$R_y + R\u0026rsquo;_y = 0 \\mod p$， 所以$R_y ,P\u0026rsquo;_y$为一基一偶，可用一个bit标识\n这样可以达到多用增加一个byte(04标记等)，来达成无需传递公钥即可验签\n相关算法与代码：https://busy.org/@oflyhigh/397bw1\n伪造签名 构造e方法  随机选择 $a, b \\in {1, \u0026hellip; n}$, 计算$T = aG + bP, r = T_x$ 计算 $s = rb^{-1}, e = arb^{-1}$ 若$e$ 为伪造摘要值, 可伪造合法签名 $(r, s)$  正确性:\n$u_1 = s^{-1}e \\mod \\ n$\n$u_2 = s^{-1}r \\mod\\ n$\n将$s, e$带入\n$u_1G + u_2P = (rb^{-1})^{-1}(arb^{-1})G + (rb^{-1})^{-1}rP = (rr^{-1})(bb^{-1})aG + (rr^{-1})bP = aG + bP = T$\n由于$r = T_x \\mod n$，校验通过\n相关算法与代码：https://github.com/GoldSaintEagle/ECDSA-SM2-Signing-Attack\nSM2签名 标记不变，$z = SM3(message)$ 是消息的摘要值（国密要求摘要使用SM3），$d$ 是私钥， $P = dG$是公钥\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x + z \\mod n$， 若$r = 0$则返回1\n  计算$s = (1 + d)^{-1}(k - rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算消息值摘要$z\u0026rsquo; = SM3(message)$ 计算$T\u0026rsquo; = sG + (r + s)P$ 判断$r\\ ?= T\u0026rsquo;_x + z \\mod n$  正确性 首先计算 $k$ :\n$s = (1 + d)^{-1}(k - rd) \\mod n$\n=\u0026gt; $s(1 + d) + rd = k \\mod n$ =\u0026gt; $s + (s + r)d = k \\mod n$\n所以 ：\n$T = kG = sG + (s + r)(dG) = sG + (s + r)P = T'$\n因此可以推导：\n$r = (T_x + z) = (T\u0026rsquo;_x + z) \\mod n$\n所以如果$r = T\u0026rsquo;_x + z\u0026rsquo; \\mod n$， 则 $z\u0026rsquo;$ 验签通过，否则 $z\u0026rsquo;$ 摘要有误\n","description":"椭圆曲线算法入门及ECDSA与SM2算法详解","id":9,"section":"posts","tags":["密码学"],"title":"ECDSA与SM2","uri":"https://summersummer3.github.io/posts/ecdsa%E4%B8%8Esm2/"}]