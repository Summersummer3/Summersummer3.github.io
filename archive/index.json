[{"content":"A useless security engineer/cn:帅华\n工作经历\n字节跳动：移动安全风控工程师，专注反自动化\n华为: 硬件安全与移动安全工程师，TEE/HSM/渗透测试/安全启动 都做过点\n学习经历\n日本筑波大学，社会工学，硕士: 差分隐私研究\n中南大学，计算机科学与技术，本科: 瞎玩儿\n","description":"","id":2,"section":"","tags":null,"title":"About Techsum","uri":"https://summersummer3.github.io/about/"},{"content":"椭圆曲线基本学习 文章：https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#elliptic-curves\n书籍：密码学原理与实践 第6章\n椭圆曲线方程 $$\n\\left\\lbrace (x, y) \\in \\mathbb{R}^2\\ |\\ y^2 = x^3 + ax + b,\\ 4 a^3 + 27 b^2 \\ne 0 \\right\\rbrace\\ \\cup\\ \\left\\lbrace 0 \\right\\rbrace\n$$\n群与阿贝尔群 ​\t$\\mathbb{G}$ 是一个 群 (Group) 如果该集合上定义了一种运算 $ + $:\n 封闭性: $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ ,则 $a + b \\in \\mathbb{G}$ ; 结合律: $a \\in \\mathbb{G}, b \\in \\mathbb{G}, c \\in \\mathbb{G}$, $ (a + b) + c = a + (b +c)$ ; 存在单位元 $0 \\in \\mathbb{G}$, 使得 $a \\in \\mathbb{G}$，$a + 0 = 0 + a = a$; 每一个元素存在逆元：对于集合内任意元素$a, \\exists b \\in \\mathbb{G}$ 满足 $a + b = 0$，记做$a = -b$  如果该群还满足:\n交换律： $a \\in \\mathbb{G}, b \\in \\mathbb{G}$， $a + b = b + a$  则该群被称为阿贝尔群.\n有限域 $\\mathbb{F}$ 是一个 域(Field) 如果该集合上定义了两种运算 $(\\cdot\\ ;+)$\n 封闭性: $a \\in \\mathbb{F}, b \\in \\mathbb{F}$，则 $a + b \\in \\mathbb{G}; a \\cdot b \\in \\mathbb{G}$ 结合律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$，$ (a + b) + c = a + (b +c);\\ (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ 存在加法单位元 $0 \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a + 0 = 0 + a = a$ 存在乘法单位元 $e \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a \\cdot e = e \\cdot a = a$ 交换律： $a \\in \\mathbb{F}, b \\in \\mathbb{F}$， $a + b = b + a$，$a \\cdot b = b \\cdot a$ 逆元: 对于集合内任意元素$a, \\exists b \\in \\mathbb{F}; \\exists c \\in \\mathbb{F}$ 满足 $a + b = 0; a \\cdot c = e$， 记做$a = -b;\\ a = c^{-1}$，$0^{-1}$无意义 分配律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$；$a \\cdot (b + c) = a \\cdot b + a \\cdot c$  注意：加法逆元定义减法，乘法逆元定义除法\n有限域指的是元素有限的域，属于计算机和密码学的基本数学原理之一\n典型的有限域例子：$\\mathbb{F}_p = {0, 1, \u0026hellip;, p-1}$, $p$为质数，\n定义 (+)：$a + b \\mod p$\n定义 ($\\cdot$)：$a \\cdot b \\mod p$\n计算 $a ^ {-1}$ : 拓展欧几里得算法\n椭圆曲线上的群  曲线上的点的集合组成群 $x$无穷远点为单位元$0$ 点$P$与它的逆$Q$关于直线$x = 0$对称 加法定义：$P + Q + R = 0$，如果这三点是非0点，且在同一条直线上(即一条直线与该曲线相交于三点，无穷远点为0) $=\u0026gt; P + Q = -R$  加法同样需要满足结合律.\n几何意义上的加法 最重要的情况:\n 如果 $P=Q, P + Q$，物理意义是切线, 与曲线交于另一点$R$, 满足：$2P = -R$ 如果$P, Q$直线的第三点刚好为$P\\ or\\ Q$，则也将包含一条切线，计算相同: $P + Q + P = 0\\ =\u0026gt; P + Q = -P$  代数意义上的加法 不同两点相加 $P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n曲线方程：$y^2 = x^3 +ax + b$\n  计算斜率 $k = \\frac{P_y - Q_y}{P_x - Q_x}$\n  曲线方程连立上直线方程 $y = kx + c$\n=\u0026gt; $ 0 = x^3 - k^2x^2 + (a - 2kc)x + b - c^2$\n  铭记三次求根公式之三根之和是二次项系数的相反数: $T_x = k^2 - P_x - Q_x$\n  由于斜率 $k = \\frac{T_y - P_y}{T_x - P_x}$，$T_y = k(T_x - P_x) + P_y$\n  相同两点相加 $P(P_x, P_y)$，求 $T(T_x,T_y) = P + P = 2P$\n和上面基本相同，但计算直线斜率需要根据切线计算\n对曲线方程两边求隐微分:\n$\\mathrm{d}(y^2) = \\mathrm{d}(x^3 +ax + b)$ =\u0026gt; $2y\\mathrm{d}y = (3x^2 + a)\\mathrm{d}x$\n将$P_x, P_y$带入，获得斜率:\n$k = \\frac{\\mathrm{d}y}{\\mathrm{d}x} = \\frac{3P_x^2 + a}{2P_y}$\n所以 $T_x = k^2 - 2P_x$，$T_y = k(T_x - P_x) + P_y$\n标量积 $P(P_x, P_y)$，求 $nP = \\underbrace{P + P + P + \u0026hellip; + P}_{\\text{n times}}$，$n \u0026gt; 2$\n  将 $n$ 用二进制表示；以151为例子，$151_{10} = 10010111_2 = 2^0 + 2^1 + 2^2 + 2^4 + 2^7$\n  $nP = P + 2P + 2^2P + 2^4P + 2^7P$\n  根据上面两项计算规则，分别计算$P, 2P，P + 2P$\n  计算$2^2P = 4P = 2 \\cdot 2P$，对$2P$做相同点相加即可\n  同理计算$2^3P = 8P = 2 \\cdot 4P$，$2^4P = 16P = 2 \\cdot 8P$, 依次类推，每计算到一个二进制中为$1$的阶数， 完成一次两点相加即可\n  曲线上的有限域 取几何曲线上的坐标$(x, y)$，$x, y \\in \\mathbb{F}_p$, $p$ 是一个质数，形成一条离散曲线：\n$$\n\\begin{array}{rcl}\n\\left\\lbrace(x, y) \\in (\\mathbb{F}_p)^2 \\right. \u0026amp; \\left. | \\right. \u0026amp; \\left. y^2 \\equiv x^3 + ax + b \\pmod{p}, \\right.\n\\left. 4a^3 + 27b^2 \\not\\equiv 0 \\pmod{p}\\right\\rbrace\\ \\cup\\ \\left\\lbrace0\\right\\rbrace\n\\end{array}\n$$\n从连续曲线上的加法可以推出有限域上的加法公式：\n$P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n$$\n\\begin{array}{rcl}\nk \u0026amp; = \u0026amp;(P_y - Q_y)(P_x - Q_x)^{-1} \\bmod{p} \\\nT_x \u0026amp; = \u0026amp; (k^2 - P_x - Q_x) \\bmod{p} \\\nT_y \u0026amp; = \u0026amp; [P_y + k(T_x - P_x)] \\bmod{p} \\\n\\end{array}\n$$\n若$P\\ = Q$\n$$\nk = (3 P_x^2 + a)(2 P_y)^{-1} \\bmod{p}\n$$\n曲线上的循环子群 循环子群的阶 对于离散曲线上的任意点$P$, 存在最小的 $n$ 使得 $nP = 0$, 此时 $n$ 称作以 $P$ 为基点的循环子群的阶\n找基点的方法  计算椭圆曲线的阶$N$ (Schoof\u0026rsquo;s algorithm: https://en.wikipedia.org/wiki/Schoof%27s_algorithm) 选择一个阶为$n$的子群。n必须是素数且必须是$N$的因子 计算辅因子 $h = N/n$ 在曲线上选择一个随机的点 $T$ 计算$G = hT$，点乘 如果$G = 0$, 返回4， 否则找到基点 $G$, 子群的阶为 $n$, $h$ 被称为辅因子  原理: 根据拉格朗日定理，$n$ 整除 $N$ 且 $n$ 为质因子，且任意点 $T$ 满足$NT = 0$， 则：$n(hT) = 0$ 恒成立, 那么若$hT\\ \\ne 0$，则 $hT$ 作为基点的阶一定为$n$. ($n$ 一定是素数, 否则不成立)\n曲线上的离散对数问题 对于曲线上的基点 $G$， 已知 $n$ 计算 $P = nG$ 是容易的\n但是已知$P, G$, 计算 $n$ 是很困难的\nECDH \u0026amp; ECDSA ECDH  CA选用共同曲线，并下发相同基点$G$，其阶数为 $n$, 则私钥的取值范围为$d \\in {1, \u0026hellip;, n - 1}$ Alice随机选择私钥$d_A$，计算 Pubkey: $P_A = d_AG$, 通过非安全信道传递给Bob Bob随机选择私钥$d_B$，计算 Pubkey: $P_B = d_BG$，通过非安全信道传递给Alice Alice和Bob分别计算$S = d_AP_b = d_BP_A = d_Ad_BG$， 共享秘密成功  秘密共享成功后可以每次通信时明文传递salt, 每次通过 $key = KDF(salt + S)$，得到具体通信对称秘钥，加密通讯(TLS/SSL)\n通过服务器动态生成的ECDH一般称作ECDHE\nECDSA 定义依然继承上文，$n$ 为 $G$ 作为基点的子群阶数\n定义 $bit(x)$ 为表示 $x$ 需要的比特数；注意计算DSA时，若摘要值的比特数 $bits(digest(plain_test)) \u0026gt; bits(n)$，则需要截取摘要值的低 $bits(n)$ 进行签名.\n符号标记 截取前n-bits函数 ： $trun_{bit(n)}(digest)$\n截取后的摘要值：$z = trun_{bit(n)}(digest(plain_test))$，$digest$ 需要选择安全摘要算法：内部要求SHA-256以上\n私钥：$d$\n公钥：$P = dG$\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x \\mod n$， 若$r = 0$则返回1\n  计算$s = k^{-1}(z + rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算 $u_1 = s^{-1}z \\mod n$ 计算 $u_2 = s^{-1}r \\mod n$ 计算 $T\u0026rsquo; = u_1G\\ +\\ u_2P$  若$T\u0026rsquo;_x = r \\mod n$，验签成功，否则失败\n正确性 我们尝试计算的其实还是$T = kG$，若此时 $z$ 是正确摘要值，则有:\n$k = s^{-1}(z + rd)\\ mod\\ n\\ =\u0026gt;\\ k = s^{-1}z + s^{-1}rd \\mod n$\n带入上式 $T = s^{-1}zG + s^{-1}rdG = u_1G + u_2(dG) = u1G + u_2P$\n所以若 $z$ 发生改变，则此时计算出来的 $T\u0026rsquo;_x\\ \\ne\\ r \\mod n$\n随机数相等下的私钥复原 若每次取出的随机数 $k$ 都相等：\n获取两份签名与摘要：$z_1, (r_1, s_1)$ 和 $z_2, (r_2, s_2)$\n容易得到: $r_1 = r_2 = (kG)_x \\mod n$\n之后通过 $s_1 - s_2$ 计算 $k$：\n$s_1 - s_2 = k^{-1}(z_1 + rd - z_2 - rd) \\mod n$\n$=\u0026gt; k = (z_1 - z_2)(s_1 - s_2)^{-1} \\mod n$\n之后计算 $d$ 就很简单了:\n$ d = r^{-1}(s_1k - z_1) \\mod n$\n通过签名恢复公钥 若已知曲线上 $x = r$ 对应的两点 $R, R\u0026rsquo;$，则可以从签名$(s, r)$中恢复公钥$P$:\n$s = k^{-1}(z + rd) \\mod n$\n$=\u0026gt; skG = (z + rd)G$\n注意 $kG = R$ 或者 $kG = R\u0026rsquo;$, 分别作为备选带入上式，同时$P = dG$:\n$=\u0026gt;\\ sR - zG = r(dG)\\ =\u0026gt; P = r^{-1}(sR - zG)$\nor $=\u0026gt;\\ P = r^{-1}(sR\u0026rsquo; - zG)$\n实现方法 点压缩：增加2bit来标识，一个用来标识 $R_x = r\\mod n$ 或者 $R_x = r$，另一个标识$R_y$是基数还是偶数：\n因为$R, R\u0026rsquo;$关于 $x$ 轴对称，$R_y + R\u0026rsquo;_y = 0 \\mod p$， 所以$R_y ,P\u0026rsquo;_y$为一基一偶，可用一个bit标识\n这样可以达到多用增加一个byte(04标记等)，来达成无需传递公钥即可验签\n相关算法与代码：https://busy.org/@oflyhigh/397bw1\n伪造签名 构造e方法  随机选择 $a, b \\in {1, \u0026hellip; n}$, 计算$T = aG + bP, r = T_x$ 计算 $s = rb^{-1}, e = arb^{-1}$ 若$e$ 为伪造摘要值, 可伪造合法签名 $(r, s)$  正确性:\n$u_1 = s^{-1}e \\mod \\ n$\n$u_2 = s^{-1}r \\mod\\ n$\n将$s, e$带入\n$u_1G + u_2P = (rb^{-1})^{-1}(arb^{-1})G + (rb^{-1})^{-1}rP = (rr^{-1})(bb^{-1})aG + (rr^{-1})bP = aG + bP = T$\n由于$r = T_x \\mod n$，校验通过\n相关算法与代码：https://github.com/GoldSaintEagle/ECDSA-SM2-Signing-Attack\nSM2签名 标记不变，$z = SM3(message)$ 是消息的摘要值（国密要求摘要使用SM3），$d$ 是私钥， $P = dG$是公钥\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x + z \\mod n$， 若$r = 0$则返回1\n  计算$s = (1 + d)^{-1}(k - rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算消息值摘要$z\u0026rsquo; = SM3(message)$ 计算$T\u0026rsquo; = sG + (r + s)P$ 判断$r\\ ?= T\u0026rsquo;_x + z \\mod n$  正确性 首先计算 $k$ :\n$s = (1 + d)^{-1}(k - rd) \\mod n$\n=\u0026gt; $s(1 + d) + rd = k \\mod n$ =\u0026gt; $s + (s + r)d = k \\mod n$\n所以 ：\n$T = kG = sG + (s + r)(dG) = sG + (s + r)P = T'$\n因此可以推导：\n$r = (T_x + z) = (T\u0026rsquo;_x + z) \\mod n$\n所以如果$r = T\u0026rsquo;_x + z\u0026rsquo; \\mod n$， 则 $z\u0026rsquo;$ 验签通过，否则 $z\u0026rsquo;$ 摘要有误\n","description":"椭圆曲线算法入门及ECDSA与SM2算法详解","id":3,"section":"posts","tags":["密码学"],"title":"ECDSA与SM2","uri":"https://summersummer3.github.io/posts/ecdsa%E4%B8%8Esm2/"},{"content":"背景 由于很多headless浏览器的webgl信息比较明显，如果源站尝试采集webgl参数会暴露自动化工具的特征，所以黑产攻击中需要去欺骗webgl的信息上报。\n目前在github上可以找到一个spoof webgl的项目，star数并不多，但其思路应该是比较主流的hook webgl相关接口的方式。本文主要对该工具的使用和源码进行分析。\n这份代码并不完美，甚至能找到几处bug，但不妨碍我们学习其思想；github地址：https://github.com/siejqa/spoofHeadless\n背景知识简单介绍 Webgl和参数采集 简单来说webgl就是浏览器给前端js代码调用的渲染绘图API，该API可以在在html canvas元素中使用，可以调用到硬件进行加速，所以webgl的参数通常与硬件强相关。更具体的介绍和教程可以参考：https://www.w3cschool.cn/webgl/i4gf1oh1.html\n具体采集webgl的参数时，需要首先先获取canvas下的webgl Context，使用getContext接口。而采集具体参数是使用getParameter函数完成，getParameter接受一个整数，每个整数对应一个属性；以获取GPU型号为例：\n1 2 3 4 5  // 获取webgl context var gl = document.createElement(\u0026#34;canvas\u0026#34;).getContext(\u0026#34;webgl\u0026#34;) // 采集GPU render：编号为37446 gl.getExtension(\u0026#34;WEBGL_debug_renderer_info\u0026#34;)[\u0026#34;UNMASKED_RENDERER_WEBGL\u0026#34;] gl.getParameter(37446)   完整的getParameter常量表可以参考：https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\nWebdriver webdriver本质上是浏览器根据w3c实现的一套操作浏览器的接口，而每个浏览器都有一个特定的 WebDriver 实现，如chrome webdriver：https://chromedriver.chromium.org/downloads\n而目前比较广义的定义（或者说黑产使用的方式），通常是指puppeteer/selenium这类，集成了多种浏览器，并提供高级api供上层应用调用的自动化工具；可以直接使用python(selenium)和nodejs(puppeteer)来编写脚本，完成webdriver的控制，从而完成浏览器上的自动化操作。相关资料可以自行搜索学习。\nSpoofWebGL使用方法 此处介绍如何在selenium使用SpoofWebGL工具，当然该工具简单改造后可以在所有的webdriver上使用。\n 将项目clone下来之后，使用可以看到src文件夹下有两个文件，其中manifest.json是extension的配置文件，injected是源码。   之后用zip命令将src文件夹打包：zip -rj extension.zip src/ 将zip后缀名改成.crx(chrome extension的后缀名) ：mv extension.zip extension.crx 编写webdriver脚本如下（注意要先安装好selenium和chrome webdriver），去观察我们的webgl参数读取情况（注意原项目中使用的是firefox的webdriver，所以脚本要做修改）：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver opt = webdriver.ChromeOptions() extension_path = \u0026#39;./extension.crx\u0026#39; opt.add_extension(extension_path) driver = webdriver.Chrome(options=opt) # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   可以看到这个vendor和render已经不太正常了；\n 作为对比，注释掉options直接启动，会显示本机的真实GPU：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver # opt = webdriver.ChromeOptions() #  # extension_path = \u0026#39;./extension.crx\u0026#39; # opt.add_extension(extension_path) driver = webdriver.Chrome() # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   注：此处是使用浏览器界面模式打开的，实际上如果是启动headless模式，该renderer会和本机的有差别，这也是为什么要使用spoof webgl的原因\n源码分析 总结来说，该extension是将webgl相关的接口全部进行了hook，本质技术难度上并不大，且可以很容易进行定制化。下面开始对hook方法进行分析\nwebdriver相关绕过 开始的第一部分跟webgl检测关系不大，主要是用defineProperty方法对navigator下一些字段进行了hook，绕过webdriver相关的一些检测；主要是设置上浏览器语言，以及将Navigator.webdriver置为false：\n1 2 3 4 5 6 7 8 9 10  Object.defineProperty(navigator, \u0026#39;languages\u0026#39;, { get: function () { var availableLanguages = Array(\u0026#39;en\u0026#39;, \u0026#39;pl\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;ru\u0026#39;, \u0026#39;fr\u0026#39;, \u0026#39;fr-fr\u0026#39;, \u0026#39;lb\u0026#39;, \u0026#39;no\u0026#39;) return [\u0026#39;en-US\u0026#39;, get_random_item(availableLanguages)]; }, }); // fake webdriver property (headless has it as true) Object.defineProperty(navigator, \u0026#39;webdriver\u0026#39;, { get: () =\u0026gt; false, });   WebGL Hook 根据上文中webgl调用示例可知调用webgl接口采集参数主要分为三步：\n 使用getContext获取webgl Context 使用context.getExtension获取webgl拓展的编号 使用context.getParameter获取具体参数的值  对应步骤我们查看该脚本的hook方法：\nHTMLCanvasElement.getContext Hook 要hook该方法，我们需要先定义一个类，如下：\n1 2 3 4 5  function WebGLRenderingContext(canvas) { this.canvas = canvas; this.drawingBufferWidth = canvas.width; this.drawingBufferHeight = canvas.height; };   之后将WebGLRenderingContext中的基本属性和方法进行初始化，即对Object.prototype.attribute进行赋值一个空函数。注意，基础属性本质上都是一些编号，如上文中的例子一样，他是用来传入getParameter做入参的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 原webgl Context中的基本方法集合 var functions = [ \u0026#39;viewport\u0026#39;, \u0026#39;vertexAttribPointer\u0026#39;, \u0026#39;vertexAttrib4fv\u0026#39;, \u0026#39;vertexAttrib4f\u0026#39;, \u0026#39;vertexAttrib3fv\u0026#39;, ... ] // 原webgl Context中的基本属性集合，这里挑选一些经常被收集的作为例子 var enumerates = { ... \u0026#39;VERSION\u0026#39;: 7938, ... \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446, ... \u0026#39;DEPTH_BITS\u0026#39;: 3414, \u0026#39;GREEN_BITS\u0026#39;: 3411, \u0026#39;BLUE_BITS\u0026#39;: 3412, ... \u0026#39;STENCIL_BITS\u0026#39;: 3415, ... \u0026#39;MAX_VERTEX_UNIFORM_VECTORS\u0026#39;: 36347, \u0026#39;MAX_VERTEX_TEXTURE_IMAGE_UNITS\u0026#39;: 35660, \u0026#39;MAX_VERTEX_ATTRIBS\u0026#39;: 34921, \u0026#39;MAX_VARYING_VECTORS\u0026#39;: 36348, \u0026#39;MAX_TEXTURE_SIZE\u0026#39;: 3379, \u0026#39;MAX_TEXTURE_IMAGE_UNITS\u0026#39;: 34930, \u0026#39;MAX_RENDERBUFFER_SIZE\u0026#39;: 34024, \u0026#39;MAX_FRAGMENT_UNIFORM_VECTORS\u0026#39;: 36349, \u0026#39;MAX_CUBE_MAP_TEXTURE_SIZE\u0026#39;: 34076, \u0026#39;MAX_COMBINED_TEXTURE_IMAGE_UNITS\u0026#39;: 35661, ... }; // 将原本的函数全部替换成空函数 functions.forEach(function (func) { WebGLRenderingContext.prototype[func] = function () { return {}; }; }); Object.keys(enumerates).forEach(function (key) { WebGLRenderingContext.prototype[key] = enumerates[key]; });   实际上原脚本之后马上对context.getExtension完成了赋值，那此处其实顺序不影响执行结果，所以我们留在下一节描述。\n进入hook的代码，实际上document.createElement(\u0026ldquo;canvas\u0026rdquo;).getContext(\u0026quot;webgl\u0026quot;)调用到的是HTMLCanvasElement.getContext方法，所以对该方法进行Hook：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  try { const getContext = HTMLCanvasElement.prototype.getContext; // 利用重定义HTMLCanvasElement.prototype.getContext完成Hook，是常见的hook方法  HTMLCanvasElement.prototype.getContext = function () { // 获取第一个入参，通常为\u0026#34;webgl\u0026#34;，\u0026#39;webgl-experimental\u0026#39;等  var name = arguments[0]; console.log(\u0026#34;HTMLCanvasElement app requested extension: \u0026#34; + name); console.log(JSON.stringify(arguments, null, 4)); if (name == \u0026#39;webgl\u0026#39; || name == \u0026#39;webgl-experimental\u0026#39; || name == \u0026#39;experimental-webgl\u0026#39; || name == \u0026#39;moz-webgl\u0026#39;) { // 最终返回了上文中自定义的类WebGLRenderingContext，完成hook  var y = new WebGLRenderingContext(this); console.log(\u0026#34;WEBGL \u0026#34; + y); console.log(JSON.stringify(y, null, 4)); return y; } // 其他的webgl类型不支持，返回原始数据  if (name == \u0026#39;webgl2\u0026#39; || name == \u0026#39;experimental-webgl2\u0026#39; || name == \u0026#39;fake-webgl\u0026#39;) { console.log(\u0026#34;WEBGL2\u0026#34;) return null; } var ext = getContext.apply(this, arguments); console.log(\u0026#34;HTMLCanvasElement extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(ext); return ext; } } catch (e) { }   context.getExtension定义 实际上很简单，只需要get对应属性时返回指定编号即可，此处以上文中的\u0026quot;WEBGL_debug_renderer_info\u0026quot;为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var extensions = { // ratified  ... \u0026#39;WEBGL_debug_renderer_info\u0026#39;: { \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446 }, ... } WebGLRenderingContext.prototype.getExtension = function (ext) { console.log(\u0026#34;WebGLRenderingContext.getExtension\u0026#34; + ext); return extensions[ext]; };   注意此处有一些特例是\u0026quot;WEBGL_lose_context\u0026quot;和\n\u0026ldquo;WEBGL_draw_buffers\u0026rdquo;, 他们的属性内部包含方法，需要定义一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function loseContext () { } function restoreContext () { } function drawBuffersWEBGL () { } var extensions = { // ratified  ... \u0026#39;WEBGL_lose_context\u0026#39;: { loseContext, restoreContext }, ... \u0026#39;WEBGL_draw_buffers\u0026#39;: { \u0026#39;MAX_DRAW_BUFFERS_WEBGL\u0026#39;: 34852, \u0026#39;MAX_COLOR_ATTACHMENTS_WEBGL\u0026#39;: 36063, ... drawBuffersWEBGL }, }   context.getParameter 定义，完成取值的Hook 代码可以拆解如下：\n 定义部分，拿到getParameter的参数：  1 2 3 4 5 6 7  try { const getParameter = WebGLRenderingContext.prototype.getParameter; WebGLRenderingContext.prototype.getParameter = function () { var name = arguments[0]; console.log(\u0026#34;WebGLRenderingContext - getParameter: \u0026#34; + name); ... } catch (a) { }    Hook UNMASKED_VENDOR_WEBGL 和UNMASKED_RENDERER_WEBGL 参数，从一个备选列表中随机返回一个vendor/renderer，可以很好的防止收集信息结果过度集中，也可以很方便的进行拓展：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function get_random_item(list) { return list[Math.floor((Math.random() * list.length))]; } WebGLRenderingContext.prototype.getParameter = function () { ... // UNMASKED_VENDOR_WEBGL  if (name == 37445) { var options = [\u0026#39;Intel Open Source Technology Center\u0026#39;, \u0026#39;X.Org\u0026#39;, \u0026#39;Vendor Google Inc.\u0026#39;]; return get_random_item(options); } else if (name == 37446) { // UNMASKED_RENDERER_WEBGL  var options = [\u0026#39;Mesa DRI Intel(R) Ivybridge Mobile\u0026#39;, \u0026#39;AMD KAVERI (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Renderer Google SwiftShader\u0026#39;, \u0026#39;AMD ARUBA (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Mesa DRI Intel(R) HD Graphics 630 (Kaby Lake GT2)\u0026#39;, \u0026#39;Gallium 0.4 on AMD KAVERI (DRM 2.43.0 / 4.4.0-83-generic, LLVM 3.8.0)\u0026#39;]; return get_random_item(options); } ... }    Hook 一些基础属性, 如RENDERER / VENDOR / SHADING_LANGUAGE_VERSION /  VERSION\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 7936) { // RENDERER // VENDOR  return \u0026#39;Mozilla\u0026#39;; } else if (name == 35724) { // SHADING_LANGUAGE_VERSION  return \u0026#39;WebGL GLSL ES 1.0\u0026#39;; } else if (name == 7937 || name == 7938) { // VERSION  return \u0026#39;WebGL 1.0\u0026#39;; } ... }    Hook ALIASED_LINE_WIDTH_RANGE / ALIASED_POINT_SIZE_RANGE, 会返回一个float array，size为2；这里代码有点小问题，不影响功能，name == 7937是VERSION，不过在上面已经判断过了，不会进到这个分支：  1 2 3 4 5 6 7 8 9  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 33901 || name == 33902) { // ALIASED_LINE_WIDTH_RANGE // ALIASED_POINT_SIZE_RANGE  var option = new Float32Array([1, 8192]); return option; } ... }    针对一些webgl位宽信息进行Hook，返回随机值[2, 4, 8, 16]中1个，具体参数见注释：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3413 || name == 3412 || name == 3411 || name == 3410 || name == 34852) { // ALPHA_BITS // BLUE_BITS // GREEN_BITS // RED_BITS // MAX_DRAW_BUFFERS_WEBGL  return get_random_item([2, 4, 8, 16]); } ... }    针对一些位宽信息进行Hook，返回固定值，参数见注释  1 2 3 4 5 6 7 8 9 10 11  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3415) // STENCIL_BITS  return 0; } else if (name == 3414) { // DEPTH_BITS  return 24; } ... }    接下来是该脚本bug的地方，Hook出现问题，如果使用该脚本不加修改，很容易通过此bug识别；原因主要在于以下hook的三个参数值理论上是返回一个整数，但不知为何作者这里使用了get_random_items, 但没有给第二个参数，所以n会为undefined，导致固定返回一个Array：undefined；修复也很简单，换成get_random_item即可。源代码如下：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function get_random_items(list, n) { var result = new Array(n), len = list.length, taken = new Array(len); if (n \u0026gt; len) n = len while (n--) { var x = Math.floor(Math.random() * len); result[n] = list[x in taken ? taken[x] : x]; // 比较巧妙的取随机多个值的方式，留一个array标记如果下次再取到其下标会从目前未取成的最后一个元素  taken[x] = --len in taken ? taken[len] : len; } return result; } WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 34047 || name == 34921) { // MAX_TEXTURE_MAX_ANISOTROPY_EXT // MAX_VERTEX_ATTRIBS  return get_random_items([2, 4, 8, 16]); } else if (name == 35661) { // MAX_COMBINED_TEXTURE_IMAGE_UNITS  return get_random_items([128, 192, 256]); } ... }    对一些其他的MAX相关属性进行Hook，返回随机值，具体属性见注释  1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... } else if (name == 34076 || name == 34024 || name == 3379) { // MAX_CUBE_MAP_TEXTURE_SIZE // MAX_RENDERBUFFER_SIZE  return get_random_item([16384, 32768]) ; } else if (name == 36349 || name == 36347) { // MAX_FRAGMENT_UNIFORM_VECTORS // MAX_VERTEX_UNIFORM_VECTORS  return get_random_item([4096, 8192]); } else if (name == 34930 || name == 36348 || name == 35660) { // MAX_TEXTURE_IMAGE_UNITS // MAX_VARYING_VECTORS // MAX_VERTEX_TEXTURE_IMAGE_UNITS  return get_random_item([16, 32, 64]); } ... }    对MAX_VIEWPORT_DIMS进行Hook，会返回一个长度为2且两个值相等的Int32Array，同样此处随机取值：  1 2 3 4 5 6 7 8 9 10  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3386) { // MAX_VIEWPORT_DIMS  var value = get_random_item([8192, 16384, 32768]) var options = new Int32Array([value, value]); return options; } ... }    最后，剩下的参数统一随机从[0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]随机取值返回(此处还有个冗余分支STENCIL_BITS，上面已经判断过了，属于冗余代码)  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else { console.log(\u0026#34;Retuning random value for: \u0026#34; + name); return get_random_item([0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]); } ... }    最后的迷惑操作：理论上此处已经涵盖了所有的case返回，但是最后还多了个跑不到的分支：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... var ext = getParameter.apply(this, arguments); console.log(\u0026#34;WebGLRenderingContext extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(JSON.stringify(ext, null, 4)); return ext; }   说实话我猜测此处他是想模拟一些参数，他们在getParameter之前必须先调用getExtension方法后才可以获取，但是此处加在最后属实看不懂，个人理解应该放在这个大if\u0026hellip;else\u0026hellip;前面；有时间我可以好好修复一下这个项目😂😂\n其他的一些被Hook的方法  getSupportedExtension：比较简单，随机从extensions中间选择随机个keys并返回，出现异常则将所有的keys都返回。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // extensions的keys可以参见getExtension部分 const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions; WebGLRenderingContext.prototype.getSupportedExtensions = function () { try { console.log(\u0026#34;WebGLRenderingContext.getSupportedExtensions\u0026#34;) var availableExtensions = Object.keys(extensions); console.log(availableExtensions); var itemsToGet = Math.floor(Math.random() * (availableExtensions.length - 6) + 5); console.log(itemsToGet); var selectedExtensions = get_random_items(availableExtensions, itemsToGet); console.log(selectedExtensions); return selectedExtensions; } catch (a) { console.log(a) return Object.keys(extensions); } }    针对一些headless浏览器有可能会出现canvas的一些属性异常（broken会为0），如canvas的width和height，以及offset，进行Hook，还是使用defineProperty重写get方法对属性进行hook：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // in case of broken image return random height/width var size = 0; [\u0026#39;height\u0026#39;, \u0026#39;width\u0026#39;].forEach(property =\u0026gt; { const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, property); Object.defineProperty(HTMLImageElement.prototype, property, { imageDescriptor, get: function () { // 如果canvas破损，则返回随机size  if (this.complete \u0026amp;\u0026amp; this.naturalHeight == 0) { if (!size) { // 返回随机的长/宽  size = Math.floor(Math.random() * (30 - 10 + 1)) + 10; } return size; } // 未破损则返回正常size  return imageDescriptor.get.apply(this); }, }); }); // hairline feature (headless can\u0026#39;t render it normally) const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;); Object.defineProperty(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;, { ...imageDescriptor, get: function () { if (this.id == \u0026#39;modernizr\u0026#39;) { return 1; } return imageDescriptor.get.apply(this); }, });   插件执行 方法比较简单，将整个大函数作为字符串，最后在html document中新建一个script tag，script.textContent赋值为字符串即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  var scriptCode = \u0026#39;(\u0026#39; + function () { ... function WebGLRenderingContext(canvas) { ... }; ... WebGLRenderingContext.prototype.getExtension = function (ext) { ... }; ... WebGLRenderingContext.prototype.getParameter = function () { ... } ... } + \u0026#39;)();\u0026#39;; // 转成字符串，可直接执行  // 新建script节点插入document中，即自动执行 var script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = scriptCode; (document.head || document.documentElement).appendChild(script); // 最后move掉代码即可 script.remove();   ","description":"SpoofWebGL","id":4,"section":"posts","tags":["黑产工具"],"title":"SpoofWebGL","uri":"https://summersummer3.github.io/posts/spoofwebgl/"}]