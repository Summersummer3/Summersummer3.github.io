[{"content":"A useless security engineer/cn:帅华\n工作经历\n字节跳动：移动安全风控工程师，专注反自动化\n华为: 硬件安全与移动安全工程师，TEE/HSM/渗透测试/安全启动 都做过点\n学习经历\n日本筑波大学，社会工学，硕士: 差分隐私研究\n中南大学，计算机科学与技术，本科: 瞎玩儿\n","description":"","id":2,"section":"","tags":null,"title":"About Techsum","uri":"https://summersummer3.github.io/about/"},{"content":"背景 由于很多headless浏览器的webgl信息比较明显，如果源站尝试采集webgl参数会暴露自动化工具的特征，所以黑产攻击中需要去欺骗webgl的信息上报。\n目前在github上可以找到一个spoof webgl的项目，star数并不多，但其思路应该是比较主流的hook webgl相关接口的方式。本文主要对该工具的使用和源码进行分析。\n这份代码并不完美，甚至能找到几处bug，但不妨碍我们学习其思想；github地址：https://github.com/siejqa/spoofHeadless\n背景知识简单介绍 Webgl和参数采集 简单来说webgl就是浏览器给前端js代码调用的渲染绘图API，该API可以在在html canvas元素中使用，可以调用到硬件进行加速，所以webgl的参数通常与硬件强相关。更具体的介绍和教程可以参考：https://www.w3cschool.cn/webgl/i4gf1oh1.html\n具体采集webgl的参数时，需要首先先获取canvas下的webgl Context，使用getContext接口。而采集具体参数是使用getParameter函数完成，getParameter接受一个整数，每个整数对应一个属性；以获取GPU型号为例：\n1 2 3 4 5  // 获取webgl context var gl = document.createElement(\u0026#34;canvas\u0026#34;).getContext(\u0026#34;webgl\u0026#34;) // 采集GPU render：编号为37446 gl.getExtension(\u0026#34;WEBGL_debug_renderer_info\u0026#34;)[\u0026#34;UNMASKED_RENDERER_WEBGL\u0026#34;] gl.getParameter(37446)   完整的getParameter常量表可以参考：https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\nWebdriver webdriver本质上是浏览器根据w3c实现的一套操作浏览器的接口，而每个浏览器都有一个特定的 WebDriver 实现，如chrome webdriver：https://chromedriver.chromium.org/downloads\n而目前比较广义的定义（或者说黑产使用的方式），通常是指puppeteer/selenium这类，集成了多种浏览器，并提供高级api供上层应用调用的自动化工具；可以直接使用python(selenium)和nodejs(puppeteer)来编写脚本，完成webdriver的控制，从而完成浏览器上的自动化操作。相关资料可以自行搜索学习。\nSpoofWebGL使用方法 此处介绍如何在selenium使用SpoofWebGL工具，当然该工具简单改造后可以在所有的webdriver上使用。\n 将项目clone下来之后，使用可以看到src文件夹下有两个文件，其中manifest.json是extension的配置文件，injected是源码。   之后用zip命令将src文件夹打包：zip -rj extension.zip src/ 将zip后缀名改成.crx(chrome extension的后缀名) ：mv extension.zip extension.crx 编写webdriver脚本如下（注意要先安装好selenium和chrome webdriver），去观察我们的webgl参数读取情况（注意原项目中使用的是firefox的webdriver，所以脚本要做修改）：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver opt = webdriver.ChromeOptions() extension_path = \u0026#39;./extension.crx\u0026#39; opt.add_extension(extension_path) driver = webdriver.Chrome(options=opt) # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   可以看到这个vendor和render已经不太正常了；\n 作为对比，注释掉options直接启动，会显示本机的真实GPU：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver # opt = webdriver.ChromeOptions() #  # extension_path = \u0026#39;./extension.crx\u0026#39; # opt.add_extension(extension_path) driver = webdriver.Chrome() # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   注：此处是使用浏览器界面模式打开的，实际上如果是启动headless模式，该renderer会和本机的有差别，这也是为什么要使用spoof webgl的原因\n源码分析 总结来说，该extension是将webgl相关的接口全部进行了hook，本质技术难度上并不大，且可以很容易进行定制化。下面开始对hook方法进行分析\nwebdriver相关绕过 开始的第一部分跟webgl检测关系不大，主要是用defineProperty方法对navigator下一些字段进行了hook，绕过webdriver相关的一些检测；主要是设置上浏览器语言，以及将Navigator.webdriver置为false：\n1 2 3 4 5 6 7 8 9 10  Object.defineProperty(navigator, \u0026#39;languages\u0026#39;, { get: function () { var availableLanguages = Array(\u0026#39;en\u0026#39;, \u0026#39;pl\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;ru\u0026#39;, \u0026#39;fr\u0026#39;, \u0026#39;fr-fr\u0026#39;, \u0026#39;lb\u0026#39;, \u0026#39;no\u0026#39;) return [\u0026#39;en-US\u0026#39;, get_random_item(availableLanguages)]; }, }); // fake webdriver property (headless has it as true) Object.defineProperty(navigator, \u0026#39;webdriver\u0026#39;, { get: () =\u0026gt; false, });   WebGL Hook 根据上文中webgl调用示例可知调用webgl接口采集参数主要分为三步：\n 使用getContext获取webgl Context 使用context.getExtension获取webgl拓展的编号 使用context.getParameter获取具体参数的值  对应步骤我们查看该脚本的hook方法：\nHTMLCanvasElement.getContext Hook 要hook该方法，我们需要先定义一个类，如下：\n1 2 3 4 5  function WebGLRenderingContext(canvas) { this.canvas = canvas; this.drawingBufferWidth = canvas.width; this.drawingBufferHeight = canvas.height; };   之后将WebGLRenderingContext中的基本属性和方法进行初始化，即对Object.prototype.attribute进行赋值一个空函数。注意，基础属性本质上都是一些编号，如上文中的例子一样，他是用来传入getParameter做入参的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 原webgl Context中的基本方法集合 var functions = [ \u0026#39;viewport\u0026#39;, \u0026#39;vertexAttribPointer\u0026#39;, \u0026#39;vertexAttrib4fv\u0026#39;, \u0026#39;vertexAttrib4f\u0026#39;, \u0026#39;vertexAttrib3fv\u0026#39;, ... ] // 原webgl Context中的基本属性集合，这里挑选一些经常被收集的作为例子 var enumerates = { ... \u0026#39;VERSION\u0026#39;: 7938, ... \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446, ... \u0026#39;DEPTH_BITS\u0026#39;: 3414, \u0026#39;GREEN_BITS\u0026#39;: 3411, \u0026#39;BLUE_BITS\u0026#39;: 3412, ... \u0026#39;STENCIL_BITS\u0026#39;: 3415, ... \u0026#39;MAX_VERTEX_UNIFORM_VECTORS\u0026#39;: 36347, \u0026#39;MAX_VERTEX_TEXTURE_IMAGE_UNITS\u0026#39;: 35660, \u0026#39;MAX_VERTEX_ATTRIBS\u0026#39;: 34921, \u0026#39;MAX_VARYING_VECTORS\u0026#39;: 36348, \u0026#39;MAX_TEXTURE_SIZE\u0026#39;: 3379, \u0026#39;MAX_TEXTURE_IMAGE_UNITS\u0026#39;: 34930, \u0026#39;MAX_RENDERBUFFER_SIZE\u0026#39;: 34024, \u0026#39;MAX_FRAGMENT_UNIFORM_VECTORS\u0026#39;: 36349, \u0026#39;MAX_CUBE_MAP_TEXTURE_SIZE\u0026#39;: 34076, \u0026#39;MAX_COMBINED_TEXTURE_IMAGE_UNITS\u0026#39;: 35661, ... }; // 将原本的函数全部替换成空函数 functions.forEach(function (func) { WebGLRenderingContext.prototype[func] = function () { return {}; }; }); Object.keys(enumerates).forEach(function (key) { WebGLRenderingContext.prototype[key] = enumerates[key]; });   实际上原脚本之后马上对context.getExtension完成了赋值，那此处其实顺序不影响执行结果，所以我们留在下一节描述。\n进入hook的代码，实际上document.createElement(\u0026ldquo;canvas\u0026rdquo;).getContext(\u0026quot;webgl\u0026quot;)调用到的是HTMLCanvasElement.getContext方法，所以对该方法进行Hook：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  try { const getContext = HTMLCanvasElement.prototype.getContext; // 利用重定义HTMLCanvasElement.prototype.getContext完成Hook，是常见的hook方法  HTMLCanvasElement.prototype.getContext = function () { // 获取第一个入参，通常为\u0026#34;webgl\u0026#34;，\u0026#39;webgl-experimental\u0026#39;等  var name = arguments[0]; console.log(\u0026#34;HTMLCanvasElement app requested extension: \u0026#34; + name); console.log(JSON.stringify(arguments, null, 4)); if (name == \u0026#39;webgl\u0026#39; || name == \u0026#39;webgl-experimental\u0026#39; || name == \u0026#39;experimental-webgl\u0026#39; || name == \u0026#39;moz-webgl\u0026#39;) { // 最终返回了上文中自定义的类WebGLRenderingContext，完成hook  var y = new WebGLRenderingContext(this); console.log(\u0026#34;WEBGL \u0026#34; + y); console.log(JSON.stringify(y, null, 4)); return y; } // 其他的webgl类型不支持，返回原始数据  if (name == \u0026#39;webgl2\u0026#39; || name == \u0026#39;experimental-webgl2\u0026#39; || name == \u0026#39;fake-webgl\u0026#39;) { console.log(\u0026#34;WEBGL2\u0026#34;) return null; } var ext = getContext.apply(this, arguments); console.log(\u0026#34;HTMLCanvasElement extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(ext); return ext; } } catch (e) { }   context.getExtension定义 实际上很简单，只需要get对应属性时返回指定编号即可，此处以上文中的\u0026quot;WEBGL_debug_renderer_info\u0026quot;为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var extensions = { // ratified  ... \u0026#39;WEBGL_debug_renderer_info\u0026#39;: { \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446 }, ... } WebGLRenderingContext.prototype.getExtension = function (ext) { console.log(\u0026#34;WebGLRenderingContext.getExtension\u0026#34; + ext); return extensions[ext]; };   注意此处有一些特例是\u0026quot;WEBGL_lose_context\u0026quot;和\n\u0026ldquo;WEBGL_draw_buffers\u0026rdquo;, 他们的属性内部包含方法，需要定义一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function loseContext () { } function restoreContext () { } function drawBuffersWEBGL () { } var extensions = { // ratified  ... \u0026#39;WEBGL_lose_context\u0026#39;: { loseContext, restoreContext }, ... \u0026#39;WEBGL_draw_buffers\u0026#39;: { \u0026#39;MAX_DRAW_BUFFERS_WEBGL\u0026#39;: 34852, \u0026#39;MAX_COLOR_ATTACHMENTS_WEBGL\u0026#39;: 36063, ... drawBuffersWEBGL }, }   context.getParameter 定义，完成取值的Hook 代码可以拆解如下：\n 定义部分，拿到getParameter的参数：  1 2 3 4 5 6 7  try { const getParameter = WebGLRenderingContext.prototype.getParameter; WebGLRenderingContext.prototype.getParameter = function () { var name = arguments[0]; console.log(\u0026#34;WebGLRenderingContext - getParameter: \u0026#34; + name); ... } catch (a) { }    Hook UNMASKED_VENDOR_WEBGL 和UNMASKED_RENDERER_WEBGL 参数，从一个备选列表中随机返回一个vendor/renderer，可以很好的防止收集信息结果过度集中，也可以很方便的进行拓展：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function get_random_item(list) { return list[Math.floor((Math.random() * list.length))]; } WebGLRenderingContext.prototype.getParameter = function () { ... // UNMASKED_VENDOR_WEBGL  if (name == 37445) { var options = [\u0026#39;Intel Open Source Technology Center\u0026#39;, \u0026#39;X.Org\u0026#39;, \u0026#39;Vendor Google Inc.\u0026#39;]; return get_random_item(options); } else if (name == 37446) { // UNMASKED_RENDERER_WEBGL  var options = [\u0026#39;Mesa DRI Intel(R) Ivybridge Mobile\u0026#39;, \u0026#39;AMD KAVERI (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Renderer Google SwiftShader\u0026#39;, \u0026#39;AMD ARUBA (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Mesa DRI Intel(R) HD Graphics 630 (Kaby Lake GT2)\u0026#39;, \u0026#39;Gallium 0.4 on AMD KAVERI (DRM 2.43.0 / 4.4.0-83-generic, LLVM 3.8.0)\u0026#39;]; return get_random_item(options); } ... }    Hook 一些基础属性, 如RENDERER / VENDOR / SHADING_LANGUAGE_VERSION /  VERSION\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 7936) { // RENDERER // VENDOR  return \u0026#39;Mozilla\u0026#39;; } else if (name == 35724) { // SHADING_LANGUAGE_VERSION  return \u0026#39;WebGL GLSL ES 1.0\u0026#39;; } else if (name == 7937 || name == 7938) { // VERSION  return \u0026#39;WebGL 1.0\u0026#39;; } ... }    Hook ALIASED_LINE_WIDTH_RANGE / ALIASED_POINT_SIZE_RANGE, 会返回一个float array，size为2；这里代码有点小问题，不影响功能，name == 7937是VERSION，不过在上面已经判断过了，不会进到这个分支：  1 2 3 4 5 6 7 8 9  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 33901 || name == 33902) { // ALIASED_LINE_WIDTH_RANGE // ALIASED_POINT_SIZE_RANGE  var option = new Float32Array([1, 8192]); return option; } ... }    针对一些webgl位宽信息进行Hook，返回随机值[2, 4, 8, 16]中1个，具体参数见注释：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3413 || name == 3412 || name == 3411 || name == 3410 || name == 34852) { // ALPHA_BITS // BLUE_BITS // GREEN_BITS // RED_BITS // MAX_DRAW_BUFFERS_WEBGL  return get_random_item([2, 4, 8, 16]); } ... }    针对一些位宽信息进行Hook，返回固定值，参数见注释  1 2 3 4 5 6 7 8 9 10 11  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3415) // STENCIL_BITS  return 0; } else if (name == 3414) { // DEPTH_BITS  return 24; } ... }    接下来是该脚本bug的地方，Hook出现问题，如果使用该脚本不加修改，很容易通过此bug识别；原因主要在于以下hook的三个参数值理论上是返回一个整数，但不知为何作者这里使用了get_random_items, 但没有给第二个参数，所以n会为undefined，导致固定返回一个Array：undefined；修复也很简单，换成get_random_item即可。源代码如下：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function get_random_items(list, n) { var result = new Array(n), len = list.length, taken = new Array(len); if (n \u0026gt; len) n = len while (n--) { var x = Math.floor(Math.random() * len); result[n] = list[x in taken ? taken[x] : x]; // 比较巧妙的取随机多个值的方式，留一个array标记如果下次再取到其下标会从目前未取成的最后一个元素  taken[x] = --len in taken ? taken[len] : len; } return result; } WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 34047 || name == 34921) { // MAX_TEXTURE_MAX_ANISOTROPY_EXT // MAX_VERTEX_ATTRIBS  return get_random_items([2, 4, 8, 16]); } else if (name == 35661) { // MAX_COMBINED_TEXTURE_IMAGE_UNITS  return get_random_items([128, 192, 256]); } ... }    对一些其他的MAX相关属性进行Hook，返回随机值，具体属性见注释  1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... } else if (name == 34076 || name == 34024 || name == 3379) { // MAX_CUBE_MAP_TEXTURE_SIZE // MAX_RENDERBUFFER_SIZE  return get_random_item([16384, 32768]) ; } else if (name == 36349 || name == 36347) { // MAX_FRAGMENT_UNIFORM_VECTORS // MAX_VERTEX_UNIFORM_VECTORS  return get_random_item([4096, 8192]); } else if (name == 34930 || name == 36348 || name == 35660) { // MAX_TEXTURE_IMAGE_UNITS // MAX_VARYING_VECTORS // MAX_VERTEX_TEXTURE_IMAGE_UNITS  return get_random_item([16, 32, 64]); } ... }    对MAX_VIEWPORT_DIMS进行Hook，会返回一个长度为2且两个值相等的Int32Array，同样此处随机取值：  1 2 3 4 5 6 7 8 9 10  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3386) { // MAX_VIEWPORT_DIMS  var value = get_random_item([8192, 16384, 32768]) var options = new Int32Array([value, value]); return options; } ... }    最后，剩下的参数统一随机从[0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]随机取值返回(此处还有个冗余分支STENCIL_BITS，上面已经判断过了，属于冗余代码)  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else { console.log(\u0026#34;Retuning random value for: \u0026#34; + name); return get_random_item([0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]); } ... }    最后的迷惑操作：理论上此处已经涵盖了所有的case返回，但是最后还多了个跑不到的分支：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... var ext = getParameter.apply(this, arguments); console.log(\u0026#34;WebGLRenderingContext extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(JSON.stringify(ext, null, 4)); return ext; }   说实话我猜测此处他是想模拟一些参数，他们在getParameter之前必须先调用getExtension方法后才可以获取，但是此处加在最后属实看不懂，个人理解应该放在这个大if\u0026hellip;else\u0026hellip;前面；有时间我可以好好修复一下这个项目😂😂\n其他的一些被Hook的方法  getSupportedExtension：比较简单，随机从extensions中间选择随机个keys并返回，出现异常则将所有的keys都返回。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // extensions的keys可以参见getExtension部分 const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions; WebGLRenderingContext.prototype.getSupportedExtensions = function () { try { console.log(\u0026#34;WebGLRenderingContext.getSupportedExtensions\u0026#34;) var availableExtensions = Object.keys(extensions); console.log(availableExtensions); var itemsToGet = Math.floor(Math.random() * (availableExtensions.length - 6) + 5); console.log(itemsToGet); var selectedExtensions = get_random_items(availableExtensions, itemsToGet); console.log(selectedExtensions); return selectedExtensions; } catch (a) { console.log(a) return Object.keys(extensions); } }    针对一些headless浏览器有可能会出现canvas的一些属性异常（broken会为0），如canvas的width和height，以及offset，进行Hook，还是使用defineProperty重写get方法对属性进行hook：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // in case of broken image return random height/width var size = 0; [\u0026#39;height\u0026#39;, \u0026#39;width\u0026#39;].forEach(property =\u0026gt; { const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, property); Object.defineProperty(HTMLImageElement.prototype, property, { imageDescriptor, get: function () { // 如果canvas破损，则返回随机size  if (this.complete \u0026amp;\u0026amp; this.naturalHeight == 0) { if (!size) { // 返回随机的长/宽  size = Math.floor(Math.random() * (30 - 10 + 1)) + 10; } return size; } // 未破损则返回正常size  return imageDescriptor.get.apply(this); }, }); }); // hairline feature (headless can\u0026#39;t render it normally) const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;); Object.defineProperty(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;, { ...imageDescriptor, get: function () { if (this.id == \u0026#39;modernizr\u0026#39;) { return 1; } return imageDescriptor.get.apply(this); }, });   插件执行 方法比较简单，将整个大函数作为字符串，最后在html document中新建一个script tag，script.textContent赋值为字符串即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  var scriptCode = \u0026#39;(\u0026#39; + function () { ... function WebGLRenderingContext(canvas) { ... }; ... WebGLRenderingContext.prototype.getExtension = function (ext) { ... }; ... WebGLRenderingContext.prototype.getParameter = function () { ... } ... } + \u0026#39;)();\u0026#39;; // 转成字符串，可直接执行  // 新建script节点插入document中，即自动执行 var script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = scriptCode; (document.head || document.documentElement).appendChild(script); // 最后move掉代码即可 script.remove();   ","description":"SpoofWebGL","id":3,"section":"posts","tags":["黑产工具"],"title":"SpoofWebGL","uri":"https://summersummer3.github.io/posts/spoofwebgl/"},{"content":"X.509系列（一）：X.509 v3格式下的证书 目前手头上接到了一个新的任务，刚好又是和X.509证书打交道的工作，想到刚入职的时候第一份正正经经的开发任务就是写证书签发工具，感觉这部分确实应该踏踏实实做一下总结了。很难说以笔者现在的水平能不能证书这么一个基础工具讲清楚，尽力而为吧。目前规划为三部分内容，本文第一篇，剩下两部分分别为：\n  ASN.1详解\n  密码库源码分析(基于mbedtls库)\n  证书的目的 我们公钥证书可以说是PKI(Public Key Infrastructure)中非常核心的组件之一，而PKI可以说是当代互联网文明安全的基石了。如果这方面的协议出现了漏洞，可以说会对整个世界互联网都造成非常严重的冲击。笔者知识有限，所以本文对CA(Certificate Authority)将简单抽象为单层级的一个证书颁发者。\n证书(Certificate) 里面主要包含三个部分：证书信息(TBS Certificate)(TBS = To Be Signed)，证书签名算法(signature Algorithm)和证书签名 (signatureValue). 证书信息里包含了证书的ID，证书拥有者的信息，签发者信息与最关键的，证书拥有者公钥信息。而证书的核心功能也是基于该公钥信息展开。\n想象两个场景：\n Alice和Bob进行通信，想要使用一条得到加密的数据传输通道，防止第三方窃听 Alice给Bob发了个消息，但是他想要向Bob证明这条消息是自己发出的，且没有被别人篡改过  场景1：秘钥协商 第一个场景下，可以把问题简单的规约为Alice和Bob需要拥有同样的对称秘钥，数据传输的通道上只传输由该秘钥加密过的数据。但是对称的秘钥如何传输呢？非对称密码体系解决了这个问题。在完成普通的握手之后：\n  Alice和Bob分别将自己的证书发给对方\n  Alice验证Bob的证书，验证成功后提取Bob公钥$ PUBKEY_B $, 之后取随机数 $ r_A $, 计算 $ s_A := PUBKEY_B(r_A) $发送给Alice. $ PUBKEY_X(n) $指使用$ X $的公钥对$ n $完成加密/验签操作. 对应ECC可以视为$ n(PUBKEY_X) $, RSA可以视为$ n^{PUBKEY_X} \\mod N$\n  Bob验证Alice的证书，验证成功后提取Alice公钥$ PUBKEY_A $, 之后取随机数 $ r_B $, 计算 $ s_B := PUBKEY_A(r_B) $ 发送给Alice\n  Alice和Bob分别用自己的私钥从$ s_B/s_A $中解出对应的$ r_B/r_A $, $ r_B := PRIKEY_A(s_B) $, $ r_A := PRIKEY_B(s_A) $，由于私钥都是仅Alice和Bob各自拥有的，网络上其他人无法解出，中间人的窃听将失效（但是中间人攻击依然是可能的，许多https的抓包软件就是基于中间人的攻击。想想为啥）\n  Alice和Bob拼接随机数串 $ r = r_A | r_B $，使用协定好的秘钥派生算法，将$ r $ 作为派生秘钥的种子派生出相同的秘钥，后期将使用该派生的秘钥作为加密通信的秘钥\n  其实上面的协议就是一个比较简化版的SSL/TLS的握手阶段，当然秘钥协商(DH: Diffie–Hellman key exchange)的方式还有很多, 但原理相差不多，会比直接加密简单一点。包括当前几乎已经是标配的HTTPS协议，底层的安全基础很大程度也是基于SSL的协议。\n场景2：数字签名 第二个场景就比较简单了：\n Alice会计算自己信息$M$的摘要值(Digest)，选择合适的padding方式，使用自己的私钥对信息的摘要值计算签名值$ Sig := PRIKEY_A(Pad(DIGEST(M))) $. 传输阶段将自己的证书，签名值与消息(Cert+Sig+M)一起打包发给Bob Bob拿到这个包后首先需要验证Alice的证书，验证成功后提取Alice的公钥；之后计算M的摘要值$D$，之后使用公钥计算$ D\u0026rsquo; := Depad(PUBKEY_A(Sig)) $, 最后判断 $ D\u0026rsquo; ?= D$，完成验签操作  简单来看，消息的摘要值保证了消息的完整性Integrity，而签名的验证保证了消息是来自Alice的不可抵赖性Non-repudiation\n好了，看完了上面的问题，有没有一点疑问：那看起来证书好像只是个公钥的壳子而已，为啥不直接发公钥就完事了？还有验证证书是什么意思？\n有没有想过，上述的Bob和Alice都是所谓的\u0026quot;好人\u0026quot;而已，这网络上哪有这么多好人。本质上，公钥其实只是一个很大的数，传递时也就是个二进制流。假如互联网上只有裸着的公钥传输，我怎么知道这个公钥是谁发给我的，中间有没有被别人给替换了。\n现实中我们证明自己是一个公民的办法通常是去公安局去获取自己的身份证，通过身份证证明我是我，因为身份证上有我的名字、唯一身份证号、照片等等，发证机关将在身份证盖上国家神圣的公章，证明身份证的真实性。那么在网络世界中，我们也需要一张这样的身份证，证明我是该公钥的拥有人，且公钥的信息很有限，所以我们需要打包更多公钥拥有者的信息，同时我们也需要一个组织来进行发证操作，起到公安局的作用，并对证书\u0026quot;盖上公章\u0026quot;。在这种场景下，网络世界的证书自然就呼之欲出了。\n证书的颁发 证书的申请文件 现实中我们去获取身份证时候，首先也要填一个申请表吧。我们在申请证书的时候同样需要一个申请文件来发给网络世界的公安局，CA。当然，这个申请文件也是需要遵循格式标准的RFC 2986 - PKCS #10: Certification Request Syntax Specification，缩写为.csr\n通过OpenSSL可以自己造一个合法格式的csr文件：\n正如申请身份证需要先造个人，首先我们需要自己造一个公钥，即制造一对公私钥对，以RSA-2048为例，生成pem格式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  pwner@pwner:~$ openssl genrsa -out rsa_private.pem 2048 Generating RSA private key, 2048 bit long modulus (2 primes) .........................................+++++ .........................................................+++++ e is 65537 (0x010001) pwner@pwner:~$ openssl rsa -in rsa_private.pem -pubout -out rsa_public.pem pwner@pwner:~$ cat rsa_public.pem rsa_private.pem -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6A5bWFoO3bU8apnV6Q4r SmosNvx28JSLz5gdwtrAHTjzqLn7yXu56kp/j8wZEKhe0jgKNCAGIwbY3begyAav ixZY4XUa647L4wtJ9lJzUTVcFdZ2g/WsmQXVY3ssa3NYL7SDnlBxffdrT8s0yRV4 Ojo4CqgJ926qEZERUxnuv5cgf7l3cfbZUoZzgcdw5XF+Mu98y+yvnrqnihfO2DGU HTWCRI93NkCpZRngPWElT1XR8kxSIuquJW54RgFE1RK6v7S8RVHvtwIqpvYV4D/u OgxktmwAblxwF65uPklLgVlNfxKMhFnQoF77vSPdWWaB0x8CQsn+5q4KhGARaT5z fQIDAQAB -----END PUBLIC KEY----- -----BEGIN RSA PRIVATE KEY----- MIIEpgIBAAKCAQEA6A5bWFoO3bU8apnV6Q4rSmosNvx28JSLz5gdwtrAHTjzqLn7 yXu56kp/j8wZEKhe0jgKNCAGIwbY3begyAavixZY4XUa647L4wtJ9lJzUTVcFdZ2 g/WsmQXVY3ssa3NYL7SDnlBxffdrT8s0yRV4Ojo4CqgJ926qEZERUxnuv5cgf7l3 cfbZUoZzgcdw5XF+Mu98y+yvnrqnihfO2DGUHTWCRI93NkCpZRngPWElT1XR8kxS IuquJW54RgFE1RK6v7S8RVHvtwIqpvYV4D/uOgxktmwAblxwF65uPklLgVlNfxKM hFnQoF77vSPdWWaB0x8CQsn+5q4KhGARaT5zfQIDAQABAoIBAQCDaxYKLD59CtWj XWnKaa7UntpZbZMCXm3rbC92maHxKr67EFDq4zn/2J7zVdfgGipRDVGiAXzYO1l3 /zV78mVZ9JbzX/mV67HF7C+/4yPRmtGCwIkv5GMR6j7V7vzSAWmw4p8jelU7zHIm p2NGefUzrKLuTgoO6cpA1pIkKOyP7TclGp9vTGh1MoE2rZjLggo+ESQuLX/GKDAH pV3NamiAgJtrfqTKoI/AnDcGhhy46np/Cwb4ENkFFJ6oHOYgyXexlBCQmjXfaQyp T45uGjuKi45r9c5mvP0Z7uejCKWPs6LjXye3SN2XtWFRJdADBMH+YMqHax8N3IPm 4cUz3l+hAoGBAP+vkZ2+qSECMjudymz9yEiSrrIAnG2G5gCTNsnannXMNzBOOgIb mpvGY8okLeA7pHsOYdyvnCvbRuA6mhtL+tFn84PjQem6Z18KyqwCvHWzsnvrcjbx yiBnSwsyfbfXQqdGhfs62Vko+6OxXSDB10uyHGiga7C26N8HY1F791UlAoGBAOhX WtNx5xubEgGumKPNNdSD/5Toq+Cz+eIuLiTfR4zZYGcjBawcESzkV3EM6HN/LL8N bZ1DFKxIMsGAECmkImKtEkWEpeqJkatjsQbDvzSX0mUPrE4fFJQF3JzzauXKUayC 51S0GS9EN0FLYk0mjXyrJcHaHcFqgVW0eQ/7RNF5AoGBANuLFFy/hpfKO/nGrjbR 3rS6BnjfX3IIX9vkjCncpy18sXKv6M1AiIvzWGIMmLuuWrgzDEKjI1ThDsWgbAy+ O9qtCIKZk1Iu9W29ZXM3Uj06lCola8fT63vRVbWCoEJH+nqJaqfiyxfswc23kMB8 0PG1OQF5pZ5yIBjJTjV8XU5lAoGBAL+M3W2712x0AXlvh5psIfguRzVuSd38o4Rs zFBL4MJnqMn/HrsRfLuFGe4zVSV7cNmmaXuhBVcwQuAzA6BBGLQ/ufOkc+GUP4uM qjNIiMgEb0owjL7vctjCqGqhaL1Aeut+FNhJjwXf+KoVS1sN8NIajAtxFt0SQMT3 AGRDpS4JAoGBAK6hrYUVDDLEDfvfCH8ItOGYozPdDDvJbiZQMdK9tXSnpfoOGOXK 9ofPPSrBoAIt7O0RR5fBR3di8fZbVGJRd2NUsnbFhlj4KBVKusYRjeTl5PcNI6G0 P8wd5+pqIdwAVN77S5MeusApw8A2+L67odt6xzHGugR3pcBzGONUsD3C -----END RSA PRIVATE KEY-----   生成csr文件，输入自己的公钥与私钥，通常还会让你输入自己的个人信息。使用PKCS#10的标准将信息与公钥打包后，由自己私钥进行自签名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  pwner@pwner:~/X509_learning$ openssl req -new -in rsa_public.pem -key rsa_private.pem -out rsa_public.csr.pem You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Country Name (2 letter code) [AU]:CN State or Province Name (full name) [Some-State]:GD Locality Name (eg, city) []:SZ Organization Name (eg, company) [Internet Widgits Pty Ltd]:xxxx Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []:xxxx Email Address []:xxxx Please enter the following \u0026#39;extra\u0026#39; attributes to be sent with your certificate request A challenge password []: An optional company name []: pwner@pwner:~/X509_learning$ cat rsa_public.csr.pem -----BEGIN CERTIFICATE REQUEST----- MIICtTCCAZ0CAQAwcDELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkdEMQswCQYDVQQH DAJTWjEPMA0GA1UECgwGSFVBV0VJMREwDwYDVQQDDAhTSFVBSUhVQTEjMCEGCSqG SIb3DQEJARYUc2h1YWlodWEyQGh1YXdlaS5jb20wggEiMA0GCSqGSIb3DQEBAQUA A4IBDwAwggEKAoIBAQDoDltYWg7dtTxqmdXpDitKaiw2/HbwlIvPmB3C2sAdOPOo ufvJe7nqSn+PzBkQqF7SOAo0IAYjBtjdt6DIBq+LFljhdRrrjsvjC0n2UnNRNVwV 1naD9ayZBdVjeyxrc1gvtIOeUHF992tPyzTJFXg6OjgKqAn3bqoRkRFTGe6/lyB/ uXdx9tlShnOBx3DlcX4y73zL7K+euqeKF87YMZQdNYJEj3c2QKllGeA9YSVPVdHy TFIi6q4lbnhGAUTVErq/tLxFUe+3Aiqm9hXgP+46DGS2bABuXHAXrm4+SUuBWU1/ EoyEWdCgXvu9I91ZZoHTHwJCyf7mrgqEYBFpPnN9AgMBAAGgADANBgkqhkiG9w0B AQsFAAOCAQEA5FHk/AAEmiR58aHZJ9dAFMtxEAm4x9WYpxcfzFrXt1h35QFLK3D5 3SkZlTeRNfH3r4eNYit8Hm3efqsfQXfgcuO5RTS4lU7DcAdsgExddxd52NojfnxP qMfBQNZTuglVLGZ3o3O/HQ0YvJjkcLyIyFyU1YwVzWkts/QHKmU2mtyrLN4piolv nZlTSX3qeUio218nwEmXzztcZBR51Z3hriUSIP/+rBWJlZEP+0sTaOmG46gQwS7r jxif4CcoCwPDd8+GeiSSbWHZzNYRISVtQcLHVsUAq6iro3YiQygPBLF4bwa4c8kX bcqeI/q36J+2myc/alFWDGjEsE/6zh6c7w== -----END CERTIFICATE REQUEST-----   -in选项输入公钥，-key输入私钥，-out为输出csr文件名。-new表示新建一个csr。运行命令行后然后会让你输入的个人信息。此处拆分主要为了阐述csr的生成流程。\n1  pwner@pwner:~/X509_learning$ openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout rsa_private.pem -out rsa_public.csr.pem   但是上面的打印啥也看不出来，我们需要用解析完的方式来查看该文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  pwner@pwner:~/X509_learning$ openssl req -in rsa_public.csr.pem -noout -text Certificate Request: Data: Version: 1 (0x0) Subject: C = CN, ST = GD, L = SZ, O = xxxx, CN = xxxx, emailAddress = xxxx Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:e8:0e:5b:58:5a:0e:dd:b5:3c:6a:99:d5:e9:0e: 2b:4a:6a:2c:36:fc:76:f0:94:8b:cf:98:1d:c2:da: c0:1d:38:f3:a8:b9:fb:c9:7b:b9:ea:4a:7f:8f:cc: 19:10:a8:5e:d2:38:0a:34:20:06:23:06:d8:dd:b7: a0:c8:06:af:8b:16:58:e1:75:1a:eb:8e:cb:e3:0b: 49:f6:52:73:51:35:5c:15:d6:76:83:f5:ac:99:05: d5:63:7b:2c:6b:73:58:2f:b4:83:9e:50:71:7d:f7: 6b:4f:cb:34:c9:15:78:3a:3a:38:0a:a8:09:f7:6e: aa:11:91:11:53:19:ee:bf:97:20:7f:b9:77:71:f6: d9:52:86:73:81:c7:70:e5:71:7e:32:ef:7c:cb:ec: af:9e:ba:a7:8a:17:ce:d8:31:94:1d:35:82:44:8f: 77:36:40:a9:65:19:e0:3d:61:25:4f:55:d1:f2:4c: 52:22:ea:ae:25:6e:78:46:01:44:d5:12:ba:bf:b4: bc:45:51:ef:b7:02:2a:a6:f6:15:e0:3f:ee:3a:0c: 64:b6:6c:00:6e:5c:70:17:ae:6e:3e:49:4b:81:59: 4d:7f:12:8c:84:59:d0:a0:5e:fb:bd:23:dd:59:66: 81:d3:1f:02:42:c9:fe:e6:ae:0a:84:60:11:69:3e: 73:7d Exponent: 65537 (0x10001) Attributes: a0:00 Signature Algorithm: sha256WithRSAEncryption e4:51:e4:fc:00:04:9a:24:79:f1:a1:d9:27:d7:40:14:cb:71: 10:09:b8:c7:d5:98:a7:17:1f:cc:5a:d7:b7:58:77:e5:01:4b: 2b:70:f9:dd:29:19:95:37:91:35:f1:f7:af:87:8d:62:2b:7c: 1e:6d:de:7e:ab:1f:41:77:e0:72:e3:b9:45:34:b8:95:4e:c3: 70:07:6c:80:4c:5d:77:17:79:d8:da:23:7e:7c:4f:a8:c7:c1: 40:d6:53:ba:09:55:2c:66:77:a3:73:bf:1d:0d:18:bc:98:e4: 70:bc:88:c8:5c:94:d5:8c:15💿69:2d:b3:f4:07:2a:65:36: 9a:dc:ab:2c:de:29:8a:89:6f:9d:99:53:49:7d:ea:79:48:a8: db:5f:27:c0:49:97:cf:3b:5c:64:14:79:d5:9d:e1:ae:25:12: 20:ff:fe:ac:15:89:95:91:0f:fb:4b:13:68:e9:86:e3:a8:10: c1:2e:eb:8f:18:9f:e0:27:28:0b:03:c3:77:cf:86:7a:24:92: 6d:61:d9:cc:d6:11:21:25:6d:41:c2:c7:56:c5:00🆎a8🆎 a3:76:22:43:28:0f:04:b1:78:6f:06:b8:73:c9:17:6d:ca:9e: 23:fa:b7:e8:9f:b6:9b:27:3f:6a:51:56:0c:68:c4:b0:4f:fa: ce:1e:9c:ef   这就有那味儿了，简单解析一下，顺便对应着RFC的标准看一下。先看Data这段，对应的是 CertificationRequestInfo\n1 2 3 4 5 6  CertificationRequestInfo ::= SEQUENCE { version INTEGER { v1(0) } (v1,...), subject Name, subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }}, attributes [0] Attributes{{ CRIAttributes }} }   顺便提一下，RFC的标准都是使用ASN.1格式描述的，而日常使用中的证书等文件同样是基于ASN.1的BER格式，而PEM是对文件进行标识（如-----BEGIN CERTIFICATE REQUEST-----）后，进行base64编码的产物。ASN.1的具体细节将在(二)部分进行分析。\n可以发现生成的csr的data部分是可以和CertificationRequestInfo一一对应起来的：\nversion：csr的版本号，当前通常是version 1，即0\nsubject：以Name的格式保存，一般会保存证书持有者的国籍(C:Country 两个字母表示，如美国US，中国CN), 省级行政区(ST: State or Province)，城市(L:Locality), 公司组织名(O:Organization), 组织部门名(OU: Organization Unit), 通用名(CN: Common Name), email地址等等。其实具体的规范还是比较复杂的，具体标准参考X.501规范。此处不细说了\nsubjectPKInfo: 最关键的部分，包含了公钥的信息，由公钥算法与公钥值组成：\n1 2 3 4  SubjectPublicKeyInfo { ALGORITHM : IOSet} ::= SEQUENCE { algorithm AlgorithmIdentifier {{IOSet}}, subjectPublicKey BIT STRING }   顺便提一句，AlgorithmIdentifier的标识是ANS.1编码中最与众不同的方式，Object ID. 后续将提到。此处算法被标记为了rsaEncrypt\n最后是attributes，他主要提供了一些证书申请者的附加信息。PKCS#9中定义了一些在此可能使用的属性类型，典型的例子是challenge-password属性：它将指定一个密码，实体可以通过该密码请求吊销证书；另一个例子是X.509证书扩展中显示的信息（例如。从PKCS #9获取的extensionRequest属性等）。此处a0:00标识了NULL\n1 2 3 4  Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE { type ATTRIBUTE.\u0026amp;id({IOSet}), values SET SIZE(1..MAX) OF ATTRIBUTE.\u0026amp;Type({IOSet}{@type}) }   再看完整的csr结构：\n1 2 3 4 5  CertificationRequest ::= SEQUENCE { certificationRequestInfo CertificationRequestInfo, signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }}, signature BIT STRING }   certificationRequestInfo对应的就是上面的Data，已完成解释\nsignatureAlgorithm对应签名算法，此处为sha256WithRSAEncryption，指的是使用待签名的公钥对应的私钥，来完成自签名，签名的对象是certificationRequestInfo的sha256摘要值，签名算法为RSA\n最后signature对应的就是签名值了，bit string类型\n最后提一点，在证书申请的模式下，申请者只需要将公钥信息发至证书签发机构即可，保证了私钥的本地性与私密性。\nCA 完成了申请表的填写，就应该交给身份证办理人员了，类比下来csr文件生成之后，我们就要向CA发送证书申请文件，以获取证书。\nCA可以翻译为数字证书认证机构，是PKI体系中的基石。维基百科于是说：\n CA是证书的签发机构，它是PKI的核心。CA是负责签发证书、认证证书、管理已颁发证书的机关。它要制定政策和具体步骤来验证、识别用户身份，并对用户证书进行签名，以确保证书持有者的身份和公钥的拥有权。\n 由上文可以推断，CA正是承担了公安局对身份证\u0026quot;盖章\u0026quot;这一工作，盖上的便是使用CA私钥完成的对证书的数字签名。但是公安局的信用是有国家背书的，所以CA也必须得到网络上所有人的信任。当然拥有CA资格的机构也是相当有限的。\nCA获取证书申请之后，首先就要检测csr的合法性，申请人信息的合法性，公钥的合法性等等。这些属于审批的范畴，技术范畴的话就是需要校验csr的签名，即certificationRequestInfo是否被篡改。过程为取出certificationRequestInfo中的公钥信息，计算certificationRequestInfo的待验证哈希值。利用提取的公钥与签名计算出签名哈希值，解padding后，判断是否与待验证哈希值一致，确定该csr的完整性与不可抵赖性。\nCA在完成验证后，将下发自己的CA证书以及签发的X.509证书。CA同样是一张X.509格式的证书，往往也是一张自签名的证书，即CA私钥签发CA公钥。事实上，当前网络通讯当中（特别是浏览器）将会内置上很多权威受信任的CA证书，若通信过程中使用的CA证书并不在内置名单中，往往程序会进行提醒：当前站点CA证书不受信任。而且现在CA往往由于需要加快签发速率等原因，会使用多级CA的模式，即CA证书由上级CA签发，最后将校验链上的证书一并发送给申请者，后续校验时将进行证书的逐级校验。\n还记得上面场景中提到的：Alice验证Bob的证书这一步吗？Alice正是通过CA证书中的公钥来校验Bob证书签名的。原因正是基于CA是Alice所信任的证书认证者。当然验证证书还需要对certificateInfo校验，确定Bob的身份，下章就会讲到。\nX.509 终于到了重头戏，我们的主角，X.509格式的证书。再强调一次，证书是功能性的描述，而X.509只是证书一种国际上通用的格式，基于RFC3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile(X.509 v3), 对应了PKCS#12。\n这次我们直接拿上一张Google的证书来看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  Certificate: Data: Version: 3 (0x2) Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT Subject: C = US, ST = California, L = Mountain View, O = Google LLC, CN = www.google.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:bc:1c:aa:96:6f:6f:99:48:79:56:61:4b:7f:ff: dc:39:08:3a:d4:4d:e2:d8:87:80:af:3d:18:5e:71: 2d:ce:09:70:57:39:38:5f:2a:ee:a8:35:f4:3a:86: 86:5a:1d:c7:31:32:1b:8d:ac:d0:46:ad:c3:fc:a5: d3:18:36:68:ab ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Authority Information Access: OCSP - URI:http://ocsp.pki.goog/gts1o1core CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt X509v3 Subject Alternative Name: DNS:www.google.com X509v3 Certificate Policies: Policy: 2.23.140.1.2.2 Policy: 1.3.6.1.4.1.11129.2.5.3 X509v3 CRL Distribution Points: Full Name: URI:http://crl.pki.goog/GTS1O1core.crl CT Precertificate SCTs: Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 5E:A7:73:F9:DF:56:C0:E7:B5:36:48:7D:D0:49:E0:32: 7A:91:9A:0C:84:A1:12:12:84:18:75:96:81:71:45:58 Timestamp : Aug 26 09:14:24.417 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:20:77:F3:D6:8B:51:4F:88:71:16:73:ED:36: 2F:64:F4:77:3E:92:D3:CE:97:1F:1C:53:FA:4E:FB:5B: D7:0A:4C:D6:02:21:00:9F:B9:FE:F1:F3:1C:0D:CF:20: 30:B1:1C:0A:01:65:AD:67:90:1F:B5:33:90:8D:49:4D: 2B:ED:1D:90:28:A1:6B Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 07:B7:5C:1B:E5:7D:68:FF:F1:B0:C6:1D:23:15:C7:BA: E6:57:7C:57:94:B7:6A:EE:BC:61:3A:1A:69:D3:A2:1C Timestamp : Aug 26 09:14:24.367 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:21:00:F4:67:8E:8B:ED:3F:B2:D4:EA:72:EB: 53:F1:52:57:98:D6:63:0E:C0:6B:68:46:CE:F3:AD:25: 52:AD:12:83:27:02:20:05:CA:04:76:D6:4F:2A:E5:D3: 96:85:79:A2:F3:85:29:9E:89:30:00:A7:20:99:2D:F7: C9:56:3C:4E:5D:5C:CF Signature Algorithm: sha256WithRSAEncryption 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: 32:99:29:f8:13:6b:72:af:16:79:63:d3:3f:76:56:57:19:78: 91:86:f8:7a:ee:26:67:98:dc:5e:e4:00:f5:87:a0:01:21:9d: cf:e5:9f:02:f3:2a:fd:0e:fd:78:af:2e:20:29:77:35:e2:c6: 30:ee:ef:be:f2:bb:26:02:52:a2:2d:27:78:ce:a9:8e:39:d0: a2:74:90:11:c5:92:58:3c:7a:88:1d:c7:5a:56:d4:1a:01:00: c3:9d:98:6f:41:02:1f:cb:e2:4d:99:6a:5c:d9:0f:c0:88:08: 15:c5:26:90:a2:a4:15:f6:71:e2:fe:a9:98:dc:40:2a:71:c1: 11:aa:00:73:52:24:74:aa:ae:72:55:2f:0d:31:b7:00:bb:1f: 87:4d:f5:05:ad:ff:7a:93:e0:cf:86:a5:1d:1b:7d:41:fa:10: 99:3b:00:7c:c9:dd:a9:52:5c:06:72:86:96:e7:05:97:77:12: 2f:26:bb:dc:65:c4:48:4d:9c:82:4b:7d:69:27:3f:85:00:2e: b1:5d:8d:dc   同样对照标准定义进行学习字段的意义：\n1 2 3 4  Certificate ::= SEQUENCE { tbsCertificate TBSCertificate, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING }   可以看到Data对应了tbsCertificate, 也是整张证书最关键的部分，该字段包含证书拥有者信息、颁发者信息、公钥信息、有效期信息等，后面单独拿出来详细解析。\n剩下的两个部分与csr完全一致，同样是表明了签名的算法与tbsCertificate的签名。这里要注意，签发者issuer信息表明了证书签发人，一般为受信任的CA。\nTBSCertificate 核心字段，一点点手撕；先看定义\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  TBSCertificate ::= SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, serialNumber CertificateSerialNumber, signature AlgorithmIdentifier, issuer Name, validity Validity, subject Name, subjectPublicKeyInfo SubjectPublicKeyInfo, issuerUniqueID [1] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version shall be v2 or v3 subjectUniqueID [2] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version shall be v2 or v3 extensions [3] EXPLICIT Extensions OPTIONAL -- If present, version shall be v3 } Version ::= INTEGER { v1(0), v2(1), v3(2) } CertificateSerialNumber ::= INTEGER Validity ::= SEQUENCE { notBefore Time, notAfter Time } Time ::= CHOICE { utcTime UTCTime, generalTime GeneralizedTime } UniqueIdentifier ::= BIT STRING SubjectPublicKeyInfo ::= SEQUENCE { algorithm AlgorithmIdentifier, subjectPublicKey BIT STRING }   这里顺便提一句ASN.1下的定义中SEQUENCE和SET的区别在于：通常SEQUENCE是一个有序集合，即编码时必须按照顺序排列，SET则可以为无序的集合。通常解析SEQUENCE时都将按序解析。\nversion：X.509标准下版本，例子中证书为0x2，即v3版本。注意证书存在extensions时，版本一定是v3版本，故extension通常也称为X.509 v3 extension。\nserialNumber：证书的序列号，它必须是一个唯一的整数。需要注意一点，他是一个大端数字，所以有时候他可能高位填一些0，但不影响其对比。比如例子中的证书，实际编码中高位填上了0：\n/* 解析结果 */ Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f /* 编码 */ Tag:[02] Length:[11] Value:[00 BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F] 序列号的作用主要在CRL中体现唯一标识的作用。可以对照到身份证上的身份证号:)\nsignature: 标记了证书的签名算法，与csr一样，不做赘述。\nissuer：标记证书签发者CA的信息，例子中可以看到为Google Trust Services签发。具体格式类似上面的subject。\nvalidity：标识了证书的生效时间，以起始时间与结束时间表述。可以看到例子中的证书的生效起始时间为格林威治时间的2020/08/26, 有效期至2020/11/18。时间的ASN.1通常以 YYMMDDHHMMSS来标识，结尾以Z或者时区差标识时区。Z是Zulu时间的意思，和格林威治时间同步。\nsubject：证书拥有者信息，同issuer。上面提到校验Bob的信息，也就是对这一段的验证。\nsubjectPublicKeyInfo：证书公钥信息，也和csr中的一致。\nUniqueID：可选字段，这个字段必须要v2及以上版本才有，主要是用来防止issuer与subject重名的情况。例子中的证书是没有的\nExtension extension是最重头戏的字段：\n1 2 3 4 5 6  Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension Extension ::= SEQUENCE { extnID OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING }   通过描述可以看到Extensions是一个可选字段，其内部可以有最多MAX个拓展字段，这里当然无法单独完成阐述，挑一些例子中的标准拓展字段描述。\nAuthority Key Identifier/Subject Key Identifier: 这两个字段主要是在多证书的场景提供一种快速确定所需要公钥的标记。Authority Key Identifier唯一标记了该证书签发私钥对应的公钥，而Subject Key Identifier则是唯一标记了当前证书中的公钥。举个例子，一个设备当中可能有好多个证书，但是每一个app可能只需要对应证书中的公钥，那么就可以将这一串ID内置在app中，证书也不需要完整解析，先去看看对应Key Identifier字段是不是匹配即可。通常计算方式为计算公钥的SHA1值，本例子中的Subject Key Identifier即为这种方式：\n1 2 3 4 5 6 7 8 9  X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 from hashlib import sha1 hash = sha1() hash.update(b\u0026#34;\\x04\\xbc\\x1c\\xaa\\x96\\x6f\\x6f\\x99\\x48\\x79\\x56\\x61\\x4b\\x7f\\xff\\xdc\\x39\\x08\\x3a\\xd4\\x4d\\xe2\\xd8\\x87\\x80\\xaf\\x3d\\x18\\x5e\\x71\\x2d\\xce\\x09\\x70\\x57\\x39\\x38\\x5f\\x2a\\xee\\xa8\\x35\\xf4\\x3a\\x86\\x86\\x5a\\x1d\\xc7\\x31\\x32\\x1b\\x8d\\xac\\xd0\\x46\\xad\\xc3\\xfc\\xa5\\xd3\\x18\\x36\\x68\\xab\u0026#34;) hash.hexdigest() \u0026gt;\u0026gt;\u0026gt;\u0026#39;af32a89d2098f3fd1441fef4c474477cd16c81b1\u0026#39;   Key Usage/Extended Key Usage: 确定证书中公钥的用途。以前一个为主，extended字段作为补充。例子中的证书主要就是用来做TLS通讯中的数字签名功能。Key Usage主要类型有以下几种，详细描述可以参考标准中的描述，这里不展开说了：\n1 2 3 4 5 6 7 8 9 10  KeyUsage ::= BIT STRING { digitalSignature (0), nonRepudiation (1), keyEncipherment (2), dataEncipherment (3), keyAgreement (4), keyCertSign (5), cRLSign (6), encipherOnly (7), decipherOnly (8) }   Certificate Policies：以OID格式体现，主要是表现申请证书时的缘由和预期的用途。例子中的2.23.140.1.2.2和1.3.6.1.4.1.11129.2.5.3是典型的OID格式，每个点隔开一个属性层级，可以通过 http://www.oid-info.com/ 进行Object的查询，如2.23.140.1.2.2表示为organization-validated，即\n Certificates issued in accordance with the CA/Browser Forum\u0026rsquo;s Baseline Requirements - Organization identity asserted\n Authority Information Access：标识了CA Issuer的信息，包括OCSP服务的网址与CA证书的下载地址。该部分在TLS很重要。OCSP服务会在后续CRL中提到。\nCRL Distribution Points：CRL(Certificate Revocation List), 标识了当前CA下吊销列表文件的下载地址，也是TLS握手阶段重要的过程。后续将继续分析。\nCT Precertificate SCTs：证书透明度(Certificate Transparency); 这个是标准中没有提到的一个比较新的拓展。CT主要搭配了CA服务器上公开的Log，将记录CA的行为日志，而每一个与当前证书相关的日志将被计入此字段，并被CA进行签名。校验阶段可以根据Log ID和timestamp查找日志中的对应操作，对证书进行审计以确定当前证书的合法性。该字段的提出主要就是防止CA被入侵者利用后获取大量非法签发证书，而透明性的日志保证了证书的签发是到受到严格监控的。\nCRL 证书的有效期似乎已经能够防止回退之内的攻击了，但是万一在有效期内发生了对应私钥的泄漏事件，该怎么取消掉证书的有效性呢？这时候就需要crl出场了。\n上面已经提到了CRL Distribution Points，直接从对应地址下载个crl：\nCertificate Revocation List (CRL): Version 2 (0x1) Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Last Update: Sep 19 02:13:00 2020 GMT Next Update: Sep 29 02:13:00 2020 GMT CRL extensions: X509v3 CRL Number: 1001 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Revoked Certificates: Serial Number: 049950FB5DD23C3502000000007A32AD Revocation Date: Sep 10 15:53:36 2020 GMT CRL entry extensions: X509v3 CRL Reason Code: Affiliation Changed Serial Number: 05303980A9456025080000000056050B Revocation Date: Sep 10 15:53:42 2020 GMT CRL entry extensions: X509v3 CRL Reason Code: Affiliation Changed ...... Signature Algorithm: sha256WithRSAEncryption 00:37:3c:7e:ba:71:d2:92:52:3a:f6:4d:86:c0:a2:c2:18:78: 34:0e:ea:80:41:08:82:32:54:42:f0:2c:d7:f7:e0:81:93:dc: 0d:e5:0b:71:1f:ae:7e:bf:1c:05:3c:3c:f8:2b:cb:99:20:21: 80:29:a9:81:1d:f4:33:f4:21:95:70:f1:4c:38:30:34:28:32: be:0a:0b:0d:09:5d:81:33:72:fb:40:16:db:26:a1:7d:e9:11: 56:74:11:58:e3:4d:37:93:23:68:6a:85:8c:89:05:7d:55:67: 8c:da:3c:02:cb:46:3b:4e:7d:c6:38:12:02:cc:a8:ff:57:04: 9d:0a:bf:07:30:36:5d:85:b7:4c:9e:a1:52:b8:2c:4a:ec:91: ba:ba:8f:74:60:f4:06:84:8b:d9:a7:08:3d:2a:cf:ee:66:c6: de:1e:ae:68:24:ed:0d:ca:d6:73:0e:40:b2:5c:91:00:dc:32: 72:04:8b:46:65:12:9c:56:9d:aa:76:89:7b:c2:74:a8:b0:a3: de:e6:d6:d1:12:87:16:34:98:9b:2e:bd:38:ea:1c:59:03:40: 0d:ba:0c:0c:f2:9e:31:64:33:1b:28:43:4e:3b:78:41:2e:d9: 82:21:39:97:fe:c0:ab:9f:82:8d:18:02:26:c4:b0:44:c5:74: 25:30:6a:50 还是先对应ASN.1对于crl格式的描述看一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  CertificateList ::= SEQUENCE { tbsCertList TBSCertList, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING } TBSCertList ::= SEQUENCE { version Version OPTIONAL, -- if present, MUST be v2 signature AlgorithmIdentifier, issuer Name, thisUpdate Time, nextUpdate Time OPTIONAL, revokedCertificates SEQUENCE OF SEQUENCE { userCertificate CertificateSerialNumber, revocationDate Time, crlEntryExtensions Extensions OPTIONAL -- if present, MUST be v2 } OPTIONAL, crlExtensions [0] EXPLICIT Extensions OPTIONAL -- if present, MUST be v2 }   可以看到这时候crl的解析出来的格式顺序已经和标准的定义略有区别，但是不影响，只要知道所有的吊销列表信息肯定都是被CA签名了的。\nsignatureAlgorithm和signatureValue 没啥好说的，和之前证书和申请文件没有区别。\nCertList 这一段可分为主要的两个部分：吊销文件信息和吊销证书列表，这也是解析出来crl没有按照顺序排列的原因，为了打印的好看，这一段被拆分成了两部分\n先看吊销文件信息：\nversion、signature和issuer 和之前完全一样，不再赘述。\nthisUpdate：指定了本次crl签发的的时间。主要用来保证crl证书的时效性\nnextUpdate：可选项，指定了下一次crl签发的时间\ncrlExtensions：包含了拓展信息，注意这个字段在实际的证书中是放在revokedCertificates后面的。在用例的google证书的crl中可以看到吊销证书的数量(CRL Number: 1001)和Authority Key Identifier,可以看到这个Authority Key Identifier和X.509证书中的相同字段是一模一样的。注意这个地方CRL Number是不一定等于revokedCertificates中被吊销列表数量的，其实为了加快查找效率，已经过期的被吊销证书是可以从列表中移除以减小列表的大小。\nrevokedCertificates 这是crl的核心部分，包含了被吊销证书的唯一序列号(userCertificate CertificateSerialNumber)，证书的吊销时间(revocationDate)，以及一些扩展，用例中包含了典型用例：吊销原因码(CRL Reason Code)。\n主要看一下唯一序列号这个段，这个段是刚好对应X.509证书中的serialNumber段，这也是为什么这个段需要唯一的原因：他标识了一张独一无二的证书。\n其实这时候查询一个列表是否吊销的流程已经很简单了：\n 握手阶段获取crl 通过CA证书校验crl签名 查询对端证书的序列号是否在revokedCertificates中  但是这是唯一的方法吗？如果碰到像当年heartbleed一样的大型泄漏事件，吊销列表是不是特别大，特别大会造成两个问题：下载慢、查询慢，最终导致握手超时。\n第二点问题是crl有更新不及时的问题：CA机构在吊销一张证书后，不会立刻去更新CRLs文件，客户端定期缓存的CRLs文件也不是及时更新的，所以会导致一种情况是，某张证书被吊销后，由于CRLs文件没有及时更新的缘故，身份校验通过了，认为该张证书没有问题。\n所以为了解决对应的问题，SSL中包含一种新协议\nOCSP OCSP（Online Certificate Status Protocol），即在线证书状态协议。同样是用来做服务器身份校验，由CA机构管理，使用数字签名技术保护，浏览器可以从中获得证书的吊销状态和吊销原因，方式是由身份校验方浏览器发送OCSP请求，等待响应来完成证书状态获取。当然OCSP的格式同样要遵照标准rfc6960。这里就不细解析OCSP格式了，可以参考标准文档。\n当然OCSP最为协议当然也有request和response(其实csr就是请求，申请下来的证书就是答复)，这里贴一下request的格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  OCSPRequest ::= SEQUENCE { tbsRequest TBSRequest, optionalSignature [0] EXPLICIT Signature OPTIONAL } TBSRequest ::= SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, requestorName [1] EXPLICIT GeneralName OPTIONAL, requestList SEQUENCE OF Request, requestExtensions [2] EXPLICIT Extensions OPTIONAL } Signature ::= SEQUENCE { signatureAlgorithm AlgorithmIdentifier, signature BIT STRING, certs [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL} Version ::= INTEGER { v1(0) } Request ::= SEQUENCE { reqCert CertID, singleRequestExtensions [0] EXPLICIT Extensions OPTIONAL } CertID ::= SEQUENCE { hashAlgorithm AlgorithmIdentifier, issuerNameHash OCTET STRING, -- Hash of issuer\u0026#39;s DN issuerKeyHash OCTET STRING, -- Hash of issuer\u0026#39;s public key serialNumber CertificateSerialNumber }   尾声 看起来X.509这一系列好像很简单的样子，然而这里打出来的其实都是完成解析之后的样子，那么解析之前的DER格式的证书是啥样子的呢：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  00000000: 3082 04c8 3082 03b0 a003 0201 0202 1100 0...0........... 00000010: bc01 4105 22d8 cc7f 0200 0000 0079 647f ..A.\u0026#34;........yd. 00000020: 300d 0609 2a86 4886 f70d 0101 0b05 0030 0...*.H........0 00000030: 4231 0b30 0906 0355 0406 1302 5553 311e B1.0...U....US1. 00000040: 301c 0603 5504 0a13 1547 6f6f 676c 6520 0...U....Google 00000050: 5472 7573 7420 5365 7276 6963 6573 3113 Trust Services1. 00000060: 3011 0603 5504 0313 0a47 5453 2043 4120 0...U....GTS CA 00000070: 314f 3130 1e17 0d32 3030 3832 3630 3831 1O10...200826081 00000080: 3432 335a 170d 3230 3131 3138 3038 3134 423Z..2011180814 00000090: 3233 5a30 6831 0b30 0906 0355 0406 1302 23Z0h1.0...U.... 000000a0: 5553 3113 3011 0603 5504 0813 0a43 616c US1.0...U....Cal 000000b0: 6966 6f72 6e69 6131 1630 1406 0355 0407 ifornia1.0...U.. 000000c0: 130d 4d6f 756e 7461 696e 2056 6965 7731 ..Mountain View1 000000d0: 1330 1106 0355 040a 130a 476f 6f67 6c65 .0...U....Google 000000e0: 204c 4c43 3117 3015 0603 5504 0313 0e77 LLC1.0...U....w 000000f0: 7777 2e67 6f6f 676c 652e 636f 6d30 5930 ww.google.com0Y0 00000100: 1306 072a 8648 ce3d 0201 0608 2a86 48ce ...*.H.=....*.H. 00000110: 3d03 0107 0342 0004 bc1c aa96 6f6f 9948 =....B......oo.H 00000120: 7956 614b 7fff dc39 083a d44d e2d8 8780 yVaK...9.:.M.... 00000130: af3d 185e 712d ce09 7057 3938 5f2a eea8 .=.^q-..pW98_*.. 00000140: 35f4 3a86 865a 1dc7 3132 1b8d acd0 46ad 5.:..Z..12....F. 00000150: c3fc a5d3 1836 68ab a382 025c 3082 0258 .....6h....\\0..X 00000160: 300e 0603 551d 0f01 01ff 0404 0302 0780 0...U........... 00000170: 3013 0603 551d 2504 0c30 0a06 082b 0601 0...U.%..0...+.. ...   啥啥啥，这是啥？？\n其实这就是反复提到的ASN.1格式。系列下一章就是手撕ASN.1, 做一个人肉decoder(想多了\u0026hellip;)\n","description":"X.509证书格式介绍","id":4,"section":"posts","tags":["OpenSSL"],"title":"X.509系列（一）：X.509 v3格式下的证书","uri":"https://summersummer3.github.io/posts/x509_1/"},{"content":"ASN.1编解码标准X.690 书接上文，我们有提到X.509格式的证书通常是使用ASN.1的格式编码的。那么ASN.1是个啥，如何进行编码解码呢。这篇文章主要用来解读ASN.1的标准，学习成为解码人柱力。\nASN.1与TLV 先看看wiki对于ANS.1格式的描述：\n 在电信和计算机网络领域，ASN.1（Abstract Syntax Notation One) 是一套标准，是描述数据的表示、编码、传输、解码的灵活的记法。它提供了一套正式、无歧义和精确的规则以描述独立于特定计算机硬件的对象结构。\n 看起来很厉害，再看看其类别有哪些：\n ASN.1本身只定义了表示信息的抽象句法，但是没有限定其编码的方法。各种ASN.1编码规则提供了由ASN.1描述其抽象句法的数据的值的传送语法（具体表达）。标准的ASN.1编码规则有基本编码规则（BER，Basic Encoding Rules）、规范编码规则（CER，Canonical Encoding Rules）、唯一编码规则（DER，Distinguished Encoding Rules）、压缩编码规则（PER，Packed Encoding Rules）XML编码规则（XER，XML Encoding Rules）。\n 很显然，这种编码方法非常多。但是不要慌，大部分密码相关标准用到的编码方式都是BER/CER/DER，而后面两种则是对BER增加限制后的产物。至于PER/XER，至少在笔者目前工作中还没有接触到过，本文就不进行介绍了。\n为什么要把前三者归为一类呢，原因很简单，这三种编码方式是一种典型TLV的编码方法。TLV:Type-Length-Value, 是一种各类通讯协议中都非常常见的编码手段，他将一段数据分解使用Type描述了数据类型，用Length描述的数据长度，最后的Value表示了真正的data。其优点也非常明显，他可以将一段数据以二进制的格式编码，大量压缩了编码导致的报文体积膨胀的消耗，同时由于编码简单，解析速度也非常迅速。其结构很简单，通常如下：\nType | Length | Value\n以一个手机号码的编码为例18570917612：\n先看Type，假设用一个字节表示Type，如0x00表示手机号码，0x01表示固定电话号码，0x02表示传真号等等。当然此时还可以区分国家号、区号等等，都可以通过Type进行拓展，这里我们简单只考虑号码的类型。那显然可以编码为0x00, 编码的类型通过也称为Tag。\nLength就比较简单，通常标识字节数，而手机号码通常是使用ASCII码来标识，则每一个手机号码数字被编码为一个字节，总计就是11，长度被编码为0x0B.\n最后Value就是数据主体，使用ASCII编码则为：0x31 0x38 0x35 0x37 0x30 0x39 0x31 0x37 0x36 0x31 0x32\n最终这个手机号码将被编码为(去掉0x，直接看真实的二进制下表示)：\n   Tag Length Value     00 0B 31 38 35 37 30 39 31 37 36 31 32    当然，TLV是支持嵌套的，即Value同样是一个TLV编码的数据。后面也将会看到。\nX.690 既然ASN.1是一个通用的，和通信与密码强相关的编码记法，当然是需要一个明确的标准。而X.690是当前比较公认的标准。主要也是定义了BER/CER/DER这三种编码格式。下文的解析也是遵循该标准的(08/2015)版本 。\nBER 作为基础编码规则，我们首先学习它。BER通常把一个字节叫做Octets，而从低到高的比特位分别被叫做bit1 - bit8，和通常计算机对于最低比特称作bit0略有不同。\n先贴一下之前的X.509证书, 用于后文实例解析中的对比:\nCertificate: Data: Version: 3 (0x2) Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT Subject: C = US, ST = California, L = Mountain View, O = Google LLC, CN = www.google.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:bc:1c:aa:96:6f:6f:99:48:79:56:61:4b:7f:ff: dc:39:08:3a:d4:4d:e2:d8:87:80:af:3d:18:5e:71: 2d:ce:09:70:57:39:38:5f:2a:ee:a8:35:f4:3a:86: 86:5a:1d:c7:31:32:1b:8d:ac:d0:46:ad:c3:fc:a5: d3:18:36:68:ab ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Authority Information Access: OCSP - URI:http://ocsp.pki.goog/gts1o1core CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt X509v3 Subject Alternative Name: DNS:www.google.com X509v3 Certificate Policies: Policy: 2.23.140.1.2.2 Policy: 1.3.6.1.4.1.11129.2.5.3 X509v3 CRL Distribution Points: Full Name: URI:http://crl.pki.goog/GTS1O1core.crl CT Precertificate SCTs: Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 5E:A7:73:F9:DF:56:C0:E7:B5:36:48:7D:D0:49:E0:32: 7A:91:9A:0C:84:A1:12:12:84:18:75:96:81:71:45:58 Timestamp : Aug 26 09:14:24.417 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:20:77:F3:D6:8B:51:4F:88:71:16:73:ED:36: 2F:64:F4:77:3E:92:D3:CE:97:1F:1C:53:FA:4E:FB:5B: D7:0A:4C:D6:02:21:00:9F:B9:FE:F1:F3:1C:0D:CF:20: 30:B1:1C:0A:01:65:AD:67:90:1F:B5:33:90:8D:49:4D: 2B:ED:1D:90:28:A1:6B Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 07:B7:5C:1B:E5:7D:68:FF:F1:B0:C6:1D:23:15:C7:BA: E6:57:7C:57:94:B7:6A:EE:BC:61:3A:1A:69:D3:A2:1C Timestamp : Aug 26 09:14:24.367 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:21:00:F4:67:8E:8B:ED:3F:B2:D4:EA:72:EB: 53:F1:52:57:98:D6:63:0E:C0:6B:68:46:CE:F3:AD:25: 52:AD:12:83:27:02:20:05:CA:04:76:D6:4F:2A:E5:D3: 96:85:79:A2:F3:85:29:9E:89:30:00:A7:20:99:2D:F7: C9:56:3C:4E:5D:5C:CF Signature Algorithm: sha256WithRSAEncryption 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: 32:99:29:f8:13:6b:72:af:16:79:63:d3:3f:76:56:57:19:78: 91:86:f8:7a:ee:26:67:98:dc:5e:e4:00:f5:87:a0:01:21:9d: cf:e5:9f:02:f3:2a:fd:0e:fd:78:af:2e:20:29:77:35:e2:c6: 30:ee:ef:be:f2:bb:26:02:52:a2:2d:27:78:ce:a9:8e:39:d0: a2:74:90:11:c5:92:58:3c:7a:88:1d:c7:5a:56:d4:1a:01:00: c3:9d:98:6f:41:02:1f:cb:e2:4d:99:6a:5c:d9:0f:c0:88:08: 15:c5:26:90:a2:a4:15:f6:71:e2:fe:a9:98:dc:40:2a:71:c1: 11:aa:00:73:52:24:74:aa:ae:72:55:2f:0d:31:b7:00:bb:1f: 87:4d:f5:05:ad:ff:7a:93:e0:cf:86:a5:1d:1b:7d:41:fa:10: 99:3b:00:7c:c9:dd:a9:52:5c:06:72:86:96:e7:05:97:77:12: 2f:26:bb:dc:65:c4:48:4d:9c:82:4b:7d:69:27:3f:85:00:2e: b1:5d:8d:dc  Identifier Octets 标识字节，可以理解为TLV中的Type。BER中将其分解成三段如下：\n1 2 3 4  * Bit 8 7 6 5 1 * +-------+-----+------------+ * | Class | P/C | Tag number | * +-------+-----+------------+   先看Class段，两个比特bit7-bit8，定义了四种类型：\n   Class Bit 8 Bit 7     Universal (0x00) 0 0   Application (0x40) 0 1   Context-specific (0x80) 1 0   Private (0xC0) 1 1    其中Universal是最常用的，属于Native的类型都将属于该段。而Context-specific也比较多见，密码学相关编码较多。通常当字段的类型非标准类型时都将使用该类型作为Identifier Octets的高位。以X.509证书中标准ASN.1版本号为例，Type被描述为A0：\n1 2 3 4  Version ::= INTEGER { v1(0), v2(1), v3(2) } version [0] EXPLICIT Version DEFAULT v1, /* Tag is \u0026#39;A0\u0026#39;: 0x80 | 0x20 | 0 */   此时A0的高位比特即为1和0，对应Context-specific。Context-specific它只能使用在SEQUENCE、SET和CHOICE类型的组件中，而且可以看到有一个关键字EXPLICIT以及对应的关键字IMPLICIT用于配合使用。而中括号中间的0则标识了对应的Tag number, 注意该数字仅在该上下文中(即单独SEQUENCE、SET和CHOICE组成的内部)生效。\n其他两种使用很少，也不推荐使用，多用于某些应用和公司内部的私有协议，此处不讨论了。\n再看看P/C, 对应1个比特：0 = Primitive(0x00); 1 = Constructed(0x20)。通常该位标识后续的Value是一个原子值还是一个嵌套的TLV. 例如INTEGER只能为Primitive，而SEQUENCE 一定是Constructed；当然也有Both允许的类型，如BIT STRING，可能是嵌套的也可能是原子的，不过显然嵌套的情况比较少，X.509证书暂时没找到相关例子。\n最后是最关键的Tag Number，使用了5个比特(bit1 - bit5)标识了最基本的原生类型，下表将解释常用的类型：\n   Name Permitted Construction Decimal Tag number Hexadecimal Tag number     End-of-Content (EOC) Primitive 0 0   BOOLEAN Primitive 1 1   INTEGER Primitive 2 2   BIT STRING Both 3 3   OCTET STRING Both 4 4   NULL Primitive 5 5   OBJECT IDENTIFIER Primitive 6 6   UTF8String Both 12 C   SEQUENCE and SEQUENCE OF Constructed 16 10   SET and SET OF Constructed 17 11   PrintableString Both 19 13   T61String Both 20 14   IA5String Both 22 16   UTCTime Both 23 17   GeneralizedTime Both 24 18   UniversalString Both 28 1C   BMPString Both 30 1E    具体的在X.509所需的编码字段将在实例中进行讲解。需要特别提到的EOC通常用在TLV串结尾标识数据已结束，属于一种可选编码方式，X.509中未使用。\n一个问题在于，此时Tag Number是无法超过0x0F的，而根据X.690标准实际上是有超过0x0F种Tag的，此时该如何编码呢？ASN.1使用0b11111作为Tag Number进行拓展，此时接下来的字节为真实的Tag Number，其中当最高位比特bit8为标识位，0标识为最后一个字节，1标识为中间字节，最后进行比特串的拼接，大端编码。类似下面的标识：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  * Leading Octet Bit 8 7 6 5 1 * +-------+-----+---------+ * | Class | P/C | 0b11111 | * +-------+-----+---------+ * 2nd Octet Bit 8 7 1 * +---+------------+ * | 1 | 0bxxxxxxx | * +---+-----+------+ ... * Last Octet Bit 8 7 1 * +---+------------+ * | 0 | 0bxxxxxxx | * +---+-----+------+ * Example for tag number 0x80: 0b10000000 * binary : [class:P/C:11111][1:0000001][0:0000000] for 3-byte   不过这种情况比较少见，在密码学标准中基本不会出现。\nLength octets 标识了编码内容的长度，属于比较简单的字段。与Tag Number编码方式类似，也被区分为了短模式与长模式：\n短模式下，bit8将为0，剩下的比特将作为实际数据长度。例如上面的手机号码长度11，将被编码为0b00001011。显然这种情况下长度是有限的：不能超过127(0b01111111)个byte.\n超过127之后将使用长模式：第一个字节的最高比特bit8置1，剩下的比特将指示该长度将由多少个字节来表示，同样的将通过大端编码的方式形成一串比特串进行编码。以上一篇X.509的证书签名段为例：\n/* * Type 0x03 : Bit String * Length: * 1st Octet: 0b10000002(0x82): bit-8 = 1 stands for long form; * bit1-7 = 0x2 encode the number of subsequent octets in the length octets, bit-7 is the most significant bit; Note: 0xFF can\u0026#39;t be used. * 2nd and 3rd Octet: bit 8 of the first subsequent octet is the most significant bit; * 0b00000001|00000001(0x01 0x01) for content length 0x101. */ signatureValue BIT STRING (Encoded as: [03] [82 01 01] [Signature]) 这里有个疑问：为啥RSA-2048为啥出来需要0x101个字节，多了一个字节啊。其实看一下就知道，编码的最高字节为0x00。至于这个的用法如何将在后续对不同Type的内容做编码时讲到。\n此外ASN.1提供了另外一种灵活的编码方式：即当Length被编码为0b10000000(0x80)时，长度被定义为不定模式(Indefinite)，后续Contents octets的尾部则必须加上上节提到的EOC，标识内容结束。\nContents octets 编码内容，这个部分将对X.509系列所需常用的类型编码方式进行详述\nEOC EOC模式一定为以下格式:\n   Identifier Length Contents     0x00 0x00 NULL    Boolean 布尔类型非常简单，Type的Class为Universal ，非嵌套，Tag number为0x1, Length为0x1。当Value字节为全0时记为false, 否则为true；下表表示一种布尔类型的编码，共3字节。\n   Identifier Length Contents     0x01 0x01 0xFF    X.509中有一个标准的拓展字段用了该布尔类型：\n/* X509v3 Basic Constraints: critical CA:FALSE */ /* encode: */ [01] [01] [FF] Integer Type的Class为Universal ，非嵌套，Tag number为0x02, Length为编码的字节长度，content为大数编码的整数，即第一个字节的最高比特为MSB，直接以上一章证书中间的serialNumber, 很简单，标识了一个大数88比特、11字节的大数：\n1 2 3 4 5 6  CertificateSerialNumber ::= INTEGER serialNumber CertificateSerialNumber /* Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f */ [02] [11] [00 BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F]   其中数字的比较与普通数字比较没有差别，如上述数字与[02] [10] [BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F]比较是相等的。\nBitstring Type的Class为Universal，可以为primitive也可以为constructed. Tag number为0x3. Length为编码的字节长度；其content的组成，第一个字节将编码了最后一个字节中填充的0bit的个数, 故解码时也应该去除掉最后一个自己的对应比特数的0，该字节被称为Unused bits；通常可以使用多个primitive的Bitstring分段，组成一个constructed的Bitstring, 此时Length可以设置为不定长模式0x80. 通常不需要使用construct模式。看下面的例子：\n/* If of type BIT STRING, the value \u0026#39;0A3B5F291CD\u0026#39;H */ /* Primitive mode encode: 04 stands for the last byte include 4 bit padding */ [03] [07] [[04] 0A 3B 5F 29 1C D0] /* * Constructed mode encode: 23 stands for 0x00(class) | 0x20(constructed) | 0x03(Tag number) * The Bitstring consists of 2 sub-bitstrings: 0A3B, first byte 00 stands for 0 padding bits; * And 5F291CD0, first byte 04 last byte include 4 bit padding. */ [23] [0C] [[[03] [03] [[00] 0A 3B]] [[03] [05] [[04] 5F 29 1C D0]]] 解释一下X.509里签名段的编码：\nsignatureValue BIT STRING /* * Signature Algorithm: sha256WithRSAEncryption * 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: * 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: * 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: * ... */ /* The first byte 00 stands for 0 padding bits */ Encoded as: [03] [82 01 01] [[00] 7A 9A 76 80 C9 39 13 8E 60 B1 93 5D ...] Octetstring 与Bitstring基本类似，差别在于Tag number为0x3，且因为最小以字节为单位，无需第一个字节标识填充信息。通常在X.509使用在Extension中，标准下ASN.1的extnValue格式为Octetstring，同时由于此类型支持其他类型的嵌套，以之前证书authorityKeyIdentifier的extnValue为例：\n1 2 3 4 5 6 7 8  Extension ::= SEQUENCE { extnID OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING } /* X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B */ [04] [18] [30 16 80 14 98 D1 F8 6E 10 EB CF 9B EC 60 9F 18 90 1B A0 EB 7D 09 FD 2B]   NULL Type的Class为Universal，primitive. Tag number为0x5，Length一定为0. 不需要Content，即通常编码固定为05 00; X.509中在AlgorithmIdentifier会出现，如本文的例子中：\n1 2 3 4 5 6  AlgorithmIdentifier ::= SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINED BY algorithm OPTIONAL } /* parameters == NULL encoded in {} */ [30] [0D] [[[06] [09] [2A 86 48 86 F7 0D 01 01 0B]] {[05] [00]}]   Sequence/Sequence of 许多使用ASN.1定义的协议都是基于该类型定义的. Type的Class为Universal, Constructed, Tag number为0x10. 故Identifier通常为0x30。通过上一节就能看到，其实整张X.509证书就是一个sequence，它由 Version, CertificateSerialNumber, AlgorithmIdentifier等多个类型的字段组合而成。例子可以参考上面的AlgorithmIdentifier；同时可以看一下整张证书的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13  Certificate ::= SEQUENCE { tbsCertificate TBSCertificate, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING } /* Cert: length = 0x4C8 */ /* * TBSCertificate and signatureAlgorithm are also SEQUENCEs with length 0x3B0 and 0x0D * signatureValue is BIT STRING with length 0x101, bits padding number is 0 */ [30] [82 04 C8] [[[30] [82 03 B0] [A0 03 02 01 02 02 11 00 ...]] [[30] [0D] [30 0D 06 09 2A 86 48 86 ...]] [[03] [82 01 01] [[00] 7A 9A 76 80 C9 39 13 8E 60 B1 93 5D 99 49 1B 71 ...]]]   注意：证书中被签名的字段需要忽略掉Certificate编码中的Identifier和Length，本例中被签名段将忽略掉前两个中括号的内容, 即第三个中括号中的第一个中括号[[30] [82 03 B0] [A0 03 02 01 02 02 11 00 ...] 为被签名段.\nSet/Set of Type的Class为Universal, Constructed, Tag number为0x11. 故Identifier通常为0x31。与Sequence基本一致，区别在于此类型在定义、解析和编码时无需强制顺序，没有前后顺序，各成员体等价。在X.509中Name类型包含set类型.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  Name ::= CHOICE { -- only one possibility for now -- rdnSequence RDNSequence } RDNSequence ::= SEQUENCE OF RelativeDistinguishedName RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue AttributeTypeAndValue ::= SEQUENCE { type AttributeType, value AttributeValue } AttributeType ::= OBJECT IDENTIFIER AttributeValue ::= ANY -- DEFINED BY AttributeType /* The encoding of a choice value shall be the same as the encoding of a value of the chosen type. */ /* * Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 * Sequence { *\tSet { *\tSequence { *\ttype OBJECT IDENTIFIER, value AttributeValue *\t}, *\tSequence { *\ttype OBJECT IDENTIFIER, value AttributeValue *\t}, ... }, *\tSet { ... } * } */ /* Sequence 30 { set 31 { Sequence 30 {OID 06, Printable String 13 }} ... } */ [30] [42] [[[31] [0B] [[30] [09] [[[06] [03] [55 04 06]] [[13] [02] [55 53]]]]] ... ]   UTCTime Type的Class为Universal, Primitive和Constructed都可能, 通常为Primitive，Tag number为0x17。其编码为ascii码下的YYMMDDhhmm[ss]Z或YYMMDDhhmm[ss](+|-)hhmm。\nYY表示年，其中如果YY \u0026lt; 50则年份为20YY年，否则为19YY年，如YY = 50则标识1950年；MM表示月份，DD表示日；hhmmss表示时分秒，其中ss是可选项。\nZ则标识Zulu时间，而(+|-)hhmm则标识了与格林威治标准时间的时差, +标识标准时间提前，-标识推后。Z与时差不能共用。\n看看X.509中的例子：\n/* Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT */ /* ascii code, print as 200826081423Z */ [17] [0D] [32 30 30 38 32 36 30 38 31 34 32 33 5A] /* ascii code, print as 201118081423Z */ [17] [0D] [32 30 31 31 31 38 30 38 31 34 32 33 5A]  Restricted character string 标识一组收到限制的string类型，如NumericString/VisibleString/PrintableString等. X.509最主要使用的是PrintableString。以Set例子中的Name里可打印字符US为例，identifier = 0x13：\n /* * PrintableString * length = 2 * \u0026#34;US\u0026#34; : 0x55 0x53 */ [13] [02] [55 53] Object identifier 简称OID，是一个用来编码特殊意义字段的标准定义ID，属于ITU-T和ISO/IEC共同开发的一种广泛使用的机制来命名任何类型的对象、概念或事物，具有一个全局明确的名称和一个长生命周期的名称。\nType的Class为Universal, Primitive, Tag number为0x6.\n先看该OID解码的格式，通常为a.b.c.d....(被称为 dot notation). 其中每一个.将分割一个特殊意义的字符。\n a中比较典型的有iso(1)和joint-iso-itu-t(2) b中比较典型的有member-body(2); identified-organization(3); ds(5); country(16) c在X.509典型有certificateExtension(29); attributeType(4) d在X.509典型有countryName(6); organizationName(10)  当然还能延续。其中最典型的OID是算法ID，以上面证书为例子：sha256WithRSAEncryption的OID为1.2.840.113549.1.1.11; 对应{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha256WithRSAEncryption(11)}.\n具体查询OID含义可以查看网站http://oid-info.com，可以查到大部分符合标准定义下的OID的详细描述，以及每个OID下的child OID，非常方便。具体实现X.509功能相关所需的OID定义可以在下一部分的libmbedtls源码分析中看到oid.h中的定义。\n其content编码方式非常特殊：\n a和b将作为第一个字节进行编码，编码结果为：a * 40 + b。举个例子2.5的编码结果为0x55 = 85 = 2 * 40 + 5。 剩下的每个字节的编码相同，非常类似超过30之后的Tag number的编码方式：首先被分割为最少数量的没有头零数字的7位数字. 这些数字以big-endian格式进行组织, 并且一个接一个地组合成字节. 编码的最后一个字节j将为0,其他所有字节的最高位(位8)都为1。举个例子840 = 0b1101001000，编码为0b0000110 | 0b1001000，最后补充高位标记位0b10000110 | 0b01001000, 即0x86 0x48  看X.509中对sha256WithRSAEncryption的编码：\n/* 1.2.840.113549.1.1.11 */ /* * 0x2A = 42 = 1 * 40 + 2: \u0026#34;1.2\u0026#34; * 840 : 0x86 0x48 * 113549 = 0b (0000110 | 1110111 | 0001101): 0b10000110 0b11110111 0b00001101 = 0x86 0xF7 0x0D * Remained is simple encode as short integer. */ [06] [09] [2A 86 48 86 F7 0D 01 01 0B]  完成基础类型的学习，我们返回去看对于X.509 Version的编码就好理解了：\n1 2 3 4 5 6 7 8 9 10  version [0] EXPLICIT Version DEFAULT v1, Version ::= INTEGER { v1(0), v2(1), v3(2) } /* * EXPLICIT implies a context-specific(0x80) and construted by a integer; * [0] stands for the tag number; * so identifier: \u0026#39;A0\u0026#39;: 0x80 | 0x20 | 0 , length: 0x03, content: type integer; * Interger tag 0x02, length 0x01, content 0x02; */ [A0] [03] [[02] [01] [02]]   完成基础的BER编码规则的学习之后，CER和DER就很好理解了，他们对BER多加了一些可用性的限制。先看两者共有的与X.509相关的限制。\nCommon Restrictions  Bool FALSE所有比特应被编码1，即该字节为0xFF Bitstring不应该出现需要补充比特的情况，即Unused bits应该为0 Sequence/Set中被设置为默认值的成员不应编码 UTCTime仅有Z模式  CER  identifier为Construted时，长度应该指定为indefinite(此处有疑问，.cer格式下的证书constructed也有使用definite长度的) identifier为primitive时，长度应该指定为最短字节：例如长度0x10在BER中可以编码为0x81 0x10, CER增加了该限制  DER  长度只能使用definite模式 bitstring, octetstring 和 restricted character string不能使用construted Set中的组成值需与ASN.1定义的顺序一致  基本上看完此文就可以化身人肉解码器了，最后推荐一个工具：ASN.1 Editor, 很好用。\n将着重分析X.509的编码解码在libmbedtls中的源码分析，相当硬核。\n","description":"X.509证书格式介绍","id":5,"section":"posts","tags":["OpenSSL"],"title":"X.509系列（一）：X.509 v3格式下的证书","uri":"https://summersummer3.github.io/posts/x509_2/"},{"content":"问题来源 OpenSSL Engine是啥，在这个地方就不细说了，资料很多，可以看看知乎这篇中文文档:\nhttps://zhuanlan.zhihu.com/p/70444766\n英文文档:\nhttps://wiki.openssl.org/index.php/Creating_an_OpenSSL_Engine_to_use_indigenous_ECDH_ECDSA_and_HASH_Algorithms#Author\n直接进入正题，我们首先查看一个OpenSSL Engine的例子：\nhttps://github.com/nibrunie/OSSL_EngineX\n直接查看bind代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static int bind(ENGINE* e, const char* id) { int ret = 0; if (!ENGINE_set_id(e, engine_id)) { fprintf(stderr, \u0026#34;ENGINE_set_id failed\\n\u0026#34;); goto end; } if (!ENGINE_set_name(e, engine_name)) { printf(\u0026#34;ENGINE_set_name failed\\n\u0026#34;); goto end; } if (!ENGINE_set_digests(e, digest_selector)) { printf(\u0026#34;ENGINE_set_digest failed\\n\u0026#34;); goto end; } ret = 1; end: return ret; } IMPLEMENT_DYNAMIC_BIND_FN(bind) IMPLEMENT_DYNAMIC_CHECK_FN()   可以看到OpenSSL去加载Engine的动态库时，需要动态库去调用 IMPLEMENT_DYNAMIC_BIND_FN 完成engine绑定初始化。\n基本上所以教你写engine的教程到这就结束了，但是内部到底是怎么要关联上这个函数，并且触发上面的bind函数的呢？我们先来看看这个宏的具体定义：\n1 2 3 4 5 6 7 8 9 10 11 12  \\# define IMPLEMENT_DYNAMIC_BIND_FN(fn) \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \\ if (ENGINE_get_static_state() == fns-\u0026gt;static_state) goto skip_cbs; \\ CRYPTO_set_mem_functions(fns-\u0026gt;mem_fns.malloc_fn, \\ fns-\u0026gt;mem_fns.realloc_fn, \\ fns-\u0026gt;mem_fns.free_fn); \\ skip_cbs: \\ if (!fn(e, id)) return 0; \\ /* 调用了上面例子中的bind函数 */ return 1; }   可以看到此处定义了函数bind_engine，他会去执行用宏包裹住的函数，以完成初始化。然而你去搜索这个函数在OpenSSL中调用你一定会很失望，肯定没有你想要的结果。果然不是这么简单的，又是什么钩子挂在了什么ctx上吧，应该也不难。\n我找了不少资料，基本没发现啥靠谱的分析，没办法自己看源码吧。结果经过分析，我深刻的理解了OpenSSL的魔鬼调用，钩子的挂载可以说是很魔幻。此处源码分析基于目前的主线master，应该也是未来OpenSSL 3.0的架构了。\n至于Engine是怎么设置上重置后的密码算法的，将在后续更新。\n从加载Engine的main函数分析起 还是上面的例子，我们查看执行engine加载的可执行程序的源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int main(void) { // initializing OpenSSL library  OPENSSL_load_builtin_modules(); ENGINE_load_dynamic(); // building OpenSSL\u0026#39;s configuration file path  char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { fprintf(stderr, \u0026#34;OpenSSL failed to load required configuration\\n\u0026#34;); ERR_print_errors_fp(stderr); return 1; } ENGINE* eng = ENGINE_by_id(\u0026#34;engineX\u0026#34;); if(NULL == eng) { printf(\u0026#34;failed to retrieve engine by id (mppa)\\n\u0026#34;); return 1; } printf(\u0026#34;EngineX has been successfully loaded \\n\u0026#34;); ... }   可以看到我们这个例子是从一个cnf配置文件去加载对应的engine的，这里提一句，加载engine有几个方式，如命令行加载，手动代码加载等。这里用配置文件加载做例子是因为这个场景更加接近实际业务场景，而且流程基本涵盖全流程，值得源码去分析。接下来我们按照调用顺序来分析这样一个漫长的调用过程。\nOPENSSL_load_builtin_modules 第一个函数，初始化了一个默认的conf_module, 且名字叫做\u0026rsquo;engines\u0026rsquo;。直接看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void OPENSSL_load_builtin_modules(void) { ... /* 我们其他的都不重要，直接看这个和Engine相关的 */ #ifndef OPENSSL_NO_ENGINE  ENGINE_add_conf_module(); #endif  ... } void ENGINE_add_conf_module(void) { CONF_module_add(\u0026#34;engines\u0026#34;, int_engine_module_init, int_engine_module_finish); }   来到我们的第一个大坑，OpenSSL的动态配置文件加载，但这里我们不需要细致了解，先简单分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  int CONF_module_add(const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { if (module_add(NULL, name, ifunc, ffunc)) return 1; else return 0; } /* 重要的结构体与全局变量 */ static STACK_OF(CONF_MODULE) *supported_modules = NULL; static STACK_OF(CONF_IMODULE) *initialized_modules = NULL; struct conf_module_st { /* DSO of this module or NULL if static */ DSO *dso; /* Name of the module */ char *name; /* Init function */ conf_init_func *init; /* Finish function */ conf_finish_func *finish; /* Number of successfully initialized modules */ int links; void *usr_data; }; typedef struct conf_module_st CONF_MODULE; static CONF_MODULE *module_add(DSO *dso, const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { CONF_MODULE *tmod = NULL; /* 若supported_modules为空， 则初始化此全局变量，即堆栈的初始化 */ if (supported_modules == NULL) supported_modules = sk_CONF_MODULE_new_null(); if (supported_modules == NULL) return NULL; /* 申请配置文件模块结构体conf_module_st的空间 */ if ((tmod = OPENSSL_zalloc(sizeof(*tmod))) == NULL) { CONFerr(CONF_F_MODULE_ADD, ERR_R_MALLOC_FAILURE); return NULL; } /* * 此处第一次调用，dso为NULL； * dso = dynamic shared object, 可以理解为是一个OpenSSL去加载动态库的结构体； */ tmod-\u0026gt;dso = dso; /* 此处记住，将初始化一个叫\u0026#34;engines\u0026#34;的conf_module */ tmod-\u0026gt;name = OPENSSL_strdup(name); /* 配置文件init函数， 此处即int_engine_module_init。这个函数是关键 */ tmod-\u0026gt;init = ifunc; /* 配置文件finish函数， 此处即int_engine_module_finish */ tmod-\u0026gt;finish = ffunc; if (tmod-\u0026gt;name == NULL) { OPENSSL_free(tmod); return NULL; } /* 将这个的conf_module结构体入栈进supported_modules这个全局变量栈中 */ if (!sk_CONF_MODULE_push(supported_modules, tmod)) { OPENSSL_free(tmod-\u0026gt;name); OPENSSL_free(tmod); return NULL; } return tmod; }   此处有一个OpenSSL的一个知识点，OpenSSL中可以定义任意类型的安全栈，并且生成操作这个类型栈的函数族。例如有一个结构体叫XX，则可以通过DEFINE_STACK_OF(XX)这个宏来定义XX结构体的栈和函数族，通过STACK_OF(XX)来声明一个栈。事实上，当我们看OpenSSL源码时看到sk_这种前缀的都是堆栈操作，而且是搜索不到实现的 (1.0.2版本应该可以找到，之后的版本都泛化了，代码写的秀，看代码的自闭)。\n详见官方文档：https://www.openssl.org/docs/man1.1.0/man3/DEFINE_STACK_OF.html\n此处有两个栈操作: 初始化时supported_modules为空，所以将调用sk_CONF_MODULE_new_null先建立上一个空容器。之后sk_CONF_MODULE_push使上面初始化的的CONF_MODULE入栈，之后想要取到这个module则需要通过supported_modules这个全局栈来取。\n此处多提一句，OpenSSL还有一个类似的结构体LHASH，它是OpenSSL内部的哈希表，如果这篇文章有下我们应该会碰到它，直接理解成是一个kv_map就好。所有lh_前缀开头的也都是哈希表操作。\nENGINE_load_dynamic 第二个函数，比较绕，简单理解就是：初始化了一个engine, 名字叫做dynamic，OpenSSL用这个engine来动态加载别的engine\u0026hellip;\n顺便提一句，ENGINE_load_dynamic 在1.1.x版本已经废弃了，统一都是调用OPENSSL_init_crypto这个函数，opts = OPENSSL_INIT_ENGINE_DYNAMIC。这又是OpenSSL非常恶心的地方了，版本兼容可以说是相当emmmmmmmm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \\# define ENGINE_load_dynamic() \\ OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_DYNAMIC, NULL) int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings) { ... /* * RUN_ONCE是多线程时需要关心的，我们这里不关心，就等于调用ossl_init_engine_dynamic * 最后一波宏展开，调用的是 engine_load_dynamic_int 这个函数 */ if ((opts \u0026amp; OPENSSL_INIT_ENGINE_DYNAMIC) \u0026amp;\u0026amp; !RUN_ONCE(\u0026amp;engine_dynamic, ossl_init_engine_dynamic)) return 0; ... } void engine_load_dynamic_int(void) { ENGINE *toadd = engine_dynamic(); /* 这命名真是绝了Orz */ if (!toadd) return; ENGINE_add(toadd); /* * If the \u0026#34;add\u0026#34; worked, it gets a structural reference. So either way, we * release our just-created reference. */ ENGINE_free(toadd); /* * If the \u0026#34;add\u0026#34; didn\u0026#39;t work, it was probably a conflict because it was * already added (eg. someone calling ENGINE_load_blah then calling * ENGINE_load_builtin_engines() perhaps). */ ERR_clear_error(); }   engine_dynamic 两个核心函数，第一个 engine_dynamic 新建了一个id叫做'dynamic'的engine，挂上了这个engine的具体处理函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static ENGINE *engine_dynamic(void) { /* OpenSSL申请结构体空间经常使用的xx_new */ ENGINE *ret = ENGINE_new(); if (ret == NULL) return NULL; if (!ENGINE_set_id(ret, engine_dynamic_id) || !ENGINE_set_name(ret, engine_dynamic_name) || !ENGINE_set_init_function(ret, dynamic_init) || !ENGINE_set_finish_function(ret, dynamic_finish) || !ENGINE_set_ctrl_function(ret, dynamic_ctrl) || !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) || !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) { ENGINE_free(ret); return NULL; } return ret; }   我们扫一眼ENGINE结构体，首先要有一个概念，ENGINE_set_xx 就是去设置这个结构体的相应字段，所以可以记录一下这个结构体被初始化成啥样了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct engine_st { const char *id; const char *name; const RSA_METHOD *rsa_meth; const DSA_METHOD *dsa_meth; const DH_METHOD *dh_meth; const EC_KEY_METHOD *ec_meth; const RAND_METHOD *rand_meth; /* Cipher handling is via this callback */ ENGINE_CIPHERS_PTR ciphers; /* Digest handling is via this callback */ ENGINE_DIGESTS_PTR digests; /* Public key handling via this callback */ ENGINE_PKEY_METHS_PTR pkey_meths; /* ASN1 public key handling via this callback */ ENGINE_PKEY_ASN1_METHS_PTR pkey_asn1_meths; ENGINE_GEN_INT_FUNC_PTR destroy; ENGINE_GEN_INT_FUNC_PTR init; ENGINE_GEN_INT_FUNC_PTR finish; ENGINE_CTRL_FUNC_PTR ctrl; ENGINE_LOAD_KEY_PTR load_privkey; ENGINE_LOAD_KEY_PTR load_pubkey; ENGINE_SSL_CLIENT_CERT_PTR load_ssl_client_cert; const ENGINE_CMD_DEFN *cmd_defns; int flags; /* reference count on the structure itself */ CRYPTO_REF_COUNT struct_ref; /* * reference count on usability of the engine type. NB: This controls the * loading and initialisation of any functionality required by this * engine, whereas the previous count is simply to cope with * (de)allocation of this structure. Hence, running_ref \u0026lt;= struct_ref at * all times. */ int funct_ref; /* A place to store per-ENGINE data */ CRYPTO_EX_DATA ex_data; /* Used to maintain the linked-list of engines. */ struct engine_st *prev; struct engine_st *next; }   整理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  static const char *engine_dynamic_id = \u0026#34;dynamic\u0026#34;; static const char *engine_dynamic_name = \u0026#34;Dynamic engine loading support\u0026#34;; static const ENGINE_CMD_DEFN dynamic_cmd_defns[] = { {DYNAMIC_CMD_SO_PATH, \u0026#34;SO_PATH\u0026#34;, \u0026#34;Specifies the path to the new ENGINE shared library\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_NO_VCHECK, \u0026#34;NO_VCHECK\u0026#34;, \u0026#34;Specifies to continue even if version checking fails (boolean)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_ID, \u0026#34;ID\u0026#34;, \u0026#34;Specifies an ENGINE id name for loading\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LIST_ADD, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_LOAD, \u0026#34;DIR_LOAD\u0026#34;, \u0026#34;Specifies whether to load from \u0026#39;DIR_ADD\u0026#39; directories (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_ADD, \u0026#34;DIR_ADD\u0026#34;, \u0026#34;Adds a directory from which ENGINEs can be loaded\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LOAD, \u0026#34;LOAD\u0026#34;, \u0026#34;Load up the ENGINE specified by other settings\u0026#34;, ENGINE_CMD_FLAG_NO_INPUT}, {0, NULL, NULL, 0} }; /* 加载动态engine时的命令 */ # define ENGINE_FLAGS_BY_ID_COPY (int)0x0004  ENGINE dynamic = {.id = engine_dynamic_id, .name = engine_dynamic_name, .init = dynamic_init, /* 空函数，直接return 0 */ .finish = dynamic_finish, /* 空函数，直接return 0 */ .ctrl = dynamic_ctrl, /* 最重要的函数，后文将分析如何调用到这来 */ .flags = ENGINE_FLAGS_BY_ID_COPY， .cmd_defns = dynamic_cmd_defns /*定义了dynamic这个engine ctrl下的合法cmd*/ .prev = NULL, .next = NULL /* 说明engine都是以双向链表形式管理 */ };   完成初始化后，将返回上这个new出来的ENGINE结构体。随后丢到ENGINE_add 里。\nENGINE_add 上面结构体分析其实已经可以看到，所有的engine都将以双向链表形式管理，链表建立简单粗暴，直接定义全局变量一头一尾，添加时就往尾巴加，搜索就从头结点开始搜索：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  static ENGINE *engine_list_head = NULL; static ENGINE *engine_list_tail = NULL; /* Add another \u0026#34;ENGINE\u0026#34; type into the list. */ int ENGINE_add(ENGINE *e) { int to_return = 1; /* 一些入参检查，omit */ ... /* 全局变量操作时需要加锁以支持多线程 */ CRYPTO_THREAD_write_lock(global_engine_lock); /* 核心函数，将刚刚new出来的dynamic加入全局链表中 */ if (!engine_list_add(e)) { ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR); to_return = 0; } CRYPTO_THREAD_unlock(global_engine_lock); return to_return; } static int engine_list_add(ENGINE *e) { int conflict = 0; ENGINE *iterator = NULL; if (e == NULL) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER); return 0; } /* 从链表头开始迭代 */ iterator = engine_list_head; /* 直接遍历到尾部查看有没有重id的情况，重id直接报错退出 */ while (iterator \u0026amp;\u0026amp; !conflict) { conflict = (strcmp(iterator-\u0026gt;id, e-\u0026gt;id) == 0); iterator = iterator-\u0026gt;next; } if (conflict) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } if (engine_list_head == NULL) { /* We are adding to an empty list. */ if (engine_list_tail) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* engine_list为空的话则链表头为新建的engine */ engine_list_head = e; e-\u0026gt;prev = NULL; /* * The first time the list allocates, we should register the cleanup. */ engine_cleanup_add_last(engine_list_cleanup); } else { /* We are adding to the tail of an existing list. */ if ((engine_list_tail == NULL) || (engine_list_tail-\u0026gt;next != NULL)) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* 将新engine加到队尾的后面 */ engine_list_tail-\u0026gt;next = e; e-\u0026gt;prev = engine_list_tail; } /* * Having the engine in the list assumes a structural reference. */ e-\u0026gt;struct_ref++; engine_ref_debug(e, 0, 1); /* 将队尾指向新engine */ engine_list_tail = e; e-\u0026gt;next = NULL; return 1; }   这样，id为'dynamic'被加入了全局engine列表当中，被管理起来。\nCONF 我们这里对OpenSSL的动态配置conf不需要细致分析，随着代码分析即可。官方文档其实对conf格式讲解的很清楚，可以学习:\nhttps://www.openssl.org/docs/man1.1.1/man5/config.html\nEngine Configuration Module这个小节\n例子中conf文件 首先我们来看engineX例子中的conf是怎么写的：\nopenssl_conf = openssl_def [openssl_def] engines = engine_section [engine_section] engine_x = engine_x_section [engine_x_section] engine_id = engineX dynamic_path = ${ENV::PWD}/build/engine_ex.so default_algorithms = ALL init = 1 简单学习一下conf之后，我们之后这个配置文件核心的section就是engine_section，其中dynamic_path定义上了该engine共享库的路径。我们看看例子中是如何根据这个配置文件去加载对应的engine的\nCONF_modules_load_file 1 2 3 4 5 6 7 8  ... char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { ... } ...   CONF_modules_load_file是去加载配置并使能配置的接口，这里我们主要关心如何去根据配置文件去加载动态库，具体怎么完成配置文件解析的流程这里不讨论。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  int CONF_modules_load_file(const char *filename, const char *appname, unsigned long flags) { return CONF_modules_load_file_with_libctx(NULL, filename, appname, flags); } int CONF_modules_load_file_with_libctx(OPENSSL_CTX *libctx, const char *filename, const char *appname, unsigned long flags) { char *file = NULL; CONF *conf = NULL; int ret = 0; conf = NCONF_new_with_libctx(libctx, NULL); if (conf == NULL) goto err; if (filename == NULL) { file = CONF_get1_default_config_file(); if (file == NULL) goto err; } else { file = (char *)filename; } if (NCONF_load(conf, file, NULL) \u0026lt;= 0) { if ((flags \u0026amp; CONF_MFLAGS_IGNORE_MISSING_FILE) \u0026amp;\u0026amp; (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) { ERR_clear_error(); ret = 1; } goto err; } ret = CONF_modules_load(conf, appname, flags); err: if (filename == NULL) OPENSSL_free(file); NCONF_free(conf); if (flags \u0026amp; CONF_MFLAGS_IGNORE_RETURN_CODES) return 1; return ret; }   可以看到这里主要有三步操作NCONF_new_with_libctx、NCONF_load、CONF_modules_load，我们一个一个分析。\nNCONF_new_with_libctx 这个函数主要是初始化上了一个CONF结构体，同时将这个结构体的METHOD定义成了默认方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  /* 配置文件的method模板 */ struct conf_method_st { const char *name; CONF *(*create) (CONF_METHOD *meth); int (*init) (CONF *conf); int (*destroy) (CONF *conf); int (*destroy_data) (CONF *conf); int (*load_bio) (CONF *conf, BIO *bp, long *eline); int (*dump) (const CONF *conf, BIO *bp); int (*is_number) (const CONF *conf, char c); int (*to_int) (const CONF *conf, char c); int (*load) (CONF *conf, const char *name, long *eline); }; /* * 所有的 AA = BB 都会按照这个格式保存 * 如[openssl_def] engines = engine_section * 此时这个底下conf_st的哈希表中将保存上一份 * {.section = \u0026#34;openssl_def\u0026#34;, .name = \u0026#34;engines\u0026#34;, value = \u0026#34;engine_section\u0026#34;} */ typedef struct { char *section; char *name; char *value; } CONF_VALUE; struct conf_st { CONF_METHOD *meth; /* 动态配置的方法，这里使用default */ void *meth_data; LHASH_OF(CONF_VALUE) *data; /* 上文有提到的哈希表 */ unsigned int flag_dollarid:1; OPENSSL_CTX *libctx; }; /* * The following section contains the \u0026#34;New CONF\u0026#34; functions. They are * completely centralised around a new CONF structure that may contain * basically anything, but at least a method pointer and a table of data. * These functions are also written in terms of the bridge functions used by * the \u0026#34;CONF classic\u0026#34; functions, for consistency. */ CONF *NCONF_new_with_libctx(OPENSSL_CTX *libctx, CONF_METHOD *meth) { CONF *ret; if (meth == NULL) meth = NCONF_default(); ret = meth-\u0026gt;create(meth); if (ret == NULL) { CONFerr(0, ERR_R_MALLOC_FAILURE); return NULL; } /* 这个流程中是NULL，不需要分析 */ ret-\u0026gt;libctx = libctx; return ret; }   我们先看NCONF_default：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 标记上这些方法，相关定义后续会给出，且将会使用 */ static CONF_METHOD default_method = { \u0026#34;OpenSSL default\u0026#34;, def_create, def_init_default, def_destroy, def_destroy_data, def_load_bio, def_dump, def_is_number, def_to_int, def_load }; CONF_METHOD *NCONF_default(void) { return \u0026amp;default_method; }   第一个在default_method被使用的方法就是def_create, 很明显是去申请一块CONF结构体内存，之后调用def_init_default去初始化结构体 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  static CONF *def_create(CONF_METHOD *meth) { CONF *ret; ret = OPENSSL_malloc(sizeof(*ret)); if (ret != NULL) /* 这里调用`def_init_default` */ if (meth-\u0026gt;init(ret) == 0) { OPENSSL_free(ret); ret = NULL; } return ret; } static int def_init_default(CONF *conf) { if (conf == NULL) return 0; memset(conf, 0, sizeof(*conf)); /* 将新申请的CONF结构体的method字段设置为默认method */ conf-\u0026gt;meth = \u0026amp;default_method; /* meth_data的设置，这个是.conf文件字符解析时候使用的，我们这里不讲 */ conf-\u0026gt;meth_data = (void *)CONF_type_default; return 1; }   NCONF_load 初始化好CONF结构体，确定好对应配置文件名，开始对配置文件进行解析，NCONF_load （OpenSSL连配置文件格式都自己定义自己解析，硬核硬核）将调用到默认方法之 def_load\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  int NCONF_load(CONF *conf, const char *file, long *eline) { if (conf == NULL) { CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF); return 0; } return conf-\u0026gt;meth-\u0026gt;load(conf, file, eline); } static int def_load(CONF *conf, const char *name, long *line) { int ret; BIO *in = NULL; /* 这里通过BIO读入文件(Binary IO, openssl自己定义的io，简单理解就是一块内存Orz) */ #ifdef OPENSSL_SYS_VMS  in = BIO_new_file(name, \u0026#34;r\u0026#34;); #else  in = BIO_new_file(name, \u0026#34;rb\u0026#34;); #endif  ... /* 正式解析，按段解析； * 这里不分析咋解析的，很复杂很长，甚至能处理一些环境变量$(xxx)... 服 * 最后结果都存在哈希表data中 */ ret = def_load_bio(conf, in, line); BIO_free(in); return ret; }   CONF_modules_load 核心过程，从CONF去加载第一部分提到的'engines'这个module:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  int CONF_modules_load(const CONF *cnf, const char *appname, unsigned long flags) { STACK_OF(CONF_VALUE) *values; CONF_VALUE *vl; char *vsection = NULL; int ret, i; if (!cnf) return 1; /* 先获取到对应的section名，这里就是\u0026#34;openssl_conf\u0026#34; */ if (appname) vsection = NCONF_get_string(cnf, NULL, appname); if (!appname || (!vsection \u0026amp;\u0026amp; (flags \u0026amp; CONF_MFLAGS_DEFAULT_SECTION))) vsection = NCONF_get_string(cnf, NULL, \u0026#34;openssl_conf\u0026#34;); if (!vsection) { ERR_clear_error(); return 1; } OSSL_TRACE1(CONF, \u0026#34;Configuration in section %s\\n\u0026#34;, vsection); /* * 找到第一个段 openssl_conf * [openssl_def] * engines = engine_section */ values = NCONF_get_section(cnf, vsection); if (!values) return 0; for (i = 0; i \u0026lt; sk_CONF_VALUE_num(values); i++) { vl = sk_CONF_VALUE_value(values, i); /* 遍历所有的value，这里只有一个 \u0026#39;engines\u0026#39; */ ret = module_run(cnf, vl-\u0026gt;name, vl-\u0026gt;value, flags); OSSL_TRACE3(CONF, \u0026#34;Running module %s (%s) returned %d\\n\u0026#34;, vl-\u0026gt;name, vl-\u0026gt;value, ret); if (ret \u0026lt;= 0) if (!(flags \u0026amp; CONF_MFLAGS_IGNORE_ERRORS)) return ret; } return 1; } static int module_run(const CONF *cnf, const char *name, const char *value, unsigned long flags) { CONF_MODULE *md; int ret; if (!RUN_ONCE(\u0026amp;load_builtin_modules, do_load_builtin_modules)) return -1; /* 这里会在supported_modules这个栈上找到\u0026#39;engines\u0026#39;这个CONF_MODULE，开始魔幻表演 */ md = module_find(name); ... /* init这个module，这里将去调用到\u0026#39;dynamic\u0026#39;这个engine，下面将分析 */ ret = module_init(md, name, value, cnf); ... return ret; } /* initialize a module */ /* 此处将申请上一个所谓的initialized module， * 之后调用\u0026#39;engines\u0026#39;的init函数 * 若成功，将\u0026#39;engines\u0026#39; push进的全局变量栈 initialized_modules */ static int module_init(CONF_MODULE *pmod, const char *name, const char *value, const CONF *cnf) { int ret = 1; int init_called = 0; CONF_IMODULE *imod = NULL; /* Otherwise add initialized module to list */ imod = OPENSSL_malloc(sizeof(*imod)); if (imod == NULL) goto err; imod-\u0026gt;pmod = pmod; imod-\u0026gt;name = OPENSSL_strdup(name); /* 即\u0026#39;engines\u0026#39; */ imod-\u0026gt;value = OPENSSL_strdup(value); imod-\u0026gt;usr_data = NULL; if (!imod-\u0026gt;name || !imod-\u0026gt;value) goto memerr; /* Try to initialize module */ if (pmod-\u0026gt;init) { /* 调用engines的init，即第一部分提到的int_engine_module_init函数 */ ret = pmod-\u0026gt;init(imod, cnf); init_called = 1; /* Error occurred, exit */ if (ret \u0026lt;= 0) goto err; } if (initialized_modules == NULL) { initialized_modules = sk_CONF_IMODULE_new_null(); if (!initialized_modules) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } } /* 将\u0026#39;engines\u0026#39; push进的全局变量栈 initialized_modules */ if (!sk_CONF_IMODULE_push(initialized_modules, imod)) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } pmod-\u0026gt;links++; return ret; err: ... }   CONF的第一部分处理完毕，开始查看如何继续解析这个配置\nint_engine_module_init 这部分开始取engines这个section下的数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  static int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf) { STACK_OF(CONF_VALUE) *elist; CONF_VALUE *cval; int i; OSSL_TRACE2(CONF, \u0026#34;Called engine module: name %s, value %s\\n\u0026#34;, CONF_imodule_get_name(md), CONF_imodule_get_value(md)); /* Value is a section containing ENGINEs to configure */ elist = NCONF_get_section(cnf, CONF_imodule_get_value(md)); /* * 获取engine_section下的列表，这里就一个section叫做engine_x_section * [engine_section] * engine_x = engine_x_section */ if (!elist) { ENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT, ENGINE_R_ENGINES_SECTION_ERROR); return 0; } for (i = 0; i \u0026lt; sk_CONF_VALUE_num(elist); i++) { cval = sk_CONF_VALUE_value(elist, i); /* * name: engine_x, value: engine_x_section * 准备开始加载了 */ if (!int_engine_configure(cval-\u0026gt;name, cval-\u0026gt;value, cnf)) return 0; } return 1; }   int_engine_configure 是加载engine的主要流程，我们按顺序来一步一步分析内部的循环\nint_engine_configure  首先加载上value的section：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { int i; int ret = 0; long do_init = -1; STACK_OF(CONF_VALUE) *ecmds; CONF_VALUE *ecmd = NULL; const char *ctrlname, *ctrlvalue; ENGINE *e = NULL; int soft = 0; name = skip_dot(name); OSSL_TRACE1(CONF, \u0026#34;Configuring engine %s\\n\u0026#34;, name); /* Value is a section containing ENGINE commands */ /* 在conf的哈希表中找 叫做engine_x_section的section */ ecmds = NCONF_get_section(cnf, value); /* * 此时ecmds是一个栈，按顺序有以下CONF_VALUE (共有section = \u0026#34;engine_x_section\u0026#34;) * {.name = \u0026#34;engine_id\u0026#34;, .value = \u0026#34;engineX\u0026#34;} * {.name = \u0026#34;dynamic_path\u0026#34;, .value = \u0026#34;${ENV::PWD}/build/engine_ex.so\u0026#34;(这里已经通配符解析 * 了)} * {.name = \u0026#34;default_algorithms\u0026#34;, .value = \u0026#34;ALL\u0026#34;} * {.name = \u0026#34;init\u0026#34;, .value = \u0026#34;1\u0026#34;} */ if (!ecmds) { ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE, ENGINE_R_ENGINE_SECTION_ERROR); return 0; } ... }    按照顺序解析：\n第一个是engine_id:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { ... /* 开始对ecmds中栈上的CONF_VALUE遍历，这部分代码都在这个for循环中 */ for (i = 0; i \u0026lt; sk_CONF_VALUE_num(ecmds); i++) { ecmd = sk_CONF_VALUE_value(ecmds, i); /* 解析出ctrlname和ctrlvalue，对应结构体中.name和.value, 下同 */ ctrlname = skip_dot(ecmd-\u0026gt;name); ctrlvalue = ecmd-\u0026gt;value; OSSL_TRACE2(CONF, \u0026#34;ENGINE: doing ctrl(%s,%s)\\n\u0026#34;, ctrlname, ctrlvalue); /* First handle some special pseudo ctrls */ /* Override engine name to use */ if (strcmp(ctrlname, \u0026#34;engine_id\u0026#34;) == 0) /* 把name制成conf文件中engine_id */ name = ctrlvalue; ... } ... }   第二个是dynamic_path， 这个定义最关键，找到这个name，开始按照指定路径加载动态库engine:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  for(...) { ... else if (strcmp(ctrlname, \u0026#34;dynamic_path\u0026#34;) == 0) { /* * 看到这里是不是豁然开朗，首先找到第二部分初始化的叫做dynamic的engine * 但这个地方有个值得注意的点，底下分析ENGINE_by_id */ e = ENGINE_by_id(\u0026#34;dynamic\u0026#34;); /* 拿到\u0026#39;dynamic\u0026#39;这个ENGINE结构体后，进行三步操作，完成了engineX这个so的加载 */ /* 之后我们将单独把ENGINE_ctrl_cmd_string拿出来分析，观察它是如何去加载的*/ if (!e) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;SO_PATH\u0026#34;, ctrlvalue, 0)) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;2\u0026#34;, 0)) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;LOAD\u0026#34;, NULL, 0)) goto err; ... } /* * 完成这三步操作后，\u0026#39;dynamic\u0026#39;副本这个engine已经被重写成了 \u0026#39;engineX\u0026#39;！ * 同时这个engineX也加入了engines的队列中。 */ ENGINE *ENGINE_by_id(const char *id) { /* 入参检查和环境初始化检查 omit */ ... /* 加锁后开始遍历链表，匹配id = \u0026#34;dynamic\u0026#34; */ CRYPTO_THREAD_write_lock(global_engine_lock); iterator = engine_list_head; while (iterator \u0026amp;\u0026amp; (strcmp(id, iterator-\u0026gt;id) != 0)) iterator = iterator-\u0026gt;next; if (iterator != NULL) { /* * We need to return a structural reference. If this is an ENGINE * type that returns copies, make a duplicate - otherwise increment * the existing ENGINE\u0026#39;s reference count. */ /* 匹配成功后的小操作：看ENGINE_load_dynamic源码可以看到 dynamic-\u0026gt;flag 被设置成了 ENGINE_FLAGS_BY_ID_COPY */ if (iterator-\u0026gt;flags \u0026amp; ENGINE_FLAGS_BY_ID_COPY) { ENGINE *cp = ENGINE_new(); if (cp == NULL) iterator = NULL; else { /* 此处很重要！ */ /* 此处取出的dynamic，不是直接取出链表中的engine节点，而是复制了一个节点 */ engine_cpy(cp, iterator); iterator = cp; } } else { iterator-\u0026gt;struct_ref++; engine_ref_debug(iterator, 0, 1); } } CRYPTO_THREAD_unlock(global_engine_lock); if (iterator != NULL) /* 作为取出返回值，得到了一个dynamic的副本 */ return iterator; }     注意，此时e这个局部变量已经是一个id为'engineX'的ENGINE结构体了，也就是完成了动态加载的engine！\n第三步是default_algorithms:\n1 2 3 4 5  for (...) { else if (strcmp(ctrlname, \u0026#34;default_algorithms\u0026#34;) == 0) { if (!ENGINE_set_default_string(e, ctrlvalue)) ... }   第四步，完成Init:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  for (...) { if (strcmp(ctrlname, \u0026#34;init\u0026#34;) == 0) { if (!NCONF_get_number_e(cnf, value, \u0026#34;init\u0026#34;, \u0026amp;do_init)) goto err; if (do_init == 1) { /* * 此处为1，完成engine init, * 具体代码就是调用ENGINE_init去执行e-\u0026gt;init, 增加引用数之类的，我们这里其实是空的 * 之后去把这个engine同时加入initialized_engines这个全局变量栈中。代码不看了 */ if (!int_engine_init(e)) goto err; ... }   就此CONF_modules_load全部运行完成，engineX加载完毕。后续只需要像main函数中的使用ENGINE_by_id(\u0026quot;engineX\u0026quot;);就可以取得这个engine了。圆满。\n但是 bind_engine 在哪调用的呢，还是没看到，那必然是在ENGINE_ctrl_cmd_string流程中。所以下面重点讲讲这个函数。\nENGINE_ctrl_cmd_string 从cmd_name去获取cmd_num 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { int num, flags; long l; char *ptr; ... /* 宏的命名已经暴露了一切，通过cmd_name得到cmd_num */ if (e-\u0026gt;ctrl == NULL || (num = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FROM_NAME, 0, (void *)cmd_name, NULL)) \u0026lt;= 0) { ... } ... } int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... /* * Intercept any \u0026#34;root-level\u0026#34; commands before trying to hand them on to * ctrl() handlers. */ switch (cmd) { /* 这部分是通用的ctrl，范围为10 ~ 18, 全部进入int_ctrl_helper */ case ENGINE_CTRL_HAS_CTRL_FUNCTION: return ctrl_exists; case ENGINE_CTRL_GET_FIRST_CMD_TYPE: case ENGINE_CTRL_GET_NEXT_CMD_TYPE: case ENGINE_CTRL_GET_CMD_FROM_NAME: case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: case ENGINE_CTRL_GET_NAME_FROM_CMD: case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: case ENGINE_CTRL_GET_DESC_FROM_CMD: case ENGINE_CTRL_GET_CMD_FLAGS: /* * 这里dynamic的flag为ENGINE_FLAGS_BY_ID_COPY，0x0004 * ENGINE_FLAGS_MANUAL_CMD_CTRL = 0x0002，与的结果为0 */ if (ctrl_exists \u0026amp;\u0026amp; !(e-\u0026gt;flags \u0026amp; ENGINE_FLAGS_MANUAL_CMD_CTRL)) return int_ctrl_helper(e, cmd, i, p, f); if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); /* * For these cmd-related functions, failure is indicated by a -1 * return value (because 0 is used as a valid return in some * places). */ return -1; } default: break; } /* Anything else requires a ctrl() handler to exist. */ /* 这里是确定当前engine-\u0026gt;ctrl != NULL */ if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); return 0; } /* 调用上面看到的 dynamic-\u0026gt;ctrl = dynamic_ctrl, 后面会调用到这来 */ return e-\u0026gt;ctrl(e, cmd, i, p, f); } /* 这个函数也将反复调用（吐槽下openssl这鬼之设计），我们这里先看当前的cmd */ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { int idx; char *s = (char *)p; const ENGINE_CMD_DEFN *cdp; ... /* Now handle cmd_name -\u0026gt; cmd_num conversion */ if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) { /* 从dynamic的cmd_defns中去匹配cmd_name,假设是\u0026#34;SO_PATH\u0026#34;, 直接去查第二部分的dynamic_cmd_defns，刚好匹配上idx = 0 */ if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(e-\u0026gt;cmd_defns, s)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME); return -1; } /* 查idx = 0时的 cmd_num = 200 = DYNAMIC_CMD_SO_PATH */ return e-\u0026gt;cmd_defns[idx].cmd_num; } ... }   可以看到这里的num返回回来的DYNAMIC_CMD_SO_PATH，是靠dynamic.cmd_defns中的ENGINE_CMD_DEFN数组表查询得到的。往下接着看ENGINE_ctrl_cmd_string\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { /* 继续调用公用ctrl，进入到int_ctrl_helper (看底下开源的注释，两个函数做的ctrl操作一样的，为啥这么搞也许就是未解之谜吧) */ ... if (!ENGINE_cmd_is_executable(e, num)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_CMD_NOT_EXECUTABLE); return 0; } /* 顾名思义，拿到dynamic的flag，这里将得到idx = 0时，cmd_defns表中0处的第四个元素 */ flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL); if (flags \u0026lt; 0) { /* * Shouldn\u0026#39;t happen, given that ENGINE_cmd_is_executable() returned * success. */ ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } } static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e-\u0026gt;cmd_defns, (unsigned int)i)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER); return -1; } /* Now the logic splits depending on command type */ cdp = \u0026amp;e-\u0026gt;cmd_defns[idx]; switch (cmd) { ... case ENGINE_CTRL_GET_CMD_FLAGS: /* 可以查出来上面的是 ENGINE_CMD_FLAG_STRING = 0x0002 */ return cdp-\u0026gt;cmd_flags; } ... }   别问为啥不一次查出来，要多次遍历，问就是架构。继续看ENGINE_ctrl_cmd_string，终于要做真正的操作了， 可以看到，最后进入了dynamic_ctrl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { ... /* ENGINE_CMD_FLAG_NO_INPUT = 0x0004 */ if (flags \u0026amp; ENGINE_CMD_FLAG_NO_INPUT) { /* 如果命令查出来的flag应该没有arg_input, 但arg非空，直接退出???? */ if (arg != NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_NO_INPUT); return 0; } /* * We deliberately force the result of ENGINE_ctrl() to 0 or 1 rather * than returning it as \u0026#34;return data\u0026#34;. This is to ensure usage of * these commands is consistent across applications and that certain * applications don\u0026#39;t understand it one way, and others another. */ /* 最后\u0026#34;LOAD\u0026#34;命令走的这 */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* So, we require input */ if (arg == NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_INPUT); return 0; } /* 一定有更好的写法吧，这种判断也太迷惑了。。 */ /* If it takes string input, that\u0026#39;s easy */ if (flags \u0026amp; ENGINE_CMD_FLAG_STRING) { /* Same explanation as above */ /* 所以应该调用到这，注意此时num 将大于200, 肯定不是默认的流程， 这就走到了return e-\u0026gt;ctrl(e, cmd, i, p, f); 即 dynamic_ctrl */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* 此时arg是数字，需要从str转int，LIST_ADD走这 */ if (!(flags \u0026amp; ENGINE_CMD_FLAG_NUMERIC)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } l = strtol(arg, \u0026amp;ptr, 10); if ((arg == ptr) || (*ptr != \u0026#39;\\0\u0026#39;)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER); return 0; } /* * Force the result of the control command to 0 or 1, for the reasons * mentioned before. */ if (ENGINE_ctrl(e, num, l, NULL, NULL) \u0026gt; 0) return 1; ... }   所以这个函数的主要步骤就是根据输入的cmd_name从dynamic中挂载的cmd_defns取出对应的cmd_num和flag，之后用cmd_num调用到dynamic挂载的ctrl字段函数去做真正的操作。我们用一张表统计下三次取到的结果：\n   cmd_name cmd_num flag     \u0026ldquo;SO_PATH\u0026rdquo; DYNAMIC_CMD_SO_PATH = 200 ENGINE_CMD_FLAG_STRING 0x0002   \u0026ldquo;LIST_ADD\u0026rdquo; DYNAMIC_CMD_LIST_ADD = 203 ENGINE_CMD_FLAG_NUMERIC 0x0001   \u0026ldquo;LOAD\u0026rdquo; DYNAMIC_CMD_LOAD = 206 ENGINE_CMD_FLAG_NO_INPUT 0x0004    根据这个表，我们去看对于dynamic-\u0026gt;ctrl即dynamic_ctrl函数对这几个cmd的操作\ndynamic_ctrl 先看这个函数的公共部分，对相同的engine会初始化上一个ctx上下文：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156  /* 动态库加载的上下文 */ struct st_dynamic_data_ctx { /* The DSO object we load that supplies the ENGINE code */ DSO *dynamic_dso; /* * The function pointer to the version checking shared library function */ dynamic_v_check_fn v_check; /* * The function pointer to the engine-binding shared library function */ dynamic_bind_engine bind_engine; /* The default name/path for loading the shared library */ char *DYNAMIC_LIBNAME; /* Whether to continue loading on a version check failure */ int no_vcheck; /* If non-NULL, stipulates the \u0026#39;id\u0026#39; of the ENGINE to be loaded */ char *engine_id; /* * If non-zero, a successfully loaded ENGINE should be added to the * internal ENGINE list. If 2, the add must succeed or the entire load * should fail. */ int list_add_value; /* The symbol name for the version checking function */ const char *DYNAMIC_F1; /* The symbol name for the \u0026#34;initialise ENGINE structure\u0026#34; function */ const char *DYNAMIC_F2; /* * Whether to never use \u0026#39;dirs\u0026#39;, use \u0026#39;dirs\u0026#39; as a fallback, or only use * \u0026#39;dirs\u0026#39; for loading. Default is to use \u0026#39;dirs\u0026#39; as a fallback. */ int dir_load; /* A stack of directories from which ENGINEs could be loaded */ STACK_OF(OPENSSL_STRING) *dirs; }; static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { /* 这个函数将会初始化并保存动态库数据的ctx，这也是为什么可以反复调用这个接口的原因 */ dynamic_data_ctx *ctx = dynamic_get_data_ctx(e); int initialised; if (!ctx) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED); return 0; } /* 可以看到，加载完成的标志是dynamic_dso钩子已经挂上了 */ initialised = ((ctx-\u0026gt;dynamic_dso == NULL) ? 0 : 1); /* All our control commands require the ENGINE to be uninitialised */ if (initialised) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED); return 0; } /* cmd解析，底下逐个分析 */ ... } /* * This function retrieves the context structure from an ENGINE\u0026#39;s \u0026#34;ex_data\u0026#34;, * or if it doesn\u0026#39;t exist yet, sets it up. */ static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e) { dynamic_data_ctx *ctx; if (dynamic_ex_data_idx \u0026lt; 0) { /* * Create and register the ENGINE ex_data, and associate our \u0026#34;free\u0026#34; * function with it to ensure any allocated contexts get freed when * an ENGINE goes underground. */ int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, dynamic_data_ctx_free_func); if (new_idx == -1) { ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX); return NULL; } CRYPTO_THREAD_write_lock(global_engine_lock); /* Avoid a race by checking again inside this lock */ if (dynamic_ex_data_idx \u0026lt; 0) { /* Good, someone didn\u0026#39;t beat us to it */ dynamic_ex_data_idx = new_idx; new_idx = -1; } CRYPTO_THREAD_unlock(global_engine_lock); /* * In theory we could \u0026#34;give back\u0026#34; the index here if (new_idx\u0026gt;-1), but * it\u0026#39;s not possible and wouldn\u0026#39;t gain us much if it were. */ } ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx); /* Check if the context needs to be created */ if ((ctx == NULL) \u0026amp;\u0026amp; !dynamic_set_data_ctx(e, \u0026amp;ctx)) /* \u0026#34;set_data\u0026#34; will set errors if necessary */ return NULL; return ctx; } /* * 简单的说就是去查挂在engine-\u0026gt;ex_data， * 这个就是动态库加载的上下文，ex_data是个栈可能有多个上下文， * 根据一个全局变量dynamic_ex_data_idx确定当前使用上下文 * 当然第一次调用ctx是空的，所以需要调用一下dynamic_set_data_ctx初始化 */ static int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx) { /* 申请ctx的mem */ dynamic_data_ctx *c = OPENSSL_zalloc(sizeof(*c)); int ret = 1; if (c == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); return 0; } c-\u0026gt;dirs = sk_OPENSSL_STRING_new_null(); if (c-\u0026gt;dirs == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); OPENSSL_free(c); return 0; } /* 初始化一些字段，下面总结 */ c-\u0026gt;DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, ; c-\u0026gt;DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;; c-\u0026gt;dir_load = 1; CRYPTO_THREAD_write_lock(global_engine_lock); /* 第一次进来为NULL(然而正常是为ctx = NULL才会调用这个函数，可能是冗余校验)*/ if ((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx)) == NULL) { /* Good, we\u0026#39;re the first */ /* 把ctx挂在engine-\u0026gt;ex_data上 */ ret = ENGINE_set_ex_data(e, dynamic_ex_data_idx, c); if (ret) { *ctx = c; c = NULL; } } CRYPTO_THREAD_unlock(global_engine_lock); /* * If we lost the race to set the context, c is non-NULL and *ctx is the * context of the thread that won. */ if (c) sk_OPENSSL_STRING_free(c-\u0026gt;dirs); OPENSSL_free(c); return ret; } /* * 得到最后的结果 dynamic-\u0026gt;ex_data = ctx; * ctx = {.DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, .DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;, c-\u0026gt;dir_load = 1} * 惊奇的发现了 bind_engine 虽然他只是个字符串，但是我相信你已经知道原因了 * 他需要在动态库中去寻找这个符号 */   之后我们逐一分析这三个cmd\nDYNAMIC_CMD_SO_PATH和DYNAMIC_CMD_LIST_ADD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { /* 注意， p就是ctrlvalue，即从conf中取下来的值 */ case DYNAMIC_CMD_SO_PATH: /* a NULL \u0026#39;p\u0026#39; or a string of zero-length is the same thing */ if (p \u0026amp;\u0026amp; (strlen((const char *)p) \u0026lt; 1)) p = NULL; OPENSSL_free(ctx-\u0026gt;DYNAMIC_LIBNAME); if (p) /* 很明显只是做了个简单的复制，此时路径已经赋值上了 */ ctx-\u0026gt;DYNAMIC_LIBNAME = OPENSSL_strdup(p); else ctx-\u0026gt;DYNAMIC_LIBNAME = NULL; return (ctx-\u0026gt;DYNAMIC_LIBNAME ? 1 : 0); case DYNAMIC_CMD_LIST_ADD: if ((i \u0026lt; 0) || (i \u0026gt; 2)) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT); return 0; } /* 很简单，赋值而已 */ ctx-\u0026gt;list_add_value = (int)i; return 1; ... } }   这两个都很简单，最后难点都给了LOAD\nDYNAMIC_CMD_LOAD 最关键的函数，完成了全部的加载，解释都在注释里：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { case DYNAMIC_CMD_LOAD: return dynamic_load(e, ctx); ... } } static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx) { ENGINE cpy; dynamic_fns fns; /* * 先new一个DSO结构体，DSO这一套函数怎么玩的这里先不讲了， * 可以理解为内部也有一个加载钩子，有4个挂载点，估计再展开讲读者疯了 */ if (ctx-\u0026gt;dynamic_dso == NULL) ctx-\u0026gt;dynamic_dso = DSO_new(); if (ctx-\u0026gt;dynamic_dso == NULL) return 0; /* 此处检查DYNAMIC_LIBNAME不能为空，这个就是dso的加载地址 */ if (!ctx-\u0026gt;DYNAMIC_LIBNAME) { if (!ctx-\u0026gt;engine_id) return 0; DSO_ctrl(ctx-\u0026gt;dynamic_dso, DSO_CTRL_SET_FLAGS, DSO_FLAG_NAME_TRANSLATION_EXT_ONLY, NULL); ctx-\u0026gt;DYNAMIC_LIBNAME = DSO_convert_filename(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;engine_id); } /* 核心加载函数int_load，看下面分析 */ if (!int_load(ctx)) { ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_NOT_FOUND); DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; return 0; } /* We have to find a bind function otherwise it\u0026#39;ll always end badly */ /* * 此时engine动态库已经加载如内存，符号表与对应地址也准备完成 * 所以肯定是需要去寻找这个绑定engine完成加载的函数了，胜利的曙光 * DSO_bind_func会在符号表中去匹配第二个参数字符串，这里就是我们要的\u0026#34;bind_engine\u0026#34; * 并返回上它的函数地址，挂载在ctx-\u0026gt;bind_engine上 */ if (! (ctx-\u0026gt;bind_engine = (dynamic_bind_engine) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F2))) { ctx-\u0026gt;bind_engine = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE); return 0; } /* Do we perform version checking? */ if (!ctx-\u0026gt;no_vcheck) { unsigned long vcheck_res = 0; /* * Now we try to find a version checking function and decide how to * cope with failure if/when it fails. */ ctx-\u0026gt;v_check = (dynamic_v_check_fn) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F1); if (ctx-\u0026gt;v_check) vcheck_res = ctx-\u0026gt;v_check(OSSL_DYNAMIC_VERSION); /* * We fail if the version checker veto\u0026#39;d the load *or* if it is * deferring to us (by returning its version) and we think it is too * old. */ if (vcheck_res \u0026lt; OSSL_DYNAMIC_OLDEST) { /* Fail */ ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_VERSION_INCOMPATIBILITY); return 0; } } /* * First binary copy the ENGINE structure so that we can roll back if the * hand-over fails */ memcpy(\u0026amp;cpy, e, sizeof(ENGINE)); /* * Provide the ERR, \u0026#34;ex_data\u0026#34;, memory, and locking callbacks so the * loaded library uses our state rather than its own. FIXME: As noted in * engine.h, much of this would be simplified if each area of code * provided its own \u0026#34;summary\u0026#34; structure of all related callbacks. It * would also increase opaqueness. */ fns.static_state = ENGINE_get_static_state(); CRYPTO_get_mem_functions(\u0026amp;fns.mem_fns.malloc_fn, \u0026amp;fns.mem_fns.realloc_fn, \u0026amp;fns.mem_fns.free_fn); /* * Now that we\u0026#39;ve loaded the dynamic engine, make sure no \u0026#34;dynamic\u0026#34; * ENGINE elements will show through. */ engine_set_all_null(e); /* Try to bind the ENGINE onto our own ENGINE structure */ /* !!!!Attension, 终于调用成功了，我们的engineX终于被设置好了！ */ if (!ctx-\u0026gt;bind_engine(e, ctx-\u0026gt;engine_id, \u0026amp;fns)) { ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED); /* Copy the original ENGINE structure back */ memcpy(e, \u0026amp;cpy, sizeof(ENGINE)); return 0; } /* Do we try to add this ENGINE to the internal list too? */ /* 把这个engine的副本add进上面engine全局链表，大功告成！*/ if (ctx-\u0026gt;list_add_value \u0026gt; 0) { if (!ENGINE_add(e)) { /* Do we tolerate this or fail? */ if (ctx-\u0026gt;list_add_value \u0026gt; 1) { /* * Fail - NB: By this time, it\u0026#39;s too late to rollback, and * trying to do so allows the bind_engine() code to have * created leaks. We just have to fail where we are, after * the ENGINE has changed. */ ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } /* Tolerate */ ERR_clear_error(); } } return 1; } static int int_load(dynamic_data_ctx *ctx) { int num, loop; /* Unless told not to, try a direct load */ /* * DSO_load去打开ctx-\u0026gt;DYNAMIC_LIBNAME，把egine对应的lib库加载进内存 * 解析符号表和对应地址到上面申请好的ctx-\u0026gt;dynamic_dso结构体中 */ if ((ctx-\u0026gt;dir_load != 2) \u0026amp;\u0026amp; (DSO_load(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, NULL, 0)) != NULL) return 1; /* If we\u0026#39;re not allowed to use \u0026#39;dirs\u0026#39; or we have none, fail */ if (!ctx-\u0026gt;dir_load || (num = sk_OPENSSL_STRING_num(ctx-\u0026gt;dirs)) \u0026lt; 1) return 0; for (loop = 0; loop \u0026lt; num; loop++) { /* 还有链接的dso这里会处理递归的去加载，对应的需要在ctx-\u0026gt;dirs中 */ const char *s = sk_OPENSSL_STRING_value(ctx-\u0026gt;dirs, loop); char *merge = DSO_merge(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, s); if (!merge) return 0; if (DSO_load(ctx-\u0026gt;dynamic_dso, merge, NULL, 0)) { /* Found what we\u0026#39;re looking for */ OPENSSL_free(merge); return 1; } OPENSSL_free(merge); } return 0; }   终于终于终于，找到目标了，这个叫做'dynamic'的engine副本完成了变成engineX的蜕变。\n后续 难怪这么多人喷OpenSSL烂，这复杂的流程，这一个又一个的钩子。不过这一串源码读下来看明白的时候还是有神清气爽的感觉。\n有缘后面会分析密码算法具体挂载，如ENGINE_set_digests。\n我很菜，有错误的地方欢迎指正\n","description":"OpenSSL Engine插件的加载过程源码分析","id":6,"section":"posts","tags":["OpenSSL"],"title":"OpenSSL Engine加载","uri":"https://summersummer3.github.io/posts/openssl_engine/"},{"content":"椭圆曲线基本学习 文章：https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#elliptic-curves\n书籍：密码学原理与实践 第6章\n椭圆曲线方程 $$\n\\left\\lbrace (x, y) \\in \\mathbb{R}^2\\ |\\ y^2 = x^3 + ax + b,\\ 4 a^3 + 27 b^2 \\ne 0 \\right\\rbrace\\ \\cup\\ \\left\\lbrace 0 \\right\\rbrace\n$$\n群与阿贝尔群 ​\t$\\mathbb{G}$ 是一个 群 (Group) 如果该集合上定义了一种运算 $ + $:\n 封闭性: $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ ,则 $a + b \\in \\mathbb{G}$ ; 结合律: $a \\in \\mathbb{G}, b \\in \\mathbb{G}, c \\in \\mathbb{G}$, $ (a + b) + c = a + (b +c)$ ; 存在单位元 $0 \\in \\mathbb{G}$, 使得 $a \\in \\mathbb{G}$，$a + 0 = 0 + a = a$; 每一个元素存在逆元：对于集合内任意元素$a, \\exists b \\in \\mathbb{G}$ 满足 $a + b = 0$，记做$a = -b$  如果该群还满足:\n交换律： $a \\in \\mathbb{G}, b \\in \\mathbb{G}$， $a + b = b + a$  则该群被称为阿贝尔群.\n有限域 $\\mathbb{F}$ 是一个 域(Field) 如果该集合上定义了两种运算 $(\\cdot\\ ;+)$\n 封闭性: $a \\in \\mathbb{F}, b \\in \\mathbb{F}$，则 $a + b \\in \\mathbb{G}; a \\cdot b \\in \\mathbb{G}$ 结合律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$，$ (a + b) + c = a + (b +c);\\ (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ 存在加法单位元 $0 \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a + 0 = 0 + a = a$ 存在乘法单位元 $e \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a \\cdot e = e \\cdot a = a$ 交换律： $a \\in \\mathbb{F}, b \\in \\mathbb{F}$， $a + b = b + a$，$a \\cdot b = b \\cdot a$ 逆元: 对于集合内任意元素$a, \\exists b \\in \\mathbb{F}; \\exists c \\in \\mathbb{F}$ 满足 $a + b = 0; a \\cdot c = e$， 记做$a = -b;\\ a = c^{-1}$，$0^{-1}$无意义 分配律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$；$a \\cdot (b + c) = a \\cdot b + a \\cdot c$  注意：加法逆元定义减法，乘法逆元定义除法\n有限域指的是元素有限的域，属于计算机和密码学的基本数学原理之一\n典型的有限域例子：$\\mathbb{F}_p = {0, 1, \u0026hellip;, p-1}$, $p$为质数，\n定义 (+)：$a + b \\mod p$\n定义 ($\\cdot$)：$a \\cdot b \\mod p$\n计算 $a ^ {-1}$ : 拓展欧几里得算法\n椭圆曲线上的群  曲线上的点的集合组成群 $x$无穷远点为单位元$0$ 点$P$与它的逆$Q$关于直线$x = 0$对称 加法定义：$P + Q + R = 0$，如果这三点是非0点，且在同一条直线上(即一条直线与该曲线相交于三点，无穷远点为0) $=\u0026gt; P + Q = -R$  加法同样需要满足结合律.\n几何意义上的加法 最重要的情况:\n 如果 $P=Q, P + Q$，物理意义是切线, 与曲线交于另一点$R$, 满足：$2P = -R$ 如果$P, Q$直线的第三点刚好为$P\\ or\\ Q$，则也将包含一条切线，计算相同: $P + Q + P = 0\\ =\u0026gt; P + Q = -P$  代数意义上的加法 不同两点相加 $P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n曲线方程：$y^2 = x^3 +ax + b$\n  计算斜率 $k = \\frac{P_y - Q_y}{P_x - Q_x}$\n  曲线方程连立上直线方程 $y = kx + c$\n=\u0026gt; $ 0 = x^3 - k^2x^2 + (a - 2kc)x + b - c^2$\n  铭记三次求根公式之三根之和是二次项系数的相反数: $T_x = k^2 - P_x - Q_x$\n  由于斜率 $k = \\frac{T_y - P_y}{T_x - P_x}$，$T_y = k(T_x - P_x) + P_y$\n  相同两点相加 $P(P_x, P_y)$，求 $T(T_x,T_y) = P + P = 2P$\n和上面基本相同，但计算直线斜率需要根据切线计算\n对曲线方程两边求隐微分:\n$\\mathrm{d}(y^2) = \\mathrm{d}(x^3 +ax + b)$ =\u0026gt; $2y\\mathrm{d}y = (3x^2 + a)\\mathrm{d}x$\n将$P_x, P_y$带入，获得斜率:\n$k = \\frac{\\mathrm{d}y}{\\mathrm{d}x} = \\frac{3P_x^2 + a}{2P_y}$\n所以 $T_x = k^2 - 2P_x$，$T_y = k(T_x - P_x) + P_y$\n标量积 $P(P_x, P_y)$，求 $nP = \\underbrace{P + P + P + \u0026hellip; + P}_{\\text{n times}}$，$n \u0026gt; 2$\n  将 $n$ 用二进制表示；以151为例子，$151_{10} = 10010111_2 = 2^0 + 2^1 + 2^2 + 2^4 + 2^7$\n  $nP = P + 2P + 2^2P + 2^4P + 2^7P$\n  根据上面两项计算规则，分别计算$P, 2P，P + 2P$\n  计算$2^2P = 4P = 2 \\cdot 2P$，对$2P$做相同点相加即可\n  同理计算$2^3P = 8P = 2 \\cdot 4P$，$2^4P = 16P = 2 \\cdot 8P$, 依次类推，每计算到一个二进制中为$1$的阶数， 完成一次两点相加即可\n  曲线上的有限域 取几何曲线上的坐标$(x, y)$，$x, y \\in \\mathbb{F}_p$, $p$ 是一个质数，形成一条离散曲线：\n$$\n\\begin{array}{rcl}\n\\left\\lbrace(x, y) \\in (\\mathbb{F}_p)^2 \\right. \u0026amp; \\left. | \\right. \u0026amp; \\left. y^2 \\equiv x^3 + ax + b \\pmod{p}, \\right.\n\\left. 4a^3 + 27b^2 \\not\\equiv 0 \\pmod{p}\\right\\rbrace\\ \\cup\\ \\left\\lbrace0\\right\\rbrace\n\\end{array}\n$$\n从连续曲线上的加法可以推出有限域上的加法公式：\n$P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n$$\n\\begin{array}{rcl}\nk \u0026amp; = \u0026amp;(P_y - Q_y)(P_x - Q_x)^{-1} \\bmod{p} \\\nT_x \u0026amp; = \u0026amp; (k^2 - P_x - Q_x) \\bmod{p} \\\nT_y \u0026amp; = \u0026amp; [P_y + k(T_x - P_x)] \\bmod{p} \\\n\\end{array}\n$$\n若$P\\ = Q$\n$$\nk = (3 P_x^2 + a)(2 P_y)^{-1} \\bmod{p}\n$$\n曲线上的循环子群 循环子群的阶 对于离散曲线上的任意点$P$, 存在最小的 $n$ 使得 $nP = 0$, 此时 $n$ 称作以 $P$ 为基点的循环子群的阶\n找基点的方法  计算椭圆曲线的阶$N$ (Schoof\u0026rsquo;s algorithm: https://en.wikipedia.org/wiki/Schoof%27s_algorithm) 选择一个阶为$n$的子群。n必须是素数且必须是$N$的因子 计算辅因子 $h = N/n$ 在曲线上选择一个随机的点 $T$ 计算$G = hT$，点乘 如果$G = 0$, 返回4， 否则找到基点 $G$, 子群的阶为 $n$, $h$ 被称为辅因子  原理: 根据拉格朗日定理，$n$ 整除 $N$ 且 $n$ 为质因子，且任意点 $T$ 满足$NT = 0$， 则：$n(hT) = 0$ 恒成立, 那么若$hT\\ \\ne 0$，则 $hT$ 作为基点的阶一定为$n$. ($n$ 一定是素数, 否则不成立)\n曲线上的离散对数问题 对于曲线上的基点 $G$， 已知 $n$ 计算 $P = nG$ 是容易的\n但是已知$P, G$, 计算 $n$ 是很困难的\nECDH \u0026amp; ECDSA ECDH  CA选用共同曲线，并下发相同基点$G$，其阶数为 $n$, 则私钥的取值范围为$d \\in {1, \u0026hellip;, n - 1}$ Alice随机选择私钥$d_A$，计算 Pubkey: $P_A = d_AG$, 通过非安全信道传递给Bob Bob随机选择私钥$d_B$，计算 Pubkey: $P_B = d_BG$，通过非安全信道传递给Alice Alice和Bob分别计算$S = d_AP_b = d_BP_A = d_Ad_BG$， 共享秘密成功  秘密共享成功后可以每次通信时明文传递salt, 每次通过 $key = KDF(salt + S)$，得到具体通信对称秘钥，加密通讯(TLS/SSL)\n通过服务器动态生成的ECDH一般称作ECDHE\nECDSA 定义依然继承上文，$n$ 为 $G$ 作为基点的子群阶数\n定义 $bit(x)$ 为表示 $x$ 需要的比特数；注意计算DSA时，若摘要值的比特数 $bits(digest(plain_test)) \u0026gt; bits(n)$，则需要截取摘要值的低 $bits(n)$ 进行签名.\n符号标记 截取前n-bits函数 ： $trun_{bit(n)}(digest)$\n截取后的摘要值：$z = trun_{bit(n)}(digest(plain_test))$，$digest$ 需要选择安全摘要算法：内部要求SHA-256以上\n私钥：$d$\n公钥：$P = dG$\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x \\mod n$， 若$r = 0$则返回1\n  计算$s = k^{-1}(z + rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算 $u_1 = s^{-1}z \\mod n$ 计算 $u_2 = s^{-1}r \\mod n$ 计算 $T\u0026rsquo; = u_1G\\ +\\ u_2P$  若$T\u0026rsquo;_x = r \\mod n$，验签成功，否则失败\n正确性 我们尝试计算的其实还是$T = kG$，若此时 $z$ 是正确摘要值，则有:\n$k = s^{-1}(z + rd)\\ mod\\ n\\ =\u0026gt;\\ k = s^{-1}z + s^{-1}rd \\mod n$\n带入上式 $T = s^{-1}zG + s^{-1}rdG = u_1G + u_2(dG) = u1G + u_2P$\n所以若 $z$ 发生改变，则此时计算出来的 $T\u0026rsquo;_x\\ \\ne\\ r \\mod n$\n随机数相等下的私钥复原 若每次取出的随机数 $k$ 都相等：\n获取两份签名与摘要：$z_1, (r_1, s_1)$ 和 $z_2, (r_2, s_2)$\n容易得到: $r_1 = r_2 = (kG)_x \\mod n$\n之后通过 $s_1 - s_2$ 计算 $k$：\n$s_1 - s_2 = k^{-1}(z_1 + rd - z_2 - rd) \\mod n$\n$=\u0026gt; k = (z_1 - z_2)(s_1 - s_2)^{-1} \\mod n$\n之后计算 $d$ 就很简单了:\n$ d = r^{-1}(s_1k - z_1) \\mod n$\n通过签名恢复公钥 若已知曲线上 $x = r$ 对应的两点 $R, R\u0026rsquo;$，则可以从签名$(s, r)$中恢复公钥$P$:\n$s = k^{-1}(z + rd) \\mod n$\n$=\u0026gt; skG = (z + rd)G$\n注意 $kG = R$ 或者 $kG = R\u0026rsquo;$, 分别作为备选带入上式，同时$P = dG$:\n$=\u0026gt;\\ sR - zG = r(dG)\\ =\u0026gt; P = r^{-1}(sR - zG)$\nor $=\u0026gt;\\ P = r^{-1}(sR\u0026rsquo; - zG)$\n实现方法 点压缩：增加2bit来标识，一个用来标识 $R_x = r\\mod n$ 或者 $R_x = r$，另一个标识$R_y$是基数还是偶数：\n因为$R, R\u0026rsquo;$关于 $x$ 轴对称，$R_y + R\u0026rsquo;_y = 0 \\mod p$， 所以$R_y ,P\u0026rsquo;_y$为一基一偶，可用一个bit标识\n这样可以达到多用增加一个byte(04标记等)，来达成无需传递公钥即可验签\n相关算法与代码：https://busy.org/@oflyhigh/397bw1\n伪造签名 构造e方法  随机选择 $a, b \\in {1, \u0026hellip; n}$, 计算$T = aG + bP, r = T_x$ 计算 $s = rb^{-1}, e = arb^{-1}$ 若$e$ 为伪造摘要值, 可伪造合法签名 $(r, s)$  正确性:\n$u_1 = s^{-1}e \\mod \\ n$\n$u_2 = s^{-1}r \\mod\\ n$\n将$s, e$带入\n$u_1G + u_2P = (rb^{-1})^{-1}(arb^{-1})G + (rb^{-1})^{-1}rP = (rr^{-1})(bb^{-1})aG + (rr^{-1})bP = aG + bP = T$\n由于$r = T_x \\mod n$，校验通过\n相关算法与代码：https://github.com/GoldSaintEagle/ECDSA-SM2-Signing-Attack\nSM2签名 标记不变，$z = SM3(message)$ 是消息的摘要值（国密要求摘要使用SM3），$d$ 是私钥， $P = dG$是公钥\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x + z \\mod n$， 若$r = 0$则返回1\n  计算$s = (1 + d)^{-1}(k - rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算消息值摘要$z\u0026rsquo; = SM3(message)$ 计算$T\u0026rsquo; = sG + (r + s)P$ 判断$r\\ ?= T\u0026rsquo;_x + z \\mod n$  正确性 首先计算 $k$ :\n$s = (1 + d)^{-1}(k - rd) \\mod n$\n=\u0026gt; $s(1 + d) + rd = k \\mod n$ =\u0026gt; $s + (s + r)d = k \\mod n$\n所以 ：\n$T = kG = sG + (s + r)(dG) = sG + (s + r)P = T'$\n因此可以推导：\n$r = (T_x + z) = (T\u0026rsquo;_x + z) \\mod n$\n所以如果$r = T\u0026rsquo;_x + z\u0026rsquo; \\mod n$， 则 $z\u0026rsquo;$ 验签通过，否则 $z\u0026rsquo;$ 摘要有误\n","description":"椭圆曲线算法入门及ECDSA与SM2算法详解","id":7,"section":"posts","tags":["密码学"],"title":"ECDSA与SM2","uri":"https://summersummer3.github.io/posts/ecdsa%E4%B8%8Esm2/"}]