[{"content":"A useless security engineer/cn:帅华\n工作经历\n字节跳动：移动安全风控工程师，专注反自动化\n华为: 硬件安全与移动安全工程师，TEE/HSM/渗透测试/安全启动 都做过点\n学习经历\n日本筑波大学，社会工学，硕士: 差分隐私研究\n中南大学，计算机科学与技术，本科: 瞎玩儿\n","description":"","id":2,"section":"","tags":null,"title":"About Techsum","uri":"https://summersummer3.github.io/about/"},{"content":"背景 由于很多headless浏览器的webgl信息比较明显，如果源站尝试采集webgl参数会暴露自动化工具的特征，所以黑产攻击中需要去欺骗webgl的信息上报。\n目前在github上可以找到一个spoof webgl的项目，star数并不多，但其思路应该是比较主流的hook webgl相关接口的方式。本文主要对该工具的使用和源码进行分析。\n这份代码并不完美，甚至能找到几处bug，但不妨碍我们学习其思想；github地址：https://github.com/siejqa/spoofHeadless\n背景知识简单介绍 Webgl和参数采集 简单来说webgl就是浏览器给前端js代码调用的渲染绘图API，该API可以在在html canvas元素中使用，可以调用到硬件进行加速，所以webgl的参数通常与硬件强相关。更具体的介绍和教程可以参考：https://www.w3cschool.cn/webgl/i4gf1oh1.html\n具体采集webgl的参数时，需要首先先获取canvas下的webgl Context，使用getContext接口。而采集具体参数是使用getParameter函数完成，getParameter接受一个整数，每个整数对应一个属性；以获取GPU型号为例：\n1 2 3 4 5  // 获取webgl context var gl = document.createElement(\u0026#34;canvas\u0026#34;).getContext(\u0026#34;webgl\u0026#34;) // 采集GPU render：编号为37446 gl.getExtension(\u0026#34;WEBGL_debug_renderer_info\u0026#34;)[\u0026#34;UNMASKED_RENDERER_WEBGL\u0026#34;] gl.getParameter(37446)   完整的getParameter常量表可以参考：https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\nWebdriver webdriver本质上是浏览器根据w3c实现的一套操作浏览器的接口，而每个浏览器都有一个特定的 WebDriver 实现，如chrome webdriver：https://chromedriver.chromium.org/downloads\n而目前比较广义的定义（或者说黑产使用的方式），通常是指puppeteer/selenium这类，集成了多种浏览器，并提供高级api供上层应用调用的自动化工具；可以直接使用python(selenium)和nodejs(puppeteer)来编写脚本，完成webdriver的控制，从而完成浏览器上的自动化操作。相关资料可以自行搜索学习。\nSpoofWebGL使用方法 此处介绍如何在selenium使用SpoofWebGL工具，当然该工具简单改造后可以在所有的webdriver上使用。\n 将项目clone下来之后，使用可以看到src文件夹下有两个文件，其中manifest.json是extension的配置文件，injected是源码。   之后用zip命令将src文件夹打包：zip -rj extension.zip src/ 将zip后缀名改成.crx(chrome extension的后缀名) ：mv extension.zip extension.crx 编写webdriver脚本如下（注意要先安装好selenium和chrome webdriver），去观察我们的webgl参数读取情况（注意原项目中使用的是firefox的webdriver，所以脚本要做修改）：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver opt = webdriver.ChromeOptions() extension_path = \u0026#39;./extension.crx\u0026#39; opt.add_extension(extension_path) driver = webdriver.Chrome(options=opt) # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   可以看到这个vendor和render已经不太正常了；\n 作为对比，注释掉options直接启动，会显示本机的真实GPU：  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver # opt = webdriver.ChromeOptions() #  # extension_path = \u0026#39;./extension.crx\u0026#39; # opt.add_extension(extension_path) driver = webdriver.Chrome() # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   注：此处是使用浏览器界面模式打开的，实际上如果是启动headless模式，该renderer会和本机的有差别，这也是为什么要使用spoof webgl的原因\n源码分析 总结来说，该extension是将webgl相关的接口全部进行了hook，本质技术难度上并不大，且可以很容易进行定制化。下面开始对hook方法进行分析\nwebdriver相关绕过 开始的第一部分跟webgl检测关系不大，主要是用defineProperty方法对navigator下一些字段进行了hook，绕过webdriver相关的一些检测；主要是设置上浏览器语言，以及将Navigator.webdriver置为false：\n1 2 3 4 5 6 7 8 9 10  Object.defineProperty(navigator, \u0026#39;languages\u0026#39;, { get: function () { var availableLanguages = Array(\u0026#39;en\u0026#39;, \u0026#39;pl\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;ru\u0026#39;, \u0026#39;fr\u0026#39;, \u0026#39;fr-fr\u0026#39;, \u0026#39;lb\u0026#39;, \u0026#39;no\u0026#39;) return [\u0026#39;en-US\u0026#39;, get_random_item(availableLanguages)]; }, }); // fake webdriver property (headless has it as true) Object.defineProperty(navigator, \u0026#39;webdriver\u0026#39;, { get: () =\u0026gt; false, });   WebGL Hook 根据上文中webgl调用示例可知调用webgl接口采集参数主要分为三步：\n 使用getContext获取webgl Context 使用context.getExtension获取webgl拓展的编号 使用context.getParameter获取具体参数的值  对应步骤我们查看该脚本的hook方法：\nHTMLCanvasElement.getContext Hook 要hook该方法，我们需要先定义一个类，如下：\n1 2 3 4 5  function WebGLRenderingContext(canvas) { this.canvas = canvas; this.drawingBufferWidth = canvas.width; this.drawingBufferHeight = canvas.height; };   之后将WebGLRenderingContext中的基本属性和方法进行初始化，即对Object.prototype.attribute进行赋值一个空函数。注意，基础属性本质上都是一些编号，如上文中的例子一样，他是用来传入getParameter做入参的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // 原webgl Context中的基本方法集合 var functions = [ \u0026#39;viewport\u0026#39;, \u0026#39;vertexAttribPointer\u0026#39;, \u0026#39;vertexAttrib4fv\u0026#39;, \u0026#39;vertexAttrib4f\u0026#39;, \u0026#39;vertexAttrib3fv\u0026#39;, ... ] // 原webgl Context中的基本属性集合，这里挑选一些经常被收集的作为例子 var enumerates = { ... \u0026#39;VERSION\u0026#39;: 7938, ... \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446, ... \u0026#39;DEPTH_BITS\u0026#39;: 3414, \u0026#39;GREEN_BITS\u0026#39;: 3411, \u0026#39;BLUE_BITS\u0026#39;: 3412, ... \u0026#39;STENCIL_BITS\u0026#39;: 3415, ... \u0026#39;MAX_VERTEX_UNIFORM_VECTORS\u0026#39;: 36347, \u0026#39;MAX_VERTEX_TEXTURE_IMAGE_UNITS\u0026#39;: 35660, \u0026#39;MAX_VERTEX_ATTRIBS\u0026#39;: 34921, \u0026#39;MAX_VARYING_VECTORS\u0026#39;: 36348, \u0026#39;MAX_TEXTURE_SIZE\u0026#39;: 3379, \u0026#39;MAX_TEXTURE_IMAGE_UNITS\u0026#39;: 34930, \u0026#39;MAX_RENDERBUFFER_SIZE\u0026#39;: 34024, \u0026#39;MAX_FRAGMENT_UNIFORM_VECTORS\u0026#39;: 36349, \u0026#39;MAX_CUBE_MAP_TEXTURE_SIZE\u0026#39;: 34076, \u0026#39;MAX_COMBINED_TEXTURE_IMAGE_UNITS\u0026#39;: 35661, ... }; // 将原本的函数全部替换成空函数 functions.forEach(function (func) { WebGLRenderingContext.prototype[func] = function () { return {}; }; }); Object.keys(enumerates).forEach(function (key) { WebGLRenderingContext.prototype[key] = enumerates[key]; });   实际上原脚本之后马上对context.getExtension完成了赋值，那此处其实顺序不影响执行结果，所以我们留在下一节描述。\n进入hook的代码，实际上document.createElement(\u0026ldquo;canvas\u0026rdquo;).getContext(\u0026quot;webgl\u0026quot;)调用到的是HTMLCanvasElement.getContext方法，所以对该方法进行Hook：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  try { const getContext = HTMLCanvasElement.prototype.getContext; // 利用重定义HTMLCanvasElement.prototype.getContext完成Hook，是常见的hook方法  HTMLCanvasElement.prototype.getContext = function () { // 获取第一个入参，通常为\u0026#34;webgl\u0026#34;，\u0026#39;webgl-experimental\u0026#39;等  var name = arguments[0]; console.log(\u0026#34;HTMLCanvasElement app requested extension: \u0026#34; + name); console.log(JSON.stringify(arguments, null, 4)); if (name == \u0026#39;webgl\u0026#39; || name == \u0026#39;webgl-experimental\u0026#39; || name == \u0026#39;experimental-webgl\u0026#39; || name == \u0026#39;moz-webgl\u0026#39;) { // 最终返回了上文中自定义的类WebGLRenderingContext，完成hook  var y = new WebGLRenderingContext(this); console.log(\u0026#34;WEBGL \u0026#34; + y); console.log(JSON.stringify(y, null, 4)); return y; } // 其他的webgl类型不支持，返回原始数据  if (name == \u0026#39;webgl2\u0026#39; || name == \u0026#39;experimental-webgl2\u0026#39; || name == \u0026#39;fake-webgl\u0026#39;) { console.log(\u0026#34;WEBGL2\u0026#34;) return null; } var ext = getContext.apply(this, arguments); console.log(\u0026#34;HTMLCanvasElement extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(ext); return ext; } } catch (e) { }   context.getExtension定义 实际上很简单，只需要get对应属性时返回指定编号即可，此处以上文中的\u0026quot;WEBGL_debug_renderer_info\u0026quot;为例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var extensions = { // ratified  ... \u0026#39;WEBGL_debug_renderer_info\u0026#39;: { \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446 }, ... } WebGLRenderingContext.prototype.getExtension = function (ext) { console.log(\u0026#34;WebGLRenderingContext.getExtension\u0026#34; + ext); return extensions[ext]; };   注意此处有一些特例是\u0026quot;WEBGL_lose_context\u0026quot;和\n\u0026ldquo;WEBGL_draw_buffers\u0026rdquo;, 他们的属性内部包含方法，需要定义一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function loseContext () { } function restoreContext () { } function drawBuffersWEBGL () { } var extensions = { // ratified  ... \u0026#39;WEBGL_lose_context\u0026#39;: { loseContext, restoreContext }, ... \u0026#39;WEBGL_draw_buffers\u0026#39;: { \u0026#39;MAX_DRAW_BUFFERS_WEBGL\u0026#39;: 34852, \u0026#39;MAX_COLOR_ATTACHMENTS_WEBGL\u0026#39;: 36063, ... drawBuffersWEBGL }, }   context.getParameter 定义，完成取值的Hook 代码可以拆解如下：\n 定义部分，拿到getParameter的参数：  1 2 3 4 5 6 7  try { const getParameter = WebGLRenderingContext.prototype.getParameter; WebGLRenderingContext.prototype.getParameter = function () { var name = arguments[0]; console.log(\u0026#34;WebGLRenderingContext - getParameter: \u0026#34; + name); ... } catch (a) { }    Hook UNMASKED_VENDOR_WEBGL 和UNMASKED_RENDERER_WEBGL 参数，从一个备选列表中随机返回一个vendor/renderer，可以很好的防止收集信息结果过度集中，也可以很方便的进行拓展：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function get_random_item(list) { return list[Math.floor((Math.random() * list.length))]; } WebGLRenderingContext.prototype.getParameter = function () { ... // UNMASKED_VENDOR_WEBGL  if (name == 37445) { var options = [\u0026#39;Intel Open Source Technology Center\u0026#39;, \u0026#39;X.Org\u0026#39;, \u0026#39;Vendor Google Inc.\u0026#39;]; return get_random_item(options); } else if (name == 37446) { // UNMASKED_RENDERER_WEBGL  var options = [\u0026#39;Mesa DRI Intel(R) Ivybridge Mobile\u0026#39;, \u0026#39;AMD KAVERI (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Renderer Google SwiftShader\u0026#39;, \u0026#39;AMD ARUBA (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Mesa DRI Intel(R) HD Graphics 630 (Kaby Lake GT2)\u0026#39;, \u0026#39;Gallium 0.4 on AMD KAVERI (DRM 2.43.0 / 4.4.0-83-generic, LLVM 3.8.0)\u0026#39;]; return get_random_item(options); } ... }    Hook 一些基础属性, 如RENDERER / VENDOR / SHADING_LANGUAGE_VERSION /  VERSION\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 7936) { // RENDERER // VENDOR  return \u0026#39;Mozilla\u0026#39;; } else if (name == 35724) { // SHADING_LANGUAGE_VERSION  return \u0026#39;WebGL GLSL ES 1.0\u0026#39;; } else if (name == 7937 || name == 7938) { // VERSION  return \u0026#39;WebGL 1.0\u0026#39;; } ... }    Hook ALIASED_LINE_WIDTH_RANGE / ALIASED_POINT_SIZE_RANGE, 会返回一个float array，size为2；这里代码有点小问题，不影响功能，name == 7937是VERSION，不过在上面已经判断过了，不会进到这个分支：  1 2 3 4 5 6 7 8 9  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 33901 || name == 33902) { // ALIASED_LINE_WIDTH_RANGE // ALIASED_POINT_SIZE_RANGE  var option = new Float32Array([1, 8192]); return option; } ... }    针对一些webgl位宽信息进行Hook，返回随机值[2, 4, 8, 16]中1个，具体参数见注释：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3413 || name == 3412 || name == 3411 || name == 3410 || name == 34852) { // ALPHA_BITS // BLUE_BITS // GREEN_BITS // RED_BITS // MAX_DRAW_BUFFERS_WEBGL  return get_random_item([2, 4, 8, 16]); } ... }    针对一些位宽信息进行Hook，返回固定值，参数见注释  1 2 3 4 5 6 7 8 9 10 11  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3415) // STENCIL_BITS  return 0; } else if (name == 3414) { // DEPTH_BITS  return 24; } ... }    接下来是该脚本bug的地方，Hook出现问题，如果使用该脚本不加修改，很容易通过此bug识别；原因主要在于以下hook的三个参数值理论上是返回一个整数，但不知为何作者这里使用了get_random_items, 但没有给第二个参数，所以n会为undefined，导致固定返回一个Array：undefined；修复也很简单，换成get_random_item即可。源代码如下：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function get_random_items(list, n) { var result = new Array(n), len = list.length, taken = new Array(len); if (n \u0026gt; len) n = len while (n--) { var x = Math.floor(Math.random() * len); result[n] = list[x in taken ? taken[x] : x]; // 比较巧妙的取随机多个值的方式，留一个array标记如果下次再取到其下标会从目前未取成的最后一个元素  taken[x] = --len in taken ? taken[len] : len; } return result; } WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 34047 || name == 34921) { // MAX_TEXTURE_MAX_ANISOTROPY_EXT // MAX_VERTEX_ATTRIBS  return get_random_items([2, 4, 8, 16]); } else if (name == 35661) { // MAX_COMBINED_TEXTURE_IMAGE_UNITS  return get_random_items([128, 192, 256]); } ... }    对一些其他的MAX相关属性进行Hook，返回随机值，具体属性见注释  1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... } else if (name == 34076 || name == 34024 || name == 3379) { // MAX_CUBE_MAP_TEXTURE_SIZE // MAX_RENDERBUFFER_SIZE  return get_random_item([16384, 32768]) ; } else if (name == 36349 || name == 36347) { // MAX_FRAGMENT_UNIFORM_VECTORS // MAX_VERTEX_UNIFORM_VECTORS  return get_random_item([4096, 8192]); } else if (name == 34930 || name == 36348 || name == 35660) { // MAX_TEXTURE_IMAGE_UNITS // MAX_VARYING_VECTORS // MAX_VERTEX_TEXTURE_IMAGE_UNITS  return get_random_item([16, 32, 64]); } ... }    对MAX_VIEWPORT_DIMS进行Hook，会返回一个长度为2且两个值相等的Int32Array，同样此处随机取值：  1 2 3 4 5 6 7 8 9 10  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3386) { // MAX_VIEWPORT_DIMS  var value = get_random_item([8192, 16384, 32768]) var options = new Int32Array([value, value]); return options; } ... }    最后，剩下的参数统一随机从[0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]随机取值返回(此处还有个冗余分支STENCIL_BITS，上面已经判断过了，属于冗余代码)  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else { console.log(\u0026#34;Retuning random value for: \u0026#34; + name); return get_random_item([0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]); } ... }    最后的迷惑操作：理论上此处已经涵盖了所有的case返回，但是最后还多了个跑不到的分支：  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... var ext = getParameter.apply(this, arguments); console.log(\u0026#34;WebGLRenderingContext extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(JSON.stringify(ext, null, 4)); return ext; }   说实话我猜测此处他是想模拟一些参数，他们在getParameter之前必须先调用getExtension方法后才可以获取，但是此处加在最后属实看不懂，个人理解应该放在这个大if\u0026hellip;else\u0026hellip;前面；有时间我可以好好修复一下这个项目😂😂\n其他的一些被Hook的方法  getSupportedExtension：比较简单，随机从extensions中间选择随机个keys并返回，出现异常则将所有的keys都返回。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // extensions的keys可以参见getExtension部分 const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions; WebGLRenderingContext.prototype.getSupportedExtensions = function () { try { console.log(\u0026#34;WebGLRenderingContext.getSupportedExtensions\u0026#34;) var availableExtensions = Object.keys(extensions); console.log(availableExtensions); var itemsToGet = Math.floor(Math.random() * (availableExtensions.length - 6) + 5); console.log(itemsToGet); var selectedExtensions = get_random_items(availableExtensions, itemsToGet); console.log(selectedExtensions); return selectedExtensions; } catch (a) { console.log(a) return Object.keys(extensions); } }    针对一些headless浏览器有可能会出现canvas的一些属性异常（broken会为0），如canvas的width和height，以及offset，进行Hook，还是使用defineProperty重写get方法对属性进行hook：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // in case of broken image return random height/width var size = 0; [\u0026#39;height\u0026#39;, \u0026#39;width\u0026#39;].forEach(property =\u0026gt; { const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, property); Object.defineProperty(HTMLImageElement.prototype, property, { imageDescriptor, get: function () { // 如果canvas破损，则返回随机size  if (this.complete \u0026amp;\u0026amp; this.naturalHeight == 0) { if (!size) { // 返回随机的长/宽  size = Math.floor(Math.random() * (30 - 10 + 1)) + 10; } return size; } // 未破损则返回正常size  return imageDescriptor.get.apply(this); }, }); }); // hairline feature (headless can\u0026#39;t render it normally) const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;); Object.defineProperty(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;, { ...imageDescriptor, get: function () { if (this.id == \u0026#39;modernizr\u0026#39;) { return 1; } return imageDescriptor.get.apply(this); }, });   插件执行 方法比较简单，将整个大函数作为字符串，最后在html document中新建一个script tag，script.textContent赋值为字符串即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  var scriptCode = \u0026#39;(\u0026#39; + function () { ... function WebGLRenderingContext(canvas) { ... }; ... WebGLRenderingContext.prototype.getExtension = function (ext) { ... }; ... WebGLRenderingContext.prototype.getParameter = function () { ... } ... } + \u0026#39;)();\u0026#39;; // 转成字符串，可直接执行  // 新建script节点插入document中，即自动执行 var script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = scriptCode; (document.head || document.documentElement).appendChild(script); // 最后move掉代码即可 script.remove();   ","description":"SpoofWebGL","id":3,"section":"posts","tags":["黑产工具"],"title":"SpoofWebGL","uri":"https://summersummer3.github.io/posts/spoofwebgl/"},{"content":"问题来源 OpenSSL Engine是啥，在这个地方就不细说了，资料很多，可以看看知乎这篇中文文档:\nhttps://zhuanlan.zhihu.com/p/70444766\n英文文档:\nhttps://wiki.openssl.org/index.php/Creating_an_OpenSSL_Engine_to_use_indigenous_ECDH_ECDSA_and_HASH_Algorithms#Author\n直接进入正题，我们首先查看一个OpenSSL Engine的例子：\nhttps://github.com/nibrunie/OSSL_EngineX\n直接查看bind代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static int bind(ENGINE* e, const char* id) { int ret = 0; if (!ENGINE_set_id(e, engine_id)) { fprintf(stderr, \u0026#34;ENGINE_set_id failed\\n\u0026#34;); goto end; } if (!ENGINE_set_name(e, engine_name)) { printf(\u0026#34;ENGINE_set_name failed\\n\u0026#34;); goto end; } if (!ENGINE_set_digests(e, digest_selector)) { printf(\u0026#34;ENGINE_set_digest failed\\n\u0026#34;); goto end; } ret = 1; end: return ret; } IMPLEMENT_DYNAMIC_BIND_FN(bind) IMPLEMENT_DYNAMIC_CHECK_FN()   可以看到OpenSSL去加载Engine的动态库时，需要动态库去调用 IMPLEMENT_DYNAMIC_BIND_FN 完成engine绑定初始化。\n基本上所以教你写engine的教程到这就结束了，但是内部到底是怎么要关联上这个函数，并且触发上面的bind函数的呢？我们先来看看这个宏的具体定义：\n1 2 3 4 5 6 7 8 9 10 11 12  \\# define IMPLEMENT_DYNAMIC_BIND_FN(fn) \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \\ if (ENGINE_get_static_state() == fns-\u0026gt;static_state) goto skip_cbs; \\ CRYPTO_set_mem_functions(fns-\u0026gt;mem_fns.malloc_fn, \\ fns-\u0026gt;mem_fns.realloc_fn, \\ fns-\u0026gt;mem_fns.free_fn); \\ skip_cbs: \\ if (!fn(e, id)) return 0; \\ /* 调用了上面例子中的bind函数 */ return 1; }   可以看到此处定义了函数bind_engine，他会去执行用宏包裹住的函数，以完成初始化。然而你去搜索这个函数在OpenSSL中调用你一定会很失望，肯定没有你想要的结果。果然不是这么简单的，又是什么钩子挂在了什么ctx上吧，应该也不难。\n我找了不少资料，基本没发现啥靠谱的分析，没办法自己看源码吧。结果经过分析，我深刻的理解了OpenSSL的魔鬼调用，钩子的挂载可以说是很魔幻。此处源码分析基于目前的主线master，应该也是未来OpenSSL 3.0的架构了。\n至于Engine是怎么设置上重置后的密码算法的，将在后续更新。\n从加载Engine的main函数分析起 还是上面的例子，我们查看执行engine加载的可执行程序的源码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int main(void) { // initializing OpenSSL library  OPENSSL_load_builtin_modules(); ENGINE_load_dynamic(); // building OpenSSL\u0026#39;s configuration file path  char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { fprintf(stderr, \u0026#34;OpenSSL failed to load required configuration\\n\u0026#34;); ERR_print_errors_fp(stderr); return 1; } ENGINE* eng = ENGINE_by_id(\u0026#34;engineX\u0026#34;); if(NULL == eng) { printf(\u0026#34;failed to retrieve engine by id (mppa)\\n\u0026#34;); return 1; } printf(\u0026#34;EngineX has been successfully loaded \\n\u0026#34;); ... }   可以看到我们这个例子是从一个cnf配置文件去加载对应的engine的，这里提一句，加载engine有几个方式，如命令行加载，手动代码加载等。这里用配置文件加载做例子是因为这个场景更加接近实际业务场景，而且流程基本涵盖全流程，值得源码去分析。接下来我们按照调用顺序来分析这样一个漫长的调用过程。\nOPENSSL_load_builtin_modules 第一个函数，初始化了一个默认的conf_module, 且名字叫做\u0026rsquo;engines\u0026rsquo;。直接看源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void OPENSSL_load_builtin_modules(void) { ... /* 我们其他的都不重要，直接看这个和Engine相关的 */ #ifndef OPENSSL_NO_ENGINE  ENGINE_add_conf_module(); #endif \t... } void ENGINE_add_conf_module(void) { CONF_module_add(\u0026#34;engines\u0026#34;, int_engine_module_init, int_engine_module_finish); }   来到我们的第一个大坑，OpenSSL的动态配置文件加载，但这里我们不需要细致了解，先简单分析下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  int CONF_module_add(const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { if (module_add(NULL, name, ifunc, ffunc)) return 1; else return 0; } /* 重要的结构体与全局变量 */ static STACK_OF(CONF_MODULE) *supported_modules = NULL; static STACK_OF(CONF_IMODULE) *initialized_modules = NULL; struct conf_module_st { /* DSO of this module or NULL if static */ DSO *dso; /* Name of the module */ char *name; /* Init function */ conf_init_func *init; /* Finish function */ conf_finish_func *finish; /* Number of successfully initialized modules */ int links; void *usr_data; }; typedef struct conf_module_st CONF_MODULE; static CONF_MODULE *module_add(DSO *dso, const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { CONF_MODULE *tmod = NULL; /* 若supported_modules为空， 则初始化此全局变量，即堆栈的初始化 */ if (supported_modules == NULL) supported_modules = sk_CONF_MODULE_new_null(); if (supported_modules == NULL) return NULL; /* 申请配置文件模块结构体conf_module_st的空间 */ if ((tmod = OPENSSL_zalloc(sizeof(*tmod))) == NULL) { CONFerr(CONF_F_MODULE_ADD, ERR_R_MALLOC_FAILURE); return NULL; } /* * 此处第一次调用，dso为NULL； * dso = dynamic shared object, 可以理解为是一个OpenSSL去加载动态库的结构体； */ tmod-\u0026gt;dso = dso; /* 此处记住，将初始化一个叫\u0026#34;engines\u0026#34;的conf_module */ tmod-\u0026gt;name = OPENSSL_strdup(name); /* 配置文件init函数， 此处即int_engine_module_init。这个函数是关键 */ tmod-\u0026gt;init = ifunc; /* 配置文件finish函数， 此处即int_engine_module_finish */ tmod-\u0026gt;finish = ffunc; if (tmod-\u0026gt;name == NULL) { OPENSSL_free(tmod); return NULL; } /* 将这个的conf_module结构体入栈进supported_modules这个全局变量栈中 */ if (!sk_CONF_MODULE_push(supported_modules, tmod)) { OPENSSL_free(tmod-\u0026gt;name); OPENSSL_free(tmod); return NULL; } return tmod; }   此处有一个OpenSSL的一个知识点，OpenSSL中可以定义任意类型的安全栈，并且生成操作这个类型栈的函数族。例如有一个结构体叫XX，则可以通过DEFINE_STACK_OF(XX)这个宏来定义XX结构体的栈和函数族，通过STACK_OF(XX)来声明一个栈。事实上，当我们看OpenSSL源码时看到sk_这种前缀的都是堆栈操作，而且是搜索不到实现的 (1.0.2版本应该可以找到，之后的版本都泛化了，代码写的秀，看代码的自闭)。\n详见官方文档：https://www.openssl.org/docs/man1.1.0/man3/DEFINE_STACK_OF.html\n此处有两个栈操作: 初始化时supported_modules为空，所以将调用sk_CONF_MODULE_new_null先建立上一个空容器。之后sk_CONF_MODULE_push使上面初始化的的CONF_MODULE入栈，之后想要取到这个module则需要通过supported_modules这个全局栈来取。\n此处多提一句，OpenSSL还有一个类似的结构体LHASH，它是OpenSSL内部的哈希表，如果这篇文章有下我们应该会碰到它，直接理解成是一个kv_map就好。所有lh_前缀开头的也都是哈希表操作。\nENGINE_load_dynamic 第二个函数，比较绕，简单理解就是：初始化了一个engine, 名字叫做dynamic，OpenSSL用这个engine来动态加载别的engine\u0026hellip;\n顺便提一句，ENGINE_load_dynamic 在1.1.x版本已经废弃了，统一都是调用OPENSSL_init_crypto这个函数，opts = OPENSSL_INIT_ENGINE_DYNAMIC。这又是OpenSSL非常恶心的地方了，版本兼容可以说是相当emmmmmmmm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \\# define ENGINE_load_dynamic() \\ OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_DYNAMIC, NULL) int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings) { ... /* * RUN_ONCE是多线程时需要关心的，我们这里不关心，就等于调用ossl_init_engine_dynamic * 最后一波宏展开，调用的是 engine_load_dynamic_int 这个函数 */ if ((opts \u0026amp; OPENSSL_INIT_ENGINE_DYNAMIC) \u0026amp;\u0026amp; !RUN_ONCE(\u0026amp;engine_dynamic, ossl_init_engine_dynamic)) return 0; ... } void engine_load_dynamic_int(void) { ENGINE *toadd = engine_dynamic(); /* 这命名真是绝了Orz */ if (!toadd) return; ENGINE_add(toadd); /* * If the \u0026#34;add\u0026#34; worked, it gets a structural reference. So either way, we * release our just-created reference. */ ENGINE_free(toadd); /* * If the \u0026#34;add\u0026#34; didn\u0026#39;t work, it was probably a conflict because it was * already added (eg. someone calling ENGINE_load_blah then calling * ENGINE_load_builtin_engines() perhaps). */ ERR_clear_error(); }   engine_dynamic 两个核心函数，第一个 engine_dynamic 新建了一个id叫做'dynamic'的engine，挂上了这个engine的具体处理函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static ENGINE *engine_dynamic(void) { /* OpenSSL申请结构体空间经常使用的xx_new */ ENGINE *ret = ENGINE_new(); if (ret == NULL) return NULL; if (!ENGINE_set_id(ret, engine_dynamic_id) || !ENGINE_set_name(ret, engine_dynamic_name) || !ENGINE_set_init_function(ret, dynamic_init) || !ENGINE_set_finish_function(ret, dynamic_finish) || !ENGINE_set_ctrl_function(ret, dynamic_ctrl) || !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) || !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) { ENGINE_free(ret); return NULL; } return ret; }   我们扫一眼ENGINE结构体，首先要有一个概念，ENGINE_set_xx 就是去设置这个结构体的相应字段，所以可以记录一下这个结构体被初始化成啥样了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct engine_st { const char *id; const char *name; const RSA_METHOD *rsa_meth; const DSA_METHOD *dsa_meth; const DH_METHOD *dh_meth; const EC_KEY_METHOD *ec_meth; const RAND_METHOD *rand_meth; /* Cipher handling is via this callback */ ENGINE_CIPHERS_PTR ciphers; /* Digest handling is via this callback */ ENGINE_DIGESTS_PTR digests; /* Public key handling via this callback */ ENGINE_PKEY_METHS_PTR pkey_meths; /* ASN1 public key handling via this callback */ ENGINE_PKEY_ASN1_METHS_PTR pkey_asn1_meths; ENGINE_GEN_INT_FUNC_PTR destroy; ENGINE_GEN_INT_FUNC_PTR init; ENGINE_GEN_INT_FUNC_PTR finish; ENGINE_CTRL_FUNC_PTR ctrl; ENGINE_LOAD_KEY_PTR load_privkey; ENGINE_LOAD_KEY_PTR load_pubkey; ENGINE_SSL_CLIENT_CERT_PTR load_ssl_client_cert; const ENGINE_CMD_DEFN *cmd_defns; int flags; /* reference count on the structure itself */ CRYPTO_REF_COUNT struct_ref; /* * reference count on usability of the engine type. NB: This controls the * loading and initialisation of any functionality required by this * engine, whereas the previous count is simply to cope with * (de)allocation of this structure. Hence, running_ref \u0026lt;= struct_ref at * all times. */ int funct_ref; /* A place to store per-ENGINE data */ CRYPTO_EX_DATA ex_data; /* Used to maintain the linked-list of engines. */ struct engine_st *prev; struct engine_st *next; }   整理如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  static const char *engine_dynamic_id = \u0026#34;dynamic\u0026#34;; static const char *engine_dynamic_name = \u0026#34;Dynamic engine loading support\u0026#34;; static const ENGINE_CMD_DEFN dynamic_cmd_defns[] = { {DYNAMIC_CMD_SO_PATH, \u0026#34;SO_PATH\u0026#34;, \u0026#34;Specifies the path to the new ENGINE shared library\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_NO_VCHECK, \u0026#34;NO_VCHECK\u0026#34;, \u0026#34;Specifies to continue even if version checking fails (boolean)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_ID, \u0026#34;ID\u0026#34;, \u0026#34;Specifies an ENGINE id name for loading\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LIST_ADD, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_LOAD, \u0026#34;DIR_LOAD\u0026#34;, \u0026#34;Specifies whether to load from \u0026#39;DIR_ADD\u0026#39; directories (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_ADD, \u0026#34;DIR_ADD\u0026#34;, \u0026#34;Adds a directory from which ENGINEs can be loaded\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LOAD, \u0026#34;LOAD\u0026#34;, \u0026#34;Load up the ENGINE specified by other settings\u0026#34;, ENGINE_CMD_FLAG_NO_INPUT}, {0, NULL, NULL, 0} }; /* 加载动态engine时的命令 */ # define ENGINE_FLAGS_BY_ID_COPY (int)0x0004  ENGINE dynamic = {.id = engine_dynamic_id, .name = engine_dynamic_name, .init = dynamic_init, /* 空函数，直接return 0 */ .finish = dynamic_finish, /* 空函数，直接return 0 */ .ctrl = dynamic_ctrl, /* 最重要的函数，后文将分析如何调用到这来 */ .flags = ENGINE_FLAGS_BY_ID_COPY， .cmd_defns = dynamic_cmd_defns /*定义了dynamic这个engine ctrl下的合法cmd*/ .prev = NULL, .next = NULL /* 说明engine都是以双向链表形式管理 */ };   完成初始化后，将返回上这个new出来的ENGINE结构体。随后丢到ENGINE_add 里。\nENGINE_add 上面结构体分析其实已经可以看到，所有的engine都将以双向链表形式管理，链表建立简单粗暴，直接定义全局变量一头一尾，添加时就往尾巴加，搜索就从头结点开始搜索：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  static ENGINE *engine_list_head = NULL; static ENGINE *engine_list_tail = NULL; /* Add another \u0026#34;ENGINE\u0026#34; type into the list. */ int ENGINE_add(ENGINE *e) { int to_return = 1; /* 一些入参检查，omit */ ... /* 全局变量操作时需要加锁以支持多线程 */ CRYPTO_THREAD_write_lock(global_engine_lock); /* 核心函数，将刚刚new出来的dynamic加入全局链表中 */ if (!engine_list_add(e)) { ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR); to_return = 0; } CRYPTO_THREAD_unlock(global_engine_lock); return to_return; } static int engine_list_add(ENGINE *e) { int conflict = 0; ENGINE *iterator = NULL; if (e == NULL) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER); return 0; } /* 从链表头开始迭代 */ iterator = engine_list_head; /* 直接遍历到尾部查看有没有重id的情况，重id直接报错退出 */ while (iterator \u0026amp;\u0026amp; !conflict) { conflict = (strcmp(iterator-\u0026gt;id, e-\u0026gt;id) == 0); iterator = iterator-\u0026gt;next; } if (conflict) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } if (engine_list_head == NULL) { /* We are adding to an empty list. */ if (engine_list_tail) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* engine_list为空的话则链表头为新建的engine */ engine_list_head = e; e-\u0026gt;prev = NULL; /* * The first time the list allocates, we should register the cleanup. */ engine_cleanup_add_last(engine_list_cleanup); } else { /* We are adding to the tail of an existing list. */ if ((engine_list_tail == NULL) || (engine_list_tail-\u0026gt;next != NULL)) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* 将新engine加到队尾的后面 */ engine_list_tail-\u0026gt;next = e; e-\u0026gt;prev = engine_list_tail; } /* * Having the engine in the list assumes a structural reference. */ e-\u0026gt;struct_ref++; engine_ref_debug(e, 0, 1); /* 将队尾指向新engine */ engine_list_tail = e; e-\u0026gt;next = NULL; return 1; }   这样，id为'dynamic'被加入了全局engine列表当中，被管理起来。\nCONF 我们这里对OpenSSL的动态配置conf不需要细致分析，随着代码分析即可。官方文档其实对conf格式讲解的很清楚，可以学习:\nhttps://www.openssl.org/docs/man1.1.1/man5/config.html\nEngine Configuration Module这个小节\n例子中conf文件 首先我们来看engineX例子中的conf是怎么写的：\nopenssl_conf = openssl_def [openssl_def] engines = engine_section [engine_section] engine_x = engine_x_section [engine_x_section] engine_id = engineX dynamic_path = ${ENV::PWD}/build/engine_ex.so default_algorithms = ALL init = 1 简单学习一下conf之后，我们之后这个配置文件核心的section就是engine_section，其中dynamic_path定义上了该engine共享库的路径。我们看看例子中是如何根据这个配置文件去加载对应的engine的\nCONF_modules_load_file 1 2 3 4 5 6 7 8  ... char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { ... } ...   CONF_modules_load_file是去加载配置并使能配置的接口，这里我们主要关心如何去根据配置文件去加载动态库，具体怎么完成配置文件解析的流程这里不讨论。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  int CONF_modules_load_file(const char *filename, const char *appname, unsigned long flags) { return CONF_modules_load_file_with_libctx(NULL, filename, appname, flags); } int CONF_modules_load_file_with_libctx(OPENSSL_CTX *libctx, const char *filename, const char *appname, unsigned long flags) { char *file = NULL; CONF *conf = NULL; int ret = 0; conf = NCONF_new_with_libctx(libctx, NULL); if (conf == NULL) goto err; if (filename == NULL) { file = CONF_get1_default_config_file(); if (file == NULL) goto err; } else { file = (char *)filename; } if (NCONF_load(conf, file, NULL) \u0026lt;= 0) { if ((flags \u0026amp; CONF_MFLAGS_IGNORE_MISSING_FILE) \u0026amp;\u0026amp; (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) { ERR_clear_error(); ret = 1; } goto err; } ret = CONF_modules_load(conf, appname, flags); err: if (filename == NULL) OPENSSL_free(file); NCONF_free(conf); if (flags \u0026amp; CONF_MFLAGS_IGNORE_RETURN_CODES) return 1; return ret; }   可以看到这里主要有三步操作NCONF_new_with_libctx、NCONF_load、CONF_modules_load，我们一个一个分析。\nNCONF_new_with_libctx 这个函数主要是初始化上了一个CONF结构体，同时将这个结构体的METHOD定义成了默认方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  /* 配置文件的method模板 */ struct conf_method_st { const char *name; CONF *(*create) (CONF_METHOD *meth); int (*init) (CONF *conf); int (*destroy) (CONF *conf); int (*destroy_data) (CONF *conf); int (*load_bio) (CONF *conf, BIO *bp, long *eline); int (*dump) (const CONF *conf, BIO *bp); int (*is_number) (const CONF *conf, char c); int (*to_int) (const CONF *conf, char c); int (*load) (CONF *conf, const char *name, long *eline); }; /* * 所有的 AA = BB 都会按照这个格式保存 * 如[openssl_def] engines = engine_section * 此时这个底下conf_st的哈希表中将保存上一份 * {.section = \u0026#34;openssl_def\u0026#34;, .name = \u0026#34;engines\u0026#34;, value = \u0026#34;engine_section\u0026#34;} */ typedef struct { char *section; char *name; char *value; } CONF_VALUE; struct conf_st { CONF_METHOD *meth; /* 动态配置的方法，这里使用default */ void *meth_data; LHASH_OF(CONF_VALUE) *data; /* 上文有提到的哈希表 */ unsigned int flag_dollarid:1; OPENSSL_CTX *libctx; }; /* * The following section contains the \u0026#34;New CONF\u0026#34; functions. They are * completely centralised around a new CONF structure that may contain * basically anything, but at least a method pointer and a table of data. * These functions are also written in terms of the bridge functions used by * the \u0026#34;CONF classic\u0026#34; functions, for consistency. */ CONF *NCONF_new_with_libctx(OPENSSL_CTX *libctx, CONF_METHOD *meth) { CONF *ret; if (meth == NULL) meth = NCONF_default(); ret = meth-\u0026gt;create(meth); if (ret == NULL) { CONFerr(0, ERR_R_MALLOC_FAILURE); return NULL; } /* 这个流程中是NULL，不需要分析 */ ret-\u0026gt;libctx = libctx; return ret; }   我们先看NCONF_default：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* 标记上这些方法，相关定义后续会给出，且将会使用 */ static CONF_METHOD default_method = { \u0026#34;OpenSSL default\u0026#34;, def_create, def_init_default, def_destroy, def_destroy_data, def_load_bio, def_dump, def_is_number, def_to_int, def_load }; CONF_METHOD *NCONF_default(void) { return \u0026amp;default_method; }   第一个在default_method被使用的方法就是def_create, 很明显是去申请一块CONF结构体内存，之后调用def_init_default去初始化结构体 :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  static CONF *def_create(CONF_METHOD *meth) { CONF *ret; ret = OPENSSL_malloc(sizeof(*ret)); if (ret != NULL) /* 这里调用`def_init_default` */ if (meth-\u0026gt;init(ret) == 0) { OPENSSL_free(ret); ret = NULL; } return ret; } static int def_init_default(CONF *conf) { if (conf == NULL) return 0; memset(conf, 0, sizeof(*conf)); /* 将新申请的CONF结构体的method字段设置为默认method */ conf-\u0026gt;meth = \u0026amp;default_method; /* meth_data的设置，这个是.conf文件字符解析时候使用的，我们这里不讲 */ conf-\u0026gt;meth_data = (void *)CONF_type_default; return 1; }   NCONF_load 初始化好CONF结构体，确定好对应配置文件名，开始对配置文件进行解析，NCONF_load （OpenSSL连配置文件格式都自己定义自己解析，硬核硬核）将调用到默认方法之 def_load\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  int NCONF_load(CONF *conf, const char *file, long *eline) { if (conf == NULL) { CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF); return 0; } return conf-\u0026gt;meth-\u0026gt;load(conf, file, eline); } static int def_load(CONF *conf, const char *name, long *line) { int ret; BIO *in = NULL; /* 这里通过BIO读入文件(Binary IO, openssl自己定义的io，简单理解就是一块内存Orz) */ #ifdef OPENSSL_SYS_VMS  in = BIO_new_file(name, \u0026#34;r\u0026#34;); #else  in = BIO_new_file(name, \u0026#34;rb\u0026#34;); #endif \t... /* 正式解析，按段解析； * 这里不分析咋解析的，很复杂很长，甚至能处理一些环境变量$(xxx)... 服 * 最后结果都存在哈希表data中 */ ret = def_load_bio(conf, in, line); BIO_free(in); return ret; }   CONF_modules_load 核心过程，从CONF去加载第一部分提到的'engines'这个module:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  int CONF_modules_load(const CONF *cnf, const char *appname, unsigned long flags) { STACK_OF(CONF_VALUE) *values; CONF_VALUE *vl; char *vsection = NULL; int ret, i; if (!cnf) return 1; /* 先获取到对应的section名，这里就是\u0026#34;openssl_conf\u0026#34; */ if (appname) vsection = NCONF_get_string(cnf, NULL, appname); if (!appname || (!vsection \u0026amp;\u0026amp; (flags \u0026amp; CONF_MFLAGS_DEFAULT_SECTION))) vsection = NCONF_get_string(cnf, NULL, \u0026#34;openssl_conf\u0026#34;); if (!vsection) { ERR_clear_error(); return 1; } OSSL_TRACE1(CONF, \u0026#34;Configuration in section %s\\n\u0026#34;, vsection); /* * 找到第一个段 openssl_conf * [openssl_def] * engines = engine_section */ values = NCONF_get_section(cnf, vsection); if (!values) return 0; for (i = 0; i \u0026lt; sk_CONF_VALUE_num(values); i++) { vl = sk_CONF_VALUE_value(values, i); /* 遍历所有的value，这里只有一个 \u0026#39;engines\u0026#39; */ ret = module_run(cnf, vl-\u0026gt;name, vl-\u0026gt;value, flags); OSSL_TRACE3(CONF, \u0026#34;Running module %s (%s) returned %d\\n\u0026#34;, vl-\u0026gt;name, vl-\u0026gt;value, ret); if (ret \u0026lt;= 0) if (!(flags \u0026amp; CONF_MFLAGS_IGNORE_ERRORS)) return ret; } return 1; } static int module_run(const CONF *cnf, const char *name, const char *value, unsigned long flags) { CONF_MODULE *md; int ret; if (!RUN_ONCE(\u0026amp;load_builtin_modules, do_load_builtin_modules)) return -1; /* 这里会在supported_modules这个栈上找到\u0026#39;engines\u0026#39;这个CONF_MODULE，开始魔幻表演 */ md = module_find(name); ... /* init这个module，这里将去调用到\u0026#39;dynamic\u0026#39;这个engine，下面将分析 */ ret = module_init(md, name, value, cnf); ... return ret; } /* initialize a module */ /* 此处将申请上一个所谓的initialized module， * 之后调用\u0026#39;engines\u0026#39;的init函数 * 若成功，将\u0026#39;engines\u0026#39; push进的全局变量栈 initialized_modules */ static int module_init(CONF_MODULE *pmod, const char *name, const char *value, const CONF *cnf) { int ret = 1; int init_called = 0; CONF_IMODULE *imod = NULL; /* Otherwise add initialized module to list */ imod = OPENSSL_malloc(sizeof(*imod)); if (imod == NULL) goto err; imod-\u0026gt;pmod = pmod; imod-\u0026gt;name = OPENSSL_strdup(name); /* 即\u0026#39;engines\u0026#39; */ imod-\u0026gt;value = OPENSSL_strdup(value); imod-\u0026gt;usr_data = NULL; if (!imod-\u0026gt;name || !imod-\u0026gt;value) goto memerr; /* Try to initialize module */ if (pmod-\u0026gt;init) { /* 调用engines的init，即第一部分提到的int_engine_module_init函数 */ ret = pmod-\u0026gt;init(imod, cnf); init_called = 1; /* Error occurred, exit */ if (ret \u0026lt;= 0) goto err; } if (initialized_modules == NULL) { initialized_modules = sk_CONF_IMODULE_new_null(); if (!initialized_modules) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } } /* 将\u0026#39;engines\u0026#39; push进的全局变量栈 initialized_modules */ if (!sk_CONF_IMODULE_push(initialized_modules, imod)) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } pmod-\u0026gt;links++; return ret; err: ... }   CONF的第一部分处理完毕，开始查看如何继续解析这个配置\nint_engine_module_init 这部分开始取engines这个section下的数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  static int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf) { STACK_OF(CONF_VALUE) *elist; CONF_VALUE *cval; int i; OSSL_TRACE2(CONF, \u0026#34;Called engine module: name %s, value %s\\n\u0026#34;, CONF_imodule_get_name(md), CONF_imodule_get_value(md)); /* Value is a section containing ENGINEs to configure */ elist = NCONF_get_section(cnf, CONF_imodule_get_value(md)); /* * 获取engine_section下的列表，这里就一个section叫做engine_x_section * [engine_section] * engine_x = engine_x_section */ if (!elist) { ENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT, ENGINE_R_ENGINES_SECTION_ERROR); return 0; } for (i = 0; i \u0026lt; sk_CONF_VALUE_num(elist); i++) { cval = sk_CONF_VALUE_value(elist, i); /* * name: engine_x, value: engine_x_section * 准备开始加载了 */ if (!int_engine_configure(cval-\u0026gt;name, cval-\u0026gt;value, cnf)) return 0; } return 1; }   int_engine_configure 是加载engine的主要流程，我们按顺序来一步一步分析内部的循环\nint_engine_configure  首先加载上value的section：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { int i; int ret = 0; long do_init = -1; STACK_OF(CONF_VALUE) *ecmds; CONF_VALUE *ecmd = NULL; const char *ctrlname, *ctrlvalue; ENGINE *e = NULL; int soft = 0; name = skip_dot(name); OSSL_TRACE1(CONF, \u0026#34;Configuring engine %s\\n\u0026#34;, name); /* Value is a section containing ENGINE commands */ /* 在conf的哈希表中找 叫做engine_x_section的section */ ecmds = NCONF_get_section(cnf, value); /* * 此时ecmds是一个栈，按顺序有以下CONF_VALUE (共有section = \u0026#34;engine_x_section\u0026#34;) * {.name = \u0026#34;engine_id\u0026#34;, .value = \u0026#34;engineX\u0026#34;} * {.name = \u0026#34;dynamic_path\u0026#34;, .value = \u0026#34;${ENV::PWD}/build/engine_ex.so\u0026#34;(这里已经通配符解析\t*\t了)} * {.name = \u0026#34;default_algorithms\u0026#34;, .value = \u0026#34;ALL\u0026#34;} * {.name = \u0026#34;init\u0026#34;, .value = \u0026#34;1\u0026#34;} */ if (!ecmds) { ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE, ENGINE_R_ENGINE_SECTION_ERROR); return 0; } ... }    按照顺序解析：\n第一个是engine_id:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { ... /* 开始对ecmds中栈上的CONF_VALUE遍历，这部分代码都在这个for循环中 */ for (i = 0; i \u0026lt; sk_CONF_VALUE_num(ecmds); i++) { ecmd = sk_CONF_VALUE_value(ecmds, i); /* 解析出ctrlname和ctrlvalue，对应结构体中.name和.value, 下同 */ ctrlname = skip_dot(ecmd-\u0026gt;name); ctrlvalue = ecmd-\u0026gt;value; OSSL_TRACE2(CONF, \u0026#34;ENGINE: doing ctrl(%s,%s)\\n\u0026#34;, ctrlname, ctrlvalue); /* First handle some special pseudo ctrls */ /* Override engine name to use */ if (strcmp(ctrlname, \u0026#34;engine_id\u0026#34;) == 0) /* 把name制成conf文件中engine_id */ name = ctrlvalue; ... } ... }   第二个是dynamic_path， 这个定义最关键，找到这个name，开始按照指定路径加载动态库engine:\nfor(\u0026hellip;) {\n\u0026hellip;\nelse if (strcmp(ctrlname, \u0026ldquo;dynamic_path\u0026rdquo;) == 0) {\n/*\n* 看到这里是不是豁然开朗，首先找到第二部分初始化的叫做dynamic的engine\n* 但这个地方有个值得注意的点，底下分析ENGINE_by_id\n/\ne = ENGINE_by_id(\u0026ldquo;dynamic\u0026rdquo;);\n/ 拿到\u0026rsquo;dynamic\u0026rsquo;这个ENGINE结构体后，进行三步操作，完成了engineX这个so的加载 /\n/ 之后我们将单独把ENGINE_ctrl_cmd_string拿出来分析，观察它是如何去加载的*/\nif (!e)\ngoto err;\nif (!ENGINE_ctrl_cmd_string(e, \u0026ldquo;SO_PATH\u0026rdquo;, ctrlvalue, 0))\ngoto err;\nif (!ENGINE_ctrl_cmd_string(e, \u0026ldquo;LIST_ADD\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, 0))\ngoto err;\nif (!ENGINE_ctrl_cmd_string(e, \u0026ldquo;LOAD\u0026rdquo;, NULL, 0))\ngoto err;\n\u0026hellip;\n}\n/*\n   完成这三步操作后，\u0026lsquo;dynamic\u0026rsquo;副本这个engine已经被重写成了 \u0026rsquo;engineX\u0026rsquo;！ 同时这个engineX也加入了engines的队列中。\n*/  ENGINE *ENGINE_by_id(const char id)\n{\n/ 入参检查和环境初始化检查 omit /\n\u0026hellip;\n/ 加锁后开始遍历链表，匹配id = \u0026ldquo;dynamic\u0026rdquo; */\nCRYPTO_THREAD_write_lock(global_engine_lock);\niterator = engine_list_head;\n while (iterator \u0026amp;\u0026amp; (strcmp(id, iterator-\u0026gt;id) != 0)) iterator = iterator-\u0026gt;next; if (iterator != NULL) { /* * We need to return a structural reference. If this is an ENGINE * type that returns copies, make a duplicate - otherwise increment * the existing ENGINE's reference count. */ /* 匹配成功后的小操作：看ENGINE_load_dynamic源码可以看到 dynamic-\u0026gt;flag 被设置成了\tENGINE_FLAGS_BY_ID_COPY */ if (iterator-\u0026gt;flags \u0026amp; ENGINE_FLAGS_BY_ID_COPY) { ENGINE *cp = ENGINE_new(); if (cp == NULL) iterator = NULL; else { /* 此处很重要！ */ /* 此处取出的dynamic，不是直接取出链表中的engine节点，而是复制了一个节点 */ engine_cpy(cp, iterator); iterator = cp; } } else { iterator-\u0026gt;struct_ref++; engine_ref_debug(iterator, 0, 1); } } CRYPTO_THREAD_unlock(global_engine_lock); if (iterator != NULL) /* 作为取出返回值，得到了一个dynamic的副本 */ return iterator;  }\n注意，此时e这个局部变量已经是一个id为'engineX'的ENGINE结构体了，也就是完成了动态加载的engine！\n第三步是default_algorithms，有缘的话，这篇文章第二部分会分析设置过程 :\n1 2 3 4 5  for (...) { else if (strcmp(ctrlname, \u0026#34;default_algorithms\u0026#34;) == 0) { if (!ENGINE_set_default_string(e, ctrlvalue)) ... }   第四步，完成Init:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  for (...) { if (strcmp(ctrlname, \u0026#34;init\u0026#34;) == 0) { if (!NCONF_get_number_e(cnf, value, \u0026#34;init\u0026#34;, \u0026amp;do_init)) goto err; if (do_init == 1) { /* * 此处为1，完成engine init, * 具体代码就是调用ENGINE_init去执行e-\u0026gt;init, 增加引用数之类的，我们这里其实是空的 * 之后去把这个engine同时加入initialized_engines这个全局变量栈中。代码不看了 */ if (!int_engine_init(e)) goto err; ... }   就此CONF_modules_load全部运行完成，engineX加载完毕。后续只需要像main函数中的使用ENGINE_by_id(\u0026quot;engineX\u0026quot;);就可以取得这个engine了。圆满。\n但是 bind_engine 在哪调用的呢，还是没看到，那必然是在ENGINE_ctrl_cmd_string流程中。所以下面重点讲讲这个函数。\nENGINE_ctrl_cmd_string 从cmd_name去获取cmd_num int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { int num, flags; long l; char *ptr; ... /* 宏的命名已经暴露了一切，通过cmd_name得到cmd_num */ if (e-\u0026gt;ctrl == NULL || (num = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FROM_NAME, 0, (void *)cmd_name, NULL)) \u0026lt;= 0) { ... } ... } int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... /* * Intercept any \u0026#34;root-level\u0026#34; commands before trying to hand them on to * ctrl() handlers. */ switch (cmd) { /* 这部分是通用的ctrl，范围为10 ~ 18, 全部进入int_ctrl_helper */ case ENGINE_CTRL_HAS_CTRL_FUNCTION: return ctrl_exists; case ENGINE_CTRL_GET_FIRST_CMD_TYPE: case ENGINE_CTRL_GET_NEXT_CMD_TYPE: case ENGINE_CTRL_GET_CMD_FROM_NAME: case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: case ENGINE_CTRL_GET_NAME_FROM_CMD: case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: case ENGINE_CTRL_GET_DESC_FROM_CMD: case ENGINE_CTRL_GET_CMD_FLAGS: /* * 这里dynamic的flag为ENGINE_FLAGS_BY_ID_COPY，0x0004 * ENGINE_FLAGS_MANUAL_CMD_CTRL = 0x0002，与的结果为0 */ if (ctrl_exists \u0026amp;\u0026amp; !(e-\u0026gt;flags \u0026amp; ENGINE_FLAGS_MANUAL_CMD_CTRL)) return int_ctrl_helper(e, cmd, i, p, f); if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); /* * For these cmd-related functions, failure is indicated by a -1 * return value (because 0 is used as a valid return in some * places). */ return -1; } default: break; } /* Anything else requires a ctrl() handler to exist. */ /* 这里是确定当前engine-\u0026gt;ctrl != NULL */ if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); return 0; } /* 调用上面看到的 dynamic-\u0026gt;ctrl = dynamic_ctrl, 后面会调用到这来 */ return e-\u0026gt;ctrl(e, cmd, i, p, f); } /* 这个函数也将反复调用（吐槽下openssl这鬼之设计），我们这里先看当前的cmd */ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { int idx; char *s = (char *)p; const ENGINE_CMD_DEFN *cdp; ... /* Now handle cmd_name -\u0026gt; cmd_num conversion */ if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) { /* 从dynamic的cmd_defns中去匹配cmd_name,假设是\u0026#34;SO_PATH\u0026#34;, 直接去查第二部分的dynamic_cmd_defns，刚好匹配上idx = 0 */ if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(e-\u0026gt;cmd_defns, s)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME); return -1; } /* 查idx = 0时的 cmd_num = 200 = DYNAMIC_CMD_SO_PATH */ return e-\u0026gt;cmd_defns[idx].cmd_num; } ... } 可以看到这里的num返回回来的DYNAMIC_CMD_SO_PATH，是靠dynamic.cmd_defns中的ENGINE_CMD_DEFN数组表查询得到的。往下接着看ENGINE_ctrl_cmd_string\nint ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { /* 继续调用公用ctrl，进入到int_ctrl_helper (看底下开源的注释，两个函数做的ctrl操作一样的，为啥这么搞也许就是未解之谜吧) */ ... if (!ENGINE_cmd_is_executable(e, num)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_CMD_NOT_EXECUTABLE); return 0; } /* 顾名思义，拿到dynamic的flag，这里将得到idx = 0时，cmd_defns表中0处的第四个元素 */ flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL); if (flags \u0026lt; 0) { /* * Shouldn\u0026#39;t happen, given that ENGINE_cmd_is_executable() returned * success. */ ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } } static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e-\u0026gt;cmd_defns, (unsigned int)i)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER); return -1; } /* Now the logic splits depending on command type */ cdp = \u0026amp;e-\u0026gt;cmd_defns[idx]; switch (cmd) { ... case ENGINE_CTRL_GET_CMD_FLAGS: /* 可以查出来上面的是 ENGINE_CMD_FLAG_STRING = 0x0002 */ return cdp-\u0026gt;cmd_flags; } ... } 别问为啥不一次查出来，要多次遍历，问就是架构。继续看ENGINE_ctrl_cmd_string，终于要做真正的操作了， 可以看到，最后进入了dynamic_ctrl：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { ... /* ENGINE_CMD_FLAG_NO_INPUT = 0x0004 */ if (flags \u0026amp; ENGINE_CMD_FLAG_NO_INPUT) { /* 如果命令查出来的flag应该没有arg_input, 但arg非空，直接退出???? */ if (arg != NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_NO_INPUT); return 0; } /* * We deliberately force the result of ENGINE_ctrl() to 0 or 1 rather * than returning it as \u0026#34;return data\u0026#34;. This is to ensure usage of * these commands is consistent across applications and that certain * applications don\u0026#39;t understand it one way, and others another. */ /* 最后\u0026#34;LOAD\u0026#34;命令走的这 */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* So, we require input */ if (arg == NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_INPUT); return 0; } /* 一定有更好的写法吧，这种判断也太迷惑了。。 */ /* If it takes string input, that\u0026#39;s easy */ if (flags \u0026amp; ENGINE_CMD_FLAG_STRING) { /* Same explanation as above */ /* 所以应该调用到这，注意此时num 将大于200, 肯定不是默认的流程， 这就走到了return e-\u0026gt;ctrl(e, cmd, i, p, f); 即 dynamic_ctrl */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* 此时arg是数字，需要从str转int，LIST_ADD走这 */ if (!(flags \u0026amp; ENGINE_CMD_FLAG_NUMERIC)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } l = strtol(arg, \u0026amp;ptr, 10); if ((arg == ptr) || (*ptr != \u0026#39;\\0\u0026#39;)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER); return 0; } /* * Force the result of the control command to 0 or 1, for the reasons * mentioned before. */ if (ENGINE_ctrl(e, num, l, NULL, NULL) \u0026gt; 0) return 1; ... }   所以这个函数的主要步骤就是根据输入的cmd_name从dynamic中挂载的cmd_defns取出对应的cmd_num和flag，之后用cmd_num调用到dynamic挂载的ctrl字段函数去做真正的操作。我们用一张表统计下三次取到的结果：\n   cmd_name cmd_num flag     \u0026ldquo;SO_PATH\u0026rdquo; DYNAMIC_CMD_SO_PATH = 200 ENGINE_CMD_FLAG_STRING 0x0002   \u0026ldquo;LIST_ADD\u0026rdquo; DYNAMIC_CMD_LIST_ADD = 203 ENGINE_CMD_FLAG_NUMERIC 0x0001   \u0026ldquo;LOAD\u0026rdquo; DYNAMIC_CMD_LOAD = 206 ENGINE_CMD_FLAG_NO_INPUT 0x0004    根据这个表，我们去看对于dynamic-\u0026gt;ctrl即dynamic_ctrl函数对这几个cmd的操作\ndynamic_ctrl 先看这个函数的公共部分，对相同的engine会初始化上一个ctx上下文：\n/* 动态库加载的上下文 */ struct st_dynamic_data_ctx { /* The DSO object we load that supplies the ENGINE code */ DSO *dynamic_dso; /* * The function pointer to the version checking shared library function */ dynamic_v_check_fn v_check; /* * The function pointer to the engine-binding shared library function */ dynamic_bind_engine bind_engine; /* The default name/path for loading the shared library */ char *DYNAMIC_LIBNAME; /* Whether to continue loading on a version check failure */ int no_vcheck; /* If non-NULL, stipulates the \u0026#39;id\u0026#39; of the ENGINE to be loaded */ char *engine_id; /* * If non-zero, a successfully loaded ENGINE should be added to the * internal ENGINE list. If 2, the add must succeed or the entire load * should fail. */ int list_add_value; /* The symbol name for the version checking function */ const char *DYNAMIC_F1; /* The symbol name for the \u0026#34;initialise ENGINE structure\u0026#34; function */ const char *DYNAMIC_F2; /* * Whether to never use \u0026#39;dirs\u0026#39;, use \u0026#39;dirs\u0026#39; as a fallback, or only use * \u0026#39;dirs\u0026#39; for loading. Default is to use \u0026#39;dirs\u0026#39; as a fallback. */ int dir_load; /* A stack of directories from which ENGINEs could be loaded */ STACK_OF(OPENSSL_STRING) *dirs; }; static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { /* 这个函数将会初始化并保存动态库数据的ctx，这也是为什么可以反复调用这个接口的原因 */ dynamic_data_ctx *ctx = dynamic_get_data_ctx(e); int initialised; if (!ctx) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED); return 0; } /* 可以看到，加载完成的标志是dynamic_dso钩子已经挂上了 */ initialised = ((ctx-\u0026gt;dynamic_dso == NULL) ? 0 : 1); /* All our control commands require the ENGINE to be uninitialised */ if (initialised) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED); return 0; } /* cmd解析，底下逐个分析 */ ... } /* * This function retrieves the context structure from an ENGINE\u0026#39;s \u0026#34;ex_data\u0026#34;, * or if it doesn\u0026#39;t exist yet, sets it up. */ static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e) { dynamic_data_ctx *ctx; if (dynamic_ex_data_idx \u0026lt; 0) { /* * Create and register the ENGINE ex_data, and associate our \u0026#34;free\u0026#34; * function with it to ensure any allocated contexts get freed when * an ENGINE goes underground. */ int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, dynamic_data_ctx_free_func); if (new_idx == -1) { ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX); return NULL; } CRYPTO_THREAD_write_lock(global_engine_lock); /* Avoid a race by checking again inside this lock */ if (dynamic_ex_data_idx \u0026lt; 0) { /* Good, someone didn\u0026#39;t beat us to it */ dynamic_ex_data_idx = new_idx; new_idx = -1; } CRYPTO_THREAD_unlock(global_engine_lock); /* * In theory we could \u0026#34;give back\u0026#34; the index here if (new_idx\u0026gt;-1), but * it\u0026#39;s not possible and wouldn\u0026#39;t gain us much if it were. */ } ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx); /* Check if the context needs to be created */ if ((ctx == NULL) \u0026amp;\u0026amp; !dynamic_set_data_ctx(e, \u0026amp;ctx)) /* \u0026#34;set_data\u0026#34; will set errors if necessary */ return NULL; return ctx; } /* * 简单的说就是去查挂在engine-\u0026gt;ex_data， * 这个就是动态库加载的上下文，ex_data是个栈可能有多个上下文， * 根据一个全局变量dynamic_ex_data_idx确定当前使用上下文 * 当然第一次调用ctx是空的，所以需要调用一下dynamic_set_data_ctx初始化 */ static int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx) { /* 申请ctx的mem */ dynamic_data_ctx *c = OPENSSL_zalloc(sizeof(*c)); int ret = 1; if (c == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); return 0; } c-\u0026gt;dirs = sk_OPENSSL_STRING_new_null(); if (c-\u0026gt;dirs == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); OPENSSL_free(c); return 0; } /* 初始化一些字段，下面总结 */ c-\u0026gt;DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, ; c-\u0026gt;DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;; c-\u0026gt;dir_load = 1; CRYPTO_THREAD_write_lock(global_engine_lock); /* 第一次进来为NULL(然而正常是为ctx = NULL才会调用这个函数，可能是冗余校验)*/ if ((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx)) == NULL) { /* Good, we\u0026#39;re the first */ /* 把ctx挂在engine-\u0026gt;ex_data上 */ ret = ENGINE_set_ex_data(e, dynamic_ex_data_idx, c); if (ret) { *ctx = c; c = NULL; } } CRYPTO_THREAD_unlock(global_engine_lock); /* * If we lost the race to set the context, c is non-NULL and *ctx is the * context of the thread that won. */ if (c) sk_OPENSSL_STRING_free(c-\u0026gt;dirs); OPENSSL_free(c); return ret; } /* * 得到最后的结果 dynamic-\u0026gt;ex_data = ctx; * ctx = {.DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, .DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;, c-\u0026gt;dir_load = 1} * 惊奇的发现了 bind_engine 虽然他只是个字符串，但是我相信你已经知道原因了 * 他需要在动态库中去寻找这个符号 */ 之后我们逐一分析这三个cmd\nDYNAMIC_CMD_SO_PATH和DYNAMIC_CMD_LIST_ADD static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { /* 注意， p就是ctrlvalue，即从conf中取下来的值 */ case DYNAMIC_CMD_SO_PATH: /* a NULL \u0026#39;p\u0026#39; or a string of zero-length is the same thing */ if (p \u0026amp;\u0026amp; (strlen((const char *)p) \u0026lt; 1)) p = NULL; OPENSSL_free(ctx-\u0026gt;DYNAMIC_LIBNAME); if (p) /* 很明显只是做了个简单的复制，此时路径已经赋值上了 */ ctx-\u0026gt;DYNAMIC_LIBNAME = OPENSSL_strdup(p); else ctx-\u0026gt;DYNAMIC_LIBNAME = NULL; return (ctx-\u0026gt;DYNAMIC_LIBNAME ? 1 : 0); case DYNAMIC_CMD_LIST_ADD: if ((i \u0026lt; 0) || (i \u0026gt; 2)) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT); return 0; } /* 很简单，赋值而已 */ ctx-\u0026gt;list_add_value = (int)i; return 1; ...\t} } 这两个都很简单，最后难点都给了LOAD\nDYNAMIC_CMD_LOAD 最关键的函数，完成了全部的加载，解释都在注释里：\nstatic int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { case DYNAMIC_CMD_LOAD: return dynamic_load(e, ctx);\t...\t} } static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx) { ENGINE cpy; dynamic_fns fns; /* * 先new一个DSO结构体，DSO这一套函数怎么玩的这里先不讲了， * 可以理解为内部也有一个加载钩子，有4个挂载点，估计再展开讲读者疯了 */ if (ctx-\u0026gt;dynamic_dso == NULL) ctx-\u0026gt;dynamic_dso = DSO_new(); if (ctx-\u0026gt;dynamic_dso == NULL) return 0; /* 此处检查DYNAMIC_LIBNAME不能为空，这个就是dso的加载地址 */ if (!ctx-\u0026gt;DYNAMIC_LIBNAME) { if (!ctx-\u0026gt;engine_id) return 0; DSO_ctrl(ctx-\u0026gt;dynamic_dso, DSO_CTRL_SET_FLAGS, DSO_FLAG_NAME_TRANSLATION_EXT_ONLY, NULL); ctx-\u0026gt;DYNAMIC_LIBNAME = DSO_convert_filename(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;engine_id); } /* 核心加载函数int_load，看下面分析 */ if (!int_load(ctx)) { ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_NOT_FOUND); DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; return 0; } /* We have to find a bind function otherwise it\u0026#39;ll always end badly */ /* * 此时engine动态库已经加载如内存，符号表与对应地址也准备完成 * 所以肯定是需要去寻找这个绑定engine完成加载的函数了，胜利的曙光 * DSO_bind_func会在符号表中去匹配第二个参数字符串，这里就是我们要的\u0026#34;bind_engine\u0026#34; * 并返回上它的函数地址，挂载在ctx-\u0026gt;bind_engine上 */ if (! (ctx-\u0026gt;bind_engine = (dynamic_bind_engine) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F2))) { ctx-\u0026gt;bind_engine = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE); return 0; } /* Do we perform version checking? */ if (!ctx-\u0026gt;no_vcheck) { unsigned long vcheck_res = 0; /* * Now we try to find a version checking function and decide how to * cope with failure if/when it fails. */ ctx-\u0026gt;v_check = (dynamic_v_check_fn) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F1); if (ctx-\u0026gt;v_check) vcheck_res = ctx-\u0026gt;v_check(OSSL_DYNAMIC_VERSION); /* * We fail if the version checker veto\u0026#39;d the load *or* if it is * deferring to us (by returning its version) and we think it is too * old. */ if (vcheck_res \u0026lt; OSSL_DYNAMIC_OLDEST) { /* Fail */ ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_VERSION_INCOMPATIBILITY); return 0; } } /* * First binary copy the ENGINE structure so that we can roll back if the * hand-over fails */ memcpy(\u0026amp;cpy, e, sizeof(ENGINE)); /* * Provide the ERR, \u0026#34;ex_data\u0026#34;, memory, and locking callbacks so the * loaded library uses our state rather than its own. FIXME: As noted in * engine.h, much of this would be simplified if each area of code * provided its own \u0026#34;summary\u0026#34; structure of all related callbacks. It * would also increase opaqueness. */ fns.static_state = ENGINE_get_static_state(); CRYPTO_get_mem_functions(\u0026amp;fns.mem_fns.malloc_fn, \u0026amp;fns.mem_fns.realloc_fn, \u0026amp;fns.mem_fns.free_fn); /* * Now that we\u0026#39;ve loaded the dynamic engine, make sure no \u0026#34;dynamic\u0026#34; * ENGINE elements will show through. */ engine_set_all_null(e); /* Try to bind the ENGINE onto our own ENGINE structure */ /* !!!!Attension, 终于调用成功了，我们的engineX终于被设置好了！ */ if (!ctx-\u0026gt;bind_engine(e, ctx-\u0026gt;engine_id, \u0026amp;fns)) { ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED); /* Copy the original ENGINE structure back */ memcpy(e, \u0026amp;cpy, sizeof(ENGINE)); return 0; } /* Do we try to add this ENGINE to the internal list too? */ /* 把这个engine的副本add进上面engine全局链表，大功告成！*/ if (ctx-\u0026gt;list_add_value \u0026gt; 0) { if (!ENGINE_add(e)) { /* Do we tolerate this or fail? */ if (ctx-\u0026gt;list_add_value \u0026gt; 1) { /* * Fail - NB: By this time, it\u0026#39;s too late to rollback, and * trying to do so allows the bind_engine() code to have * created leaks. We just have to fail where we are, after * the ENGINE has changed. */ ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } /* Tolerate */ ERR_clear_error(); } } return 1; } static int int_load(dynamic_data_ctx *ctx) { int num, loop; /* Unless told not to, try a direct load */ /* * DSO_load去打开ctx-\u0026gt;DYNAMIC_LIBNAME，把egine对应的lib库加载进内存 * 解析符号表和对应地址到上面申请好的ctx-\u0026gt;dynamic_dso结构体中 */ if ((ctx-\u0026gt;dir_load != 2) \u0026amp;\u0026amp; (DSO_load(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, NULL, 0)) != NULL) return 1; /* If we\u0026#39;re not allowed to use \u0026#39;dirs\u0026#39; or we have none, fail */ if (!ctx-\u0026gt;dir_load || (num = sk_OPENSSL_STRING_num(ctx-\u0026gt;dirs)) \u0026lt; 1) return 0; for (loop = 0; loop \u0026lt; num; loop++) { /* 还有链接的dso这里会处理递归的去加载，对应的需要在ctx-\u0026gt;dirs中 */ const char *s = sk_OPENSSL_STRING_value(ctx-\u0026gt;dirs, loop); char *merge = DSO_merge(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, s); if (!merge) return 0; if (DSO_load(ctx-\u0026gt;dynamic_dso, merge, NULL, 0)) { /* Found what we\u0026#39;re looking for */ OPENSSL_free(merge); return 1; } OPENSSL_free(merge); } return 0; } 终于终于终于，找到目标了，这个叫做'dynamic'的engine副本完成了变成engineX的蜕变。\n后续 难怪这么多人喷OpenSSL烂，这复杂的流程，这一个又一个的钩子。不过这一串源码读下来看明白的时候还是有神清气爽的感觉。\n有缘后面会分析密码算法具体挂载，如ENGINE_set_digests。\n我很菜，有错误的地方欢迎指正\n","description":"OpenSSL Engine插件的加载过程源码分析","id":4,"section":"posts","tags":["OpenSSL"],"title":"OpenSSL Engine加载","uri":"https://summersummer3.github.io/posts/openssl_engine/"},{"content":"椭圆曲线基本学习 文章：https://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#elliptic-curves\n书籍：密码学原理与实践 第6章\n椭圆曲线方程 $$\n\\left\\lbrace (x, y) \\in \\mathbb{R}^2\\ |\\ y^2 = x^3 + ax + b,\\ 4 a^3 + 27 b^2 \\ne 0 \\right\\rbrace\\ \\cup\\ \\left\\lbrace 0 \\right\\rbrace\n$$\n群与阿贝尔群 ​\t$\\mathbb{G}$ 是一个 群 (Group) 如果该集合上定义了一种运算 $ + $:\n 封闭性: $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ ,则 $a + b \\in \\mathbb{G}$ ; 结合律: $a \\in \\mathbb{G}, b \\in \\mathbb{G}, c \\in \\mathbb{G}$, $ (a + b) + c = a + (b +c)$ ; 存在单位元 $0 \\in \\mathbb{G}$, 使得 $a \\in \\mathbb{G}$，$a + 0 = 0 + a = a$; 每一个元素存在逆元：对于集合内任意元素$a, \\exists b \\in \\mathbb{G}$ 满足 $a + b = 0$，记做$a = -b$  如果该群还满足:\n交换律： $a \\in \\mathbb{G}, b \\in \\mathbb{G}$， $a + b = b + a$  则该群被称为阿贝尔群.\n有限域 $\\mathbb{F}$ 是一个 域(Field) 如果该集合上定义了两种运算 $(\\cdot\\ ;+)$\n 封闭性: $a \\in \\mathbb{F}, b \\in \\mathbb{F}$，则 $a + b \\in \\mathbb{G}; a \\cdot b \\in \\mathbb{G}$ 结合律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$，$ (a + b) + c = a + (b +c);\\ (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ 存在加法单位元 $0 \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a + 0 = 0 + a = a$ 存在乘法单位元 $e \\in \\mathbb{F}$，使得 $a \\in \\mathbb{F}$，$a \\cdot e = e \\cdot a = a$ 交换律： $a \\in \\mathbb{F}, b \\in \\mathbb{F}$， $a + b = b + a$，$a \\cdot b = b \\cdot a$ 逆元: 对于集合内任意元素$a, \\exists b \\in \\mathbb{F}; \\exists c \\in \\mathbb{F}$ 满足 $a + b = 0; a \\cdot c = e$， 记做$a = -b;\\ a = c^{-1}$，$0^{-1}$无意义 分配律: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$；$a \\cdot (b + c) = a \\cdot b + a \\cdot c$  注意：加法逆元定义减法，乘法逆元定义除法\n有限域指的是元素有限的域，属于计算机和密码学的基本数学原理之一\n典型的有限域例子：$\\mathbb{F}_p = {0, 1, \u0026hellip;, p-1}$, $p$为质数，\n定义 (+)：$a + b \\mod p$\n定义 ($\\cdot$)：$a \\cdot b \\mod p$\n计算 $a ^ {-1}$ : 拓展欧几里得算法\n椭圆曲线上的群  曲线上的点的集合组成群 $x$无穷远点为单位元$0$ 点$P$与它的逆$Q$关于直线$x = 0$对称 加法定义：$P + Q + R = 0$，如果这三点是非0点，且在同一条直线上(即一条直线与该曲线相交于三点，无穷远点为0) $=\u0026gt; P + Q = -R$  加法同样需要满足结合律.\n几何意义上的加法 最重要的情况:\n 如果 $P=Q, P + Q$，物理意义是切线, 与曲线交于另一点$R$, 满足：$2P = -R$ 如果$P, Q$直线的第三点刚好为$P\\ or\\ Q$，则也将包含一条切线，计算相同: $P + Q + P = 0\\ =\u0026gt; P + Q = -P$  代数意义上的加法 不同两点相加 $P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n曲线方程：$y^2 = x^3 +ax + b$\n  计算斜率 $k = \\frac{P_y - Q_y}{P_x - Q_x}$\n  曲线方程连立上直线方程 $y = kx + c$\n=\u0026gt; $ 0 = x^3 - k^2x^2 + (a - 2kc)x + b - c^2$\n  铭记三次求根公式之三根之和是二次项系数的相反数: $T_x = k^2 - P_x - Q_x$\n  由于斜率 $k = \\frac{T_y - P_y}{T_x - P_x}$，$T_y = k(T_x - P_x) + P_y$\n  相同两点相加 $P(P_x, P_y)$，求 $T(T_x,T_y) = P + P = 2P$\n和上面基本相同，但计算直线斜率需要根据切线计算\n对曲线方程两边求隐微分:\n$\\mathrm{d}(y^2) = \\mathrm{d}(x^3 +ax + b)$ =\u0026gt; $2y\\mathrm{d}y = (3x^2 + a)\\mathrm{d}x$\n将$P_x, P_y$带入，获得斜率:\n$k = \\frac{\\mathrm{d}y}{\\mathrm{d}x} = \\frac{3P_x^2 + a}{2P_y}$\n所以 $T_x = k^2 - 2P_x$，$T_y = k(T_x - P_x) + P_y$\n标量积 $P(P_x, P_y)$，求 $nP = \\underbrace{P + P + P + \u0026hellip; + P}_{\\text{n times}}$，$n \u0026gt; 2$\n  将 $n$ 用二进制表示；以151为例子，$151_{10} = 10010111_2 = 2^0 + 2^1 + 2^2 + 2^4 + 2^7$\n  $nP = P + 2P + 2^2P + 2^4P + 2^7P$\n  根据上面两项计算规则，分别计算$P, 2P，P + 2P$\n  计算$2^2P = 4P = 2 \\cdot 2P$，对$2P$做相同点相加即可\n  同理计算$2^3P = 8P = 2 \\cdot 4P$，$2^4P = 16P = 2 \\cdot 8P$, 依次类推，每计算到一个二进制中为$1$的阶数， 完成一次两点相加即可\n  曲线上的有限域 取几何曲线上的坐标$(x, y)$，$x, y \\in \\mathbb{F}_p$, $p$ 是一个质数，形成一条离散曲线：\n$$\n\\begin{array}{rcl}\n\\left\\lbrace(x, y) \\in (\\mathbb{F}_p)^2 \\right. \u0026amp; \\left. | \\right. \u0026amp; \\left. y^2 \\equiv x^3 + ax + b \\pmod{p}, \\right.\n\\left. 4a^3 + 27b^2 \\not\\equiv 0 \\pmod{p}\\right\\rbrace\\ \\cup\\ \\left\\lbrace0\\right\\rbrace\n\\end{array}\n$$\n从连续曲线上的加法可以推出有限域上的加法公式：\n$P(P_x, P_y), Q(Q_x, Q_y)，P\\ \\ne Q$, 求 $T(T_x, T_y) = P + Q$\n$$\n\\begin{array}{rcl}\nk \u0026amp; = \u0026amp;(P_y - Q_y)(P_x - Q_x)^{-1} \\bmod{p} \\\nT_x \u0026amp; = \u0026amp; (k^2 - P_x - Q_x) \\bmod{p} \\\nT_y \u0026amp; = \u0026amp; [P_y + k(T_x - P_x)] \\bmod{p} \\\n\\end{array}\n$$\n若$P\\ = Q$\n$$\nk = (3 P_x^2 + a)(2 P_y)^{-1} \\bmod{p}\n$$\n曲线上的循环子群 循环子群的阶 对于离散曲线上的任意点$P$, 存在最小的 $n$ 使得 $nP = 0$, 此时 $n$ 称作以 $P$ 为基点的循环子群的阶\n找基点的方法  计算椭圆曲线的阶$N$ (Schoof\u0026rsquo;s algorithm: https://en.wikipedia.org/wiki/Schoof%27s_algorithm) 选择一个阶为$n$的子群。n必须是素数且必须是$N$的因子 计算辅因子 $h = N/n$ 在曲线上选择一个随机的点 $T$ 计算$G = hT$，点乘 如果$G = 0$, 返回4， 否则找到基点 $G$, 子群的阶为 $n$, $h$ 被称为辅因子  原理: 根据拉格朗日定理，$n$ 整除 $N$ 且 $n$ 为质因子，且任意点 $T$ 满足$NT = 0$， 则：$n(hT) = 0$ 恒成立, 那么若$hT\\ \\ne 0$，则 $hT$ 作为基点的阶一定为$n$. ($n$ 一定是素数, 否则不成立)\n曲线上的离散对数问题 对于曲线上的基点 $G$， 已知 $n$ 计算 $P = nG$ 是容易的\n但是已知$P, G$, 计算 $n$ 是很困难的\nECDH \u0026amp; ECDSA ECDH  CA选用共同曲线，并下发相同基点$G$，其阶数为 $n$, 则私钥的取值范围为$d \\in {1, \u0026hellip;, n - 1}$ Alice随机选择私钥$d_A$，计算 Pubkey: $P_A = d_AG$, 通过非安全信道传递给Bob Bob随机选择私钥$d_B$，计算 Pubkey: $P_B = d_BG$，通过非安全信道传递给Alice Alice和Bob分别计算$S = d_AP_b = d_BP_A = d_Ad_BG$， 共享秘密成功  秘密共享成功后可以每次通信时明文传递salt, 每次通过 $key = KDF(salt + S)$，得到具体通信对称秘钥，加密通讯(TLS/SSL)\n通过服务器动态生成的ECDH一般称作ECDHE\nECDSA 定义依然继承上文，$n$ 为 $G$ 作为基点的子群阶数\n定义 $bit(x)$ 为表示 $x$ 需要的比特数；注意计算DSA时，若摘要值的比特数 $bits(digest(plain_test)) \u0026gt; bits(n)$，则需要截取摘要值的低 $bits(n)$ 进行签名.\n符号标记 截取前n-bits函数 ： $trun_{bit(n)}(digest)$\n截取后的摘要值：$z = trun_{bit(n)}(digest(plain_test))$，$digest$ 需要选择安全摘要算法：内部要求SHA-256以上\n私钥：$d$\n公钥：$P = dG$\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x \\mod n$， 若$r = 0$则返回1\n  计算$s = k^{-1}(z + rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算 $u_1 = s^{-1}z \\mod n$ 计算 $u_2 = s^{-1}r \\mod n$ 计算 $T\u0026rsquo; = u_1G\\ +\\ u_2P$  若$T\u0026rsquo;_x = r \\mod n$，验签成功，否则失败\n正确性 我们尝试计算的其实还是$T = kG$，若此时 $z$ 是正确摘要值，则有:\n$k = s^{-1}(z + rd)\\ mod\\ n\\ =\u0026gt;\\ k = s^{-1}z + s^{-1}rd \\mod n$\n带入上式 $T = s^{-1}zG + s^{-1}rdG = u_1G + u_2(dG) = u1G + u_2P$\n所以若 $z$ 发生改变，则此时计算出来的 $T\u0026rsquo;_x\\ \\ne\\ r \\mod n$\n随机数相等下的私钥复原 若每次取出的随机数 $k$ 都相等：\n获取两份签名与摘要：$z_1, (r_1, s_1)$ 和 $z_2, (r_2, s_2)$\n容易得到: $r_1 = r_2 = (kG)_x \\mod n$\n之后通过 $s_1 - s_2$ 计算 $k$：\n$s_1 - s_2 = k^{-1}(z_1 + rd - z_2 - rd) \\mod n$\n$=\u0026gt; k = (z_1 - z_2)(s_1 - s_2)^{-1} \\mod n$\n之后计算 $d$ 就很简单了:\n$ d = r^{-1}(s_1k - z_1) \\mod n$\n通过签名恢复公钥 若已知曲线上 $x = r$ 对应的两点 $R, R\u0026rsquo;$，则可以从签名$(s, r)$中恢复公钥$P$:\n$s = k^{-1}(z + rd) \\mod n$\n$=\u0026gt; skG = (z + rd)G$\n注意 $kG = R$ 或者 $kG = R\u0026rsquo;$, 分别作为备选带入上式，同时$P = dG$:\n$=\u0026gt;\\ sR - zG = r(dG)\\ =\u0026gt; P = r^{-1}(sR - zG)$\nor $=\u0026gt;\\ P = r^{-1}(sR\u0026rsquo; - zG)$\n实现方法 点压缩：增加2bit来标识，一个用来标识 $R_x = r\\mod n$ 或者 $R_x = r$，另一个标识$R_y$是基数还是偶数：\n因为$R, R\u0026rsquo;$关于 $x$ 轴对称，$R_y + R\u0026rsquo;_y = 0 \\mod p$， 所以$R_y ,P\u0026rsquo;_y$为一基一偶，可用一个bit标识\n这样可以达到多用增加一个byte(04标记等)，来达成无需传递公钥即可验签\n相关算法与代码：https://busy.org/@oflyhigh/397bw1\n伪造签名 构造e方法  随机选择 $a, b \\in {1, \u0026hellip; n}$, 计算$T = aG + bP, r = T_x$ 计算 $s = rb^{-1}, e = arb^{-1}$ 若$e$ 为伪造摘要值, 可伪造合法签名 $(r, s)$  正确性:\n$u_1 = s^{-1}e \\mod \\ n$\n$u_2 = s^{-1}r \\mod\\ n$\n将$s, e$带入\n$u_1G + u_2P = (rb^{-1})^{-1}(arb^{-1})G + (rb^{-1})^{-1}rP = (rr^{-1})(bb^{-1})aG + (rr^{-1})bP = aG + bP = T$\n由于$r = T_x \\mod n$，校验通过\n相关算法与代码：https://github.com/GoldSaintEagle/ECDSA-SM2-Signing-Attack\nSM2签名 标记不变，$z = SM3(message)$ 是消息的摘要值（国密要求摘要使用SM3），$d$ 是私钥， $P = dG$是公钥\n签名算法   随机选择 $k \\in {1, \u0026hellip;, n -1 }$\n  计算$T = kG = (T_x, T_y)$\n  计算数字 $r = T_x + z \\mod n$， 若$r = 0$则返回1\n  计算$s = (1 + d)^{-1}(k - rd) \\mod n$, 如果$s = 0$，返回1\n  最后签名：$(r, s)$\n  验证算法  计算消息值摘要$z\u0026rsquo; = SM3(message)$ 计算$T\u0026rsquo; = sG + (r + s)P$ 判断$r\\ ?= T\u0026rsquo;_x + z \\mod n$  正确性 首先计算 $k$ :\n$s = (1 + d)^{-1}(k - rd) \\mod n$\n=\u0026gt; $s(1 + d) + rd = k \\mod n$ =\u0026gt; $s + (s + r)d = k \\mod n$\n所以 ：\n$T = kG = sG + (s + r)(dG) = sG + (s + r)P = T'$\n因此可以推导：\n$r = (T_x + z) = (T\u0026rsquo;_x + z) \\mod n$\n所以如果$r = T\u0026rsquo;_x + z\u0026rsquo; \\mod n$， 则 $z\u0026rsquo;$ 验签通过，否则 $z\u0026rsquo;$ 摘要有误\n","description":"椭圆曲线算法入门及ECDSA与SM2算法详解","id":5,"section":"posts","tags":["密码学"],"title":"ECDSA与SM2","uri":"https://summersummer3.github.io/posts/ecdsa%E4%B8%8Esm2/"}]