[{"content":"A useless security engineer/cn:å¸…å\nå·¥ä½œç»å†\nå­—èŠ‚è·³åŠ¨ï¼šç§»åŠ¨å®‰å…¨é£æ§å·¥ç¨‹å¸ˆï¼Œä¸“æ³¨åè‡ªåŠ¨åŒ–\nåä¸º: ç¡¬ä»¶å®‰å…¨ä¸ç§»åŠ¨å®‰å…¨å·¥ç¨‹å¸ˆï¼ŒTEE/HSM/æ¸—é€æµ‹è¯•/å®‰å…¨å¯åŠ¨ éƒ½åšè¿‡ç‚¹\nå­¦ä¹ ç»å†\næ—¥æœ¬ç­‘æ³¢å¤§å­¦ï¼Œç¤¾ä¼šå·¥å­¦ï¼Œç¡•å£«: å·®åˆ†éšç§ç ”ç©¶\nä¸­å—å¤§å­¦ï¼Œè®¡ç®—æœºç§‘å­¦ä¸æŠ€æœ¯ï¼Œæœ¬ç§‘: çç©å„¿\n","description":"","id":2,"section":"","tags":null,"title":"About Techsum","uri":"https://summersummer3.github.io/about/"},{"content":"èƒŒæ™¯ ç”±äºå¾ˆå¤šheadlessæµè§ˆå™¨çš„webglä¿¡æ¯æ¯”è¾ƒæ˜æ˜¾ï¼Œå¦‚æœæºç«™å°è¯•é‡‡é›†webglå‚æ•°ä¼šæš´éœ²è‡ªåŠ¨åŒ–å·¥å…·çš„ç‰¹å¾ï¼Œæ‰€ä»¥é»‘äº§æ”»å‡»ä¸­éœ€è¦å»æ¬ºéª—webglçš„ä¿¡æ¯ä¸ŠæŠ¥ã€‚\nç›®å‰åœ¨githubä¸Šå¯ä»¥æ‰¾åˆ°ä¸€ä¸ªspoof webglçš„é¡¹ç›®ï¼Œstaræ•°å¹¶ä¸å¤šï¼Œä½†å…¶æ€è·¯åº”è¯¥æ˜¯æ¯”è¾ƒä¸»æµçš„hook webglç›¸å…³æ¥å£çš„æ–¹å¼ã€‚æœ¬æ–‡ä¸»è¦å¯¹è¯¥å·¥å…·çš„ä½¿ç”¨å’Œæºç è¿›è¡Œåˆ†æã€‚\nè¿™ä»½ä»£ç å¹¶ä¸å®Œç¾ï¼Œç”šè‡³èƒ½æ‰¾åˆ°å‡ å¤„bugï¼Œä½†ä¸å¦¨ç¢æˆ‘ä»¬å­¦ä¹ å…¶æ€æƒ³ï¼›githubåœ°å€ï¼šhttps://github.com/siejqa/spoofHeadless\nèƒŒæ™¯çŸ¥è¯†ç®€å•ä»‹ç» Webglå’Œå‚æ•°é‡‡é›† ç®€å•æ¥è¯´webglå°±æ˜¯æµè§ˆå™¨ç»™å‰ç«¯jsä»£ç è°ƒç”¨çš„æ¸²æŸ“ç»˜å›¾APIï¼Œè¯¥APIå¯ä»¥åœ¨åœ¨html canvaså…ƒç´ ä¸­ä½¿ç”¨ï¼Œå¯ä»¥è°ƒç”¨åˆ°ç¡¬ä»¶è¿›è¡ŒåŠ é€Ÿï¼Œæ‰€ä»¥webglçš„å‚æ•°é€šå¸¸ä¸ç¡¬ä»¶å¼ºç›¸å…³ã€‚æ›´å…·ä½“çš„ä»‹ç»å’Œæ•™ç¨‹å¯ä»¥å‚è€ƒï¼šhttps://www.w3cschool.cn/webgl/i4gf1oh1.html\nå…·ä½“é‡‡é›†webglçš„å‚æ•°æ—¶ï¼Œéœ€è¦é¦–å…ˆå…ˆè·å–canvasä¸‹çš„webgl Contextï¼Œä½¿ç”¨getContextæ¥å£ã€‚è€Œé‡‡é›†å…·ä½“å‚æ•°æ˜¯ä½¿ç”¨getParameterå‡½æ•°å®Œæˆï¼ŒgetParameteræ¥å—ä¸€ä¸ªæ•´æ•°ï¼Œæ¯ä¸ªæ•´æ•°å¯¹åº”ä¸€ä¸ªå±æ€§ï¼›ä»¥è·å–GPUå‹å·ä¸ºä¾‹ï¼š\n1 2 3 4 5  // è·å–webgl context var gl = document.createElement(\u0026#34;canvas\u0026#34;).getContext(\u0026#34;webgl\u0026#34;) // é‡‡é›†GPU renderï¼šç¼–å·ä¸º37446 gl.getExtension(\u0026#34;WEBGL_debug_renderer_info\u0026#34;)[\u0026#34;UNMASKED_RENDERER_WEBGL\u0026#34;] gl.getParameter(37446)   å®Œæ•´çš„getParameterå¸¸é‡è¡¨å¯ä»¥å‚è€ƒï¼šhttps://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\nWebdriver webdriveræœ¬è´¨ä¸Šæ˜¯æµè§ˆå™¨æ ¹æ®w3cå®ç°çš„ä¸€å¥—æ“ä½œæµè§ˆå™¨çš„æ¥å£ï¼Œè€Œæ¯ä¸ªæµè§ˆå™¨éƒ½æœ‰ä¸€ä¸ªç‰¹å®šçš„ WebDriver å®ç°ï¼Œå¦‚chrome webdriverï¼šhttps://chromedriver.chromium.org/downloads\nè€Œç›®å‰æ¯”è¾ƒå¹¿ä¹‰çš„å®šä¹‰ï¼ˆæˆ–è€…è¯´é»‘äº§ä½¿ç”¨çš„æ–¹å¼ï¼‰ï¼Œé€šå¸¸æ˜¯æŒ‡puppeteer/seleniumè¿™ç±»ï¼Œé›†æˆäº†å¤šç§æµè§ˆå™¨ï¼Œå¹¶æä¾›é«˜çº§apiä¾›ä¸Šå±‚åº”ç”¨è°ƒç”¨çš„è‡ªåŠ¨åŒ–å·¥å…·ï¼›å¯ä»¥ç›´æ¥ä½¿ç”¨python(selenium)å’Œnodejs(puppeteer)æ¥ç¼–å†™è„šæœ¬ï¼Œå®Œæˆwebdriverçš„æ§åˆ¶ï¼Œä»è€Œå®Œæˆæµè§ˆå™¨ä¸Šçš„è‡ªåŠ¨åŒ–æ“ä½œã€‚ç›¸å…³èµ„æ–™å¯ä»¥è‡ªè¡Œæœç´¢å­¦ä¹ ã€‚\nSpoofWebGLä½¿ç”¨æ–¹æ³• æ­¤å¤„ä»‹ç»å¦‚ä½•åœ¨seleniumä½¿ç”¨SpoofWebGLå·¥å…·ï¼Œå½“ç„¶è¯¥å·¥å…·ç®€å•æ”¹é€ åå¯ä»¥åœ¨æ‰€æœ‰çš„webdriverä¸Šä½¿ç”¨ã€‚\n å°†é¡¹ç›®cloneä¸‹æ¥ä¹‹åï¼Œä½¿ç”¨å¯ä»¥çœ‹åˆ°srcæ–‡ä»¶å¤¹ä¸‹æœ‰ä¸¤ä¸ªæ–‡ä»¶ï¼Œå…¶ä¸­manifest.jsonæ˜¯extensionçš„é…ç½®æ–‡ä»¶ï¼Œinjectedæ˜¯æºç ã€‚   ä¹‹åç”¨zipå‘½ä»¤å°†srcæ–‡ä»¶å¤¹æ‰“åŒ…ï¼šzip -rj extension.zip src/ å°†zipåç¼€åæ”¹æˆ.crx(chrome extensionçš„åç¼€å) ï¼šmv extension.zip extension.crx ç¼–å†™webdriverè„šæœ¬å¦‚ä¸‹ï¼ˆæ³¨æ„è¦å…ˆå®‰è£…å¥½seleniumå’Œchrome webdriverï¼‰ï¼Œå»è§‚å¯Ÿæˆ‘ä»¬çš„webglå‚æ•°è¯»å–æƒ…å†µï¼ˆæ³¨æ„åŸé¡¹ç›®ä¸­ä½¿ç”¨çš„æ˜¯firefoxçš„webdriverï¼Œæ‰€ä»¥è„šæœ¬è¦åšä¿®æ”¹ï¼‰ï¼š  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver opt = webdriver.ChromeOptions() extension_path = \u0026#39;./extension.crx\u0026#39; opt.add_extension(extension_path) driver = webdriver.Chrome(options=opt) # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   å¯ä»¥çœ‹åˆ°è¿™ä¸ªvendorå’Œrenderå·²ç»ä¸å¤ªæ­£å¸¸äº†ï¼›\n ä½œä¸ºå¯¹æ¯”ï¼Œæ³¨é‡Šæ‰optionsç›´æ¥å¯åŠ¨ï¼Œä¼šæ˜¾ç¤ºæœ¬æœºçš„çœŸå®GPUï¼š  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver # opt = webdriver.ChromeOptions() #  # extension_path = \u0026#39;./extension.crx\u0026#39; # opt.add_extension(extension_path) driver = webdriver.Chrome() # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   æ³¨ï¼šæ­¤å¤„æ˜¯ä½¿ç”¨æµè§ˆå™¨ç•Œé¢æ¨¡å¼æ‰“å¼€çš„ï¼Œå®é™…ä¸Šå¦‚æœæ˜¯å¯åŠ¨headlessæ¨¡å¼ï¼Œè¯¥rendererä¼šå’Œæœ¬æœºçš„æœ‰å·®åˆ«ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¦ä½¿ç”¨spoof webglçš„åŸå› \næºç åˆ†æ æ€»ç»“æ¥è¯´ï¼Œè¯¥extensionæ˜¯å°†webglç›¸å…³çš„æ¥å£å…¨éƒ¨è¿›è¡Œäº†hookï¼Œæœ¬è´¨æŠ€æœ¯éš¾åº¦ä¸Šå¹¶ä¸å¤§ï¼Œä¸”å¯ä»¥å¾ˆå®¹æ˜“è¿›è¡Œå®šåˆ¶åŒ–ã€‚ä¸‹é¢å¼€å§‹å¯¹hookæ–¹æ³•è¿›è¡Œåˆ†æ\nwebdriverç›¸å…³ç»•è¿‡ å¼€å§‹çš„ç¬¬ä¸€éƒ¨åˆ†è·Ÿwebglæ£€æµ‹å…³ç³»ä¸å¤§ï¼Œä¸»è¦æ˜¯ç”¨definePropertyæ–¹æ³•å¯¹navigatorä¸‹ä¸€äº›å­—æ®µè¿›è¡Œäº†hookï¼Œç»•è¿‡webdriverç›¸å…³çš„ä¸€äº›æ£€æµ‹ï¼›ä¸»è¦æ˜¯è®¾ç½®ä¸Šæµè§ˆå™¨è¯­è¨€ï¼Œä»¥åŠå°†Navigator.webdriverç½®ä¸ºfalseï¼š\n1 2 3 4 5 6 7 8 9 10  Object.defineProperty(navigator, \u0026#39;languages\u0026#39;, { get: function () { var availableLanguages = Array(\u0026#39;en\u0026#39;, \u0026#39;pl\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;ru\u0026#39;, \u0026#39;fr\u0026#39;, \u0026#39;fr-fr\u0026#39;, \u0026#39;lb\u0026#39;, \u0026#39;no\u0026#39;) return [\u0026#39;en-US\u0026#39;, get_random_item(availableLanguages)]; }, }); // fake webdriver property (headless has it as true) Object.defineProperty(navigator, \u0026#39;webdriver\u0026#39;, { get: () =\u0026gt; false, });   WebGL Hook æ ¹æ®ä¸Šæ–‡ä¸­webglè°ƒç”¨ç¤ºä¾‹å¯çŸ¥è°ƒç”¨webglæ¥å£é‡‡é›†å‚æ•°ä¸»è¦åˆ†ä¸ºä¸‰æ­¥ï¼š\n ä½¿ç”¨getContextè·å–webgl Context ä½¿ç”¨context.getExtensionè·å–webglæ‹“å±•çš„ç¼–å· ä½¿ç”¨context.getParameterè·å–å…·ä½“å‚æ•°çš„å€¼  å¯¹åº”æ­¥éª¤æˆ‘ä»¬æŸ¥çœ‹è¯¥è„šæœ¬çš„hookæ–¹æ³•ï¼š\nHTMLCanvasElement.getContext Hook è¦hookè¯¥æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå®šä¹‰ä¸€ä¸ªç±»ï¼Œå¦‚ä¸‹ï¼š\n1 2 3 4 5  function WebGLRenderingContext(canvas) { this.canvas = canvas; this.drawingBufferWidth = canvas.width; this.drawingBufferHeight = canvas.height; };   ä¹‹åå°†WebGLRenderingContextä¸­çš„åŸºæœ¬å±æ€§å’Œæ–¹æ³•è¿›è¡Œåˆå§‹åŒ–ï¼Œå³å¯¹Object.prototype.attributeè¿›è¡Œèµ‹å€¼ä¸€ä¸ªç©ºå‡½æ•°ã€‚æ³¨æ„ï¼ŒåŸºç¡€å±æ€§æœ¬è´¨ä¸Šéƒ½æ˜¯ä¸€äº›ç¼–å·ï¼Œå¦‚ä¸Šæ–‡ä¸­çš„ä¾‹å­ä¸€æ ·ï¼Œä»–æ˜¯ç”¨æ¥ä¼ å…¥getParameteråšå…¥å‚çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // åŸwebgl Contextä¸­çš„åŸºæœ¬æ–¹æ³•é›†åˆ var functions = [ \u0026#39;viewport\u0026#39;, \u0026#39;vertexAttribPointer\u0026#39;, \u0026#39;vertexAttrib4fv\u0026#39;, \u0026#39;vertexAttrib4f\u0026#39;, \u0026#39;vertexAttrib3fv\u0026#39;, ... ] // åŸwebgl Contextä¸­çš„åŸºæœ¬å±æ€§é›†åˆï¼Œè¿™é‡ŒæŒ‘é€‰ä¸€äº›ç»å¸¸è¢«æ”¶é›†çš„ä½œä¸ºä¾‹å­ var enumerates = { ... \u0026#39;VERSION\u0026#39;: 7938, ... \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446, ... \u0026#39;DEPTH_BITS\u0026#39;: 3414, \u0026#39;GREEN_BITS\u0026#39;: 3411, \u0026#39;BLUE_BITS\u0026#39;: 3412, ... \u0026#39;STENCIL_BITS\u0026#39;: 3415, ... \u0026#39;MAX_VERTEX_UNIFORM_VECTORS\u0026#39;: 36347, \u0026#39;MAX_VERTEX_TEXTURE_IMAGE_UNITS\u0026#39;: 35660, \u0026#39;MAX_VERTEX_ATTRIBS\u0026#39;: 34921, \u0026#39;MAX_VARYING_VECTORS\u0026#39;: 36348, \u0026#39;MAX_TEXTURE_SIZE\u0026#39;: 3379, \u0026#39;MAX_TEXTURE_IMAGE_UNITS\u0026#39;: 34930, \u0026#39;MAX_RENDERBUFFER_SIZE\u0026#39;: 34024, \u0026#39;MAX_FRAGMENT_UNIFORM_VECTORS\u0026#39;: 36349, \u0026#39;MAX_CUBE_MAP_TEXTURE_SIZE\u0026#39;: 34076, \u0026#39;MAX_COMBINED_TEXTURE_IMAGE_UNITS\u0026#39;: 35661, ... }; // å°†åŸæœ¬çš„å‡½æ•°å…¨éƒ¨æ›¿æ¢æˆç©ºå‡½æ•° functions.forEach(function (func) { WebGLRenderingContext.prototype[func] = function () { return {}; }; }); Object.keys(enumerates).forEach(function (key) { WebGLRenderingContext.prototype[key] = enumerates[key]; });   å®é™…ä¸ŠåŸè„šæœ¬ä¹‹åé©¬ä¸Šå¯¹context.getExtensionå®Œæˆäº†èµ‹å€¼ï¼Œé‚£æ­¤å¤„å…¶å®é¡ºåºä¸å½±å“æ‰§è¡Œç»“æœï¼Œæ‰€ä»¥æˆ‘ä»¬ç•™åœ¨ä¸‹ä¸€èŠ‚æè¿°ã€‚\nè¿›å…¥hookçš„ä»£ç ï¼Œå®é™…ä¸Šdocument.createElement(\u0026ldquo;canvas\u0026rdquo;).getContext(\u0026quot;webgl\u0026quot;)è°ƒç”¨åˆ°çš„æ˜¯HTMLCanvasElement.getContextæ–¹æ³•ï¼Œæ‰€ä»¥å¯¹è¯¥æ–¹æ³•è¿›è¡ŒHookï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  try { const getContext = HTMLCanvasElement.prototype.getContext; // åˆ©ç”¨é‡å®šä¹‰HTMLCanvasElement.prototype.getContextå®ŒæˆHookï¼Œæ˜¯å¸¸è§çš„hookæ–¹æ³•  HTMLCanvasElement.prototype.getContext = function () { // è·å–ç¬¬ä¸€ä¸ªå…¥å‚ï¼Œé€šå¸¸ä¸º\u0026#34;webgl\u0026#34;ï¼Œ\u0026#39;webgl-experimental\u0026#39;ç­‰  var name = arguments[0]; console.log(\u0026#34;HTMLCanvasElement app requested extension: \u0026#34; + name); console.log(JSON.stringify(arguments, null, 4)); if (name == \u0026#39;webgl\u0026#39; || name == \u0026#39;webgl-experimental\u0026#39; || name == \u0026#39;experimental-webgl\u0026#39; || name == \u0026#39;moz-webgl\u0026#39;) { // æœ€ç»ˆè¿”å›äº†ä¸Šæ–‡ä¸­è‡ªå®šä¹‰çš„ç±»WebGLRenderingContextï¼Œå®Œæˆhook  var y = new WebGLRenderingContext(this); console.log(\u0026#34;WEBGL \u0026#34; + y); console.log(JSON.stringify(y, null, 4)); return y; } // å…¶ä»–çš„webglç±»å‹ä¸æ”¯æŒï¼Œè¿”å›åŸå§‹æ•°æ®  if (name == \u0026#39;webgl2\u0026#39; || name == \u0026#39;experimental-webgl2\u0026#39; || name == \u0026#39;fake-webgl\u0026#39;) { console.log(\u0026#34;WEBGL2\u0026#34;) return null; } var ext = getContext.apply(this, arguments); console.log(\u0026#34;HTMLCanvasElement extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(ext); return ext; } } catch (e) { }   context.getExtensionå®šä¹‰ å®é™…ä¸Šå¾ˆç®€å•ï¼Œåªéœ€è¦getå¯¹åº”å±æ€§æ—¶è¿”å›æŒ‡å®šç¼–å·å³å¯ï¼Œæ­¤å¤„ä»¥ä¸Šæ–‡ä¸­çš„\u0026quot;WEBGL_debug_renderer_info\u0026quot;ä¸ºä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var extensions = { // ratified  ... \u0026#39;WEBGL_debug_renderer_info\u0026#39;: { \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446 }, ... } WebGLRenderingContext.prototype.getExtension = function (ext) { console.log(\u0026#34;WebGLRenderingContext.getExtension\u0026#34; + ext); return extensions[ext]; };   æ³¨æ„æ­¤å¤„æœ‰ä¸€äº›ç‰¹ä¾‹æ˜¯\u0026quot;WEBGL_lose_context\u0026quot;å’Œ\n\u0026ldquo;WEBGL_draw_buffers\u0026rdquo;, ä»–ä»¬çš„å±æ€§å†…éƒ¨åŒ…å«æ–¹æ³•ï¼Œéœ€è¦å®šä¹‰ä¸€ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function loseContext () { } function restoreContext () { } function drawBuffersWEBGL () { } var extensions = { // ratified  ... \u0026#39;WEBGL_lose_context\u0026#39;: { loseContext, restoreContext }, ... \u0026#39;WEBGL_draw_buffers\u0026#39;: { \u0026#39;MAX_DRAW_BUFFERS_WEBGL\u0026#39;: 34852, \u0026#39;MAX_COLOR_ATTACHMENTS_WEBGL\u0026#39;: 36063, ... drawBuffersWEBGL }, }   context.getParameter å®šä¹‰ï¼Œå®Œæˆå–å€¼çš„Hook ä»£ç å¯ä»¥æ‹†è§£å¦‚ä¸‹ï¼š\n å®šä¹‰éƒ¨åˆ†ï¼Œæ‹¿åˆ°getParameterçš„å‚æ•°ï¼š  1 2 3 4 5 6 7  try { const getParameter = WebGLRenderingContext.prototype.getParameter; WebGLRenderingContext.prototype.getParameter = function () { var name = arguments[0]; console.log(\u0026#34;WebGLRenderingContext - getParameter: \u0026#34; + name); ... } catch (a) { }    Hook UNMASKED_VENDOR_WEBGL å’ŒUNMASKED_RENDERER_WEBGL å‚æ•°ï¼Œä»ä¸€ä¸ªå¤‡é€‰åˆ—è¡¨ä¸­éšæœºè¿”å›ä¸€ä¸ªvendor/rendererï¼Œå¯ä»¥å¾ˆå¥½çš„é˜²æ­¢æ”¶é›†ä¿¡æ¯ç»“æœè¿‡åº¦é›†ä¸­ï¼Œä¹Ÿå¯ä»¥å¾ˆæ–¹ä¾¿çš„è¿›è¡Œæ‹“å±•ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function get_random_item(list) { return list[Math.floor((Math.random() * list.length))]; } WebGLRenderingContext.prototype.getParameter = function () { ... // UNMASKED_VENDOR_WEBGL  if (name == 37445) { var options = [\u0026#39;Intel Open Source Technology Center\u0026#39;, \u0026#39;X.Org\u0026#39;, \u0026#39;Vendor Google Inc.\u0026#39;]; return get_random_item(options); } else if (name == 37446) { // UNMASKED_RENDERER_WEBGL  var options = [\u0026#39;Mesa DRI Intel(R) Ivybridge Mobile\u0026#39;, \u0026#39;AMD KAVERI (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Renderer Google SwiftShader\u0026#39;, \u0026#39;AMD ARUBA (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Mesa DRI Intel(R) HD Graphics 630 (Kaby Lake GT2)\u0026#39;, \u0026#39;Gallium 0.4 on AMD KAVERI (DRM 2.43.0 / 4.4.0-83-generic, LLVM 3.8.0)\u0026#39;]; return get_random_item(options); } ... }    Hook ä¸€äº›åŸºç¡€å±æ€§, å¦‚RENDERER / VENDOR / SHADING_LANGUAGE_VERSION /  VERSION\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 7936) { // RENDERER // VENDOR  return \u0026#39;Mozilla\u0026#39;; } else if (name == 35724) { // SHADING_LANGUAGE_VERSION  return \u0026#39;WebGL GLSL ES 1.0\u0026#39;; } else if (name == 7937 || name == 7938) { // VERSION  return \u0026#39;WebGL 1.0\u0026#39;; } ... }    Hook ALIASED_LINE_WIDTH_RANGE / ALIASED_POINT_SIZE_RANGE, ä¼šè¿”å›ä¸€ä¸ªfloat arrayï¼Œsizeä¸º2ï¼›è¿™é‡Œä»£ç æœ‰ç‚¹å°é—®é¢˜ï¼Œä¸å½±å“åŠŸèƒ½ï¼Œname == 7937æ˜¯VERSIONï¼Œä¸è¿‡åœ¨ä¸Šé¢å·²ç»åˆ¤æ–­è¿‡äº†ï¼Œä¸ä¼šè¿›åˆ°è¿™ä¸ªåˆ†æ”¯ï¼š  1 2 3 4 5 6 7 8 9  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 33901 || name == 33902) { // ALIASED_LINE_WIDTH_RANGE // ALIASED_POINT_SIZE_RANGE  var option = new Float32Array([1, 8192]); return option; } ... }    é’ˆå¯¹ä¸€äº›webglä½å®½ä¿¡æ¯è¿›è¡ŒHookï¼Œè¿”å›éšæœºå€¼[2, 4, 8, 16]ä¸­1ä¸ªï¼Œå…·ä½“å‚æ•°è§æ³¨é‡Šï¼š  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3413 || name == 3412 || name == 3411 || name == 3410 || name == 34852) { // ALPHA_BITS // BLUE_BITS // GREEN_BITS // RED_BITS // MAX_DRAW_BUFFERS_WEBGL  return get_random_item([2, 4, 8, 16]); } ... }    é’ˆå¯¹ä¸€äº›ä½å®½ä¿¡æ¯è¿›è¡ŒHookï¼Œè¿”å›å›ºå®šå€¼ï¼Œå‚æ•°è§æ³¨é‡Š  1 2 3 4 5 6 7 8 9 10 11  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3415) // STENCIL_BITS  return 0; } else if (name == 3414) { // DEPTH_BITS  return 24; } ... }    æ¥ä¸‹æ¥æ˜¯è¯¥è„šæœ¬bugçš„åœ°æ–¹ï¼ŒHookå‡ºç°é—®é¢˜ï¼Œå¦‚æœä½¿ç”¨è¯¥è„šæœ¬ä¸åŠ ä¿®æ”¹ï¼Œå¾ˆå®¹æ˜“é€šè¿‡æ­¤bugè¯†åˆ«ï¼›åŸå› ä¸»è¦åœ¨äºä»¥ä¸‹hookçš„ä¸‰ä¸ªå‚æ•°å€¼ç†è®ºä¸Šæ˜¯è¿”å›ä¸€ä¸ªæ•´æ•°ï¼Œä½†ä¸çŸ¥ä¸ºä½•ä½œè€…è¿™é‡Œä½¿ç”¨äº†get_random_items, ä½†æ²¡æœ‰ç»™ç¬¬äºŒä¸ªå‚æ•°ï¼Œæ‰€ä»¥nä¼šä¸ºundefinedï¼Œå¯¼è‡´å›ºå®šè¿”å›ä¸€ä¸ªArrayï¼šundefinedï¼›ä¿®å¤ä¹Ÿå¾ˆç®€å•ï¼Œæ¢æˆget_random_itemå³å¯ã€‚æºä»£ç å¦‚ä¸‹ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function get_random_items(list, n) { var result = new Array(n), len = list.length, taken = new Array(len); if (n \u0026gt; len) n = len while (n--) { var x = Math.floor(Math.random() * len); result[n] = list[x in taken ? taken[x] : x]; // æ¯”è¾ƒå·§å¦™çš„å–éšæœºå¤šä¸ªå€¼çš„æ–¹å¼ï¼Œç•™ä¸€ä¸ªarrayæ ‡è®°å¦‚æœä¸‹æ¬¡å†å–åˆ°å…¶ä¸‹æ ‡ä¼šä»ç›®å‰æœªå–æˆçš„æœ€åä¸€ä¸ªå…ƒç´   taken[x] = --len in taken ? taken[len] : len; } return result; } WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 34047 || name == 34921) { // MAX_TEXTURE_MAX_ANISOTROPY_EXT // MAX_VERTEX_ATTRIBS  return get_random_items([2, 4, 8, 16]); } else if (name == 35661) { // MAX_COMBINED_TEXTURE_IMAGE_UNITS  return get_random_items([128, 192, 256]); } ... }    å¯¹ä¸€äº›å…¶ä»–çš„MAXç›¸å…³å±æ€§è¿›è¡ŒHookï¼Œè¿”å›éšæœºå€¼ï¼Œå…·ä½“å±æ€§è§æ³¨é‡Š  1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... } else if (name == 34076 || name == 34024 || name == 3379) { // MAX_CUBE_MAP_TEXTURE_SIZE // MAX_RENDERBUFFER_SIZE  return get_random_item([16384, 32768]) ; } else if (name == 36349 || name == 36347) { // MAX_FRAGMENT_UNIFORM_VECTORS // MAX_VERTEX_UNIFORM_VECTORS  return get_random_item([4096, 8192]); } else if (name == 34930 || name == 36348 || name == 35660) { // MAX_TEXTURE_IMAGE_UNITS // MAX_VARYING_VECTORS // MAX_VERTEX_TEXTURE_IMAGE_UNITS  return get_random_item([16, 32, 64]); } ... }    å¯¹MAX_VIEWPORT_DIMSè¿›è¡ŒHookï¼Œä¼šè¿”å›ä¸€ä¸ªé•¿åº¦ä¸º2ä¸”ä¸¤ä¸ªå€¼ç›¸ç­‰çš„Int32Arrayï¼ŒåŒæ ·æ­¤å¤„éšæœºå–å€¼ï¼š  1 2 3 4 5 6 7 8 9 10  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3386) { // MAX_VIEWPORT_DIMS  var value = get_random_item([8192, 16384, 32768]) var options = new Int32Array([value, value]); return options; } ... }    æœ€åï¼Œå‰©ä¸‹çš„å‚æ•°ç»Ÿä¸€éšæœºä»[0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]éšæœºå–å€¼è¿”å›(æ­¤å¤„è¿˜æœ‰ä¸ªå†—ä½™åˆ†æ”¯STENCIL_BITSï¼Œä¸Šé¢å·²ç»åˆ¤æ–­è¿‡äº†ï¼Œå±äºå†—ä½™ä»£ç )  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else { console.log(\u0026#34;Retuning random value for: \u0026#34; + name); return get_random_item([0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]); } ... }    æœ€åçš„è¿·æƒ‘æ“ä½œï¼šç†è®ºä¸Šæ­¤å¤„å·²ç»æ¶µç›–äº†æ‰€æœ‰çš„caseè¿”å›ï¼Œä½†æ˜¯æœ€åè¿˜å¤šäº†ä¸ªè·‘ä¸åˆ°çš„åˆ†æ”¯ï¼š  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... var ext = getParameter.apply(this, arguments); console.log(\u0026#34;WebGLRenderingContext extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(JSON.stringify(ext, null, 4)); return ext; }   è¯´å®è¯æˆ‘çŒœæµ‹æ­¤å¤„ä»–æ˜¯æƒ³æ¨¡æ‹Ÿä¸€äº›å‚æ•°ï¼Œä»–ä»¬åœ¨getParameterä¹‹å‰å¿…é¡»å…ˆè°ƒç”¨getExtensionæ–¹æ³•åæ‰å¯ä»¥è·å–ï¼Œä½†æ˜¯æ­¤å¤„åŠ åœ¨æœ€åå±å®çœ‹ä¸æ‡‚ï¼Œä¸ªäººç†è§£åº”è¯¥æ”¾åœ¨è¿™ä¸ªå¤§if\u0026hellip;else\u0026hellip;å‰é¢ï¼›æœ‰æ—¶é—´æˆ‘å¯ä»¥å¥½å¥½ä¿®å¤ä¸€ä¸‹è¿™ä¸ªé¡¹ç›®ğŸ˜‚ğŸ˜‚\nå…¶ä»–çš„ä¸€äº›è¢«Hookçš„æ–¹æ³•  getSupportedExtensionï¼šæ¯”è¾ƒç®€å•ï¼Œéšæœºä»extensionsä¸­é—´é€‰æ‹©éšæœºä¸ªkeyså¹¶è¿”å›ï¼Œå‡ºç°å¼‚å¸¸åˆ™å°†æ‰€æœ‰çš„keyséƒ½è¿”å›ã€‚  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // extensionsçš„keyså¯ä»¥å‚è§getExtensionéƒ¨åˆ† const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions; WebGLRenderingContext.prototype.getSupportedExtensions = function () { try { console.log(\u0026#34;WebGLRenderingContext.getSupportedExtensions\u0026#34;) var availableExtensions = Object.keys(extensions); console.log(availableExtensions); var itemsToGet = Math.floor(Math.random() * (availableExtensions.length - 6) + 5); console.log(itemsToGet); var selectedExtensions = get_random_items(availableExtensions, itemsToGet); console.log(selectedExtensions); return selectedExtensions; } catch (a) { console.log(a) return Object.keys(extensions); } }    é’ˆå¯¹ä¸€äº›headlessæµè§ˆå™¨æœ‰å¯èƒ½ä¼šå‡ºç°canvasçš„ä¸€äº›å±æ€§å¼‚å¸¸ï¼ˆbrokenä¼šä¸º0ï¼‰ï¼Œå¦‚canvasçš„widthå’Œheightï¼Œä»¥åŠoffsetï¼Œè¿›è¡ŒHookï¼Œè¿˜æ˜¯ä½¿ç”¨definePropertyé‡å†™getæ–¹æ³•å¯¹å±æ€§è¿›è¡Œhookï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // in case of broken image return random height/width var size = 0; [\u0026#39;height\u0026#39;, \u0026#39;width\u0026#39;].forEach(property =\u0026gt; { const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, property); Object.defineProperty(HTMLImageElement.prototype, property, { imageDescriptor, get: function () { // å¦‚æœcanvasç ´æŸï¼Œåˆ™è¿”å›éšæœºsize  if (this.complete \u0026amp;\u0026amp; this.naturalHeight == 0) { if (!size) { // è¿”å›éšæœºçš„é•¿/å®½  size = Math.floor(Math.random() * (30 - 10 + 1)) + 10; } return size; } // æœªç ´æŸåˆ™è¿”å›æ­£å¸¸size  return imageDescriptor.get.apply(this); }, }); }); // hairline feature (headless can\u0026#39;t render it normally) const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;); Object.defineProperty(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;, { ...imageDescriptor, get: function () { if (this.id == \u0026#39;modernizr\u0026#39;) { return 1; } return imageDescriptor.get.apply(this); }, });   æ’ä»¶æ‰§è¡Œ æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œå°†æ•´ä¸ªå¤§å‡½æ•°ä½œä¸ºå­—ç¬¦ä¸²ï¼Œæœ€ååœ¨html documentä¸­æ–°å»ºä¸€ä¸ªscript tagï¼Œscript.textContentèµ‹å€¼ä¸ºå­—ç¬¦ä¸²å³å¯ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  var scriptCode = \u0026#39;(\u0026#39; + function () { ... function WebGLRenderingContext(canvas) { ... }; ... WebGLRenderingContext.prototype.getExtension = function (ext) { ... }; ... WebGLRenderingContext.prototype.getParameter = function () { ... } ... } + \u0026#39;)();\u0026#39;; // è½¬æˆå­—ç¬¦ä¸²ï¼Œå¯ç›´æ¥æ‰§è¡Œ  // æ–°å»ºscriptèŠ‚ç‚¹æ’å…¥documentä¸­ï¼Œå³è‡ªåŠ¨æ‰§è¡Œ var script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = scriptCode; (document.head || document.documentElement).appendChild(script); // æœ€åmoveæ‰ä»£ç å³å¯ script.remove();   ","description":"SpoofWebGL","id":3,"section":"posts","tags":["é»‘äº§å·¥å…·"],"title":"SpoofWebGL","uri":"https://summersummer3.github.io/posts/spoofwebgl/"},{"content":"é—®é¢˜æ¥æº OpenSSL Engineæ˜¯å•¥ï¼Œåœ¨è¿™ä¸ªåœ°æ–¹å°±ä¸ç»†è¯´äº†ï¼Œèµ„æ–™å¾ˆå¤šï¼Œå¯ä»¥çœ‹çœ‹çŸ¥ä¹è¿™ç¯‡ä¸­æ–‡æ–‡æ¡£:\nhttps://zhuanlan.zhihu.com/p/70444766\nè‹±æ–‡æ–‡æ¡£:\nhttps://wiki.openssl.org/index.php/Creating_an_OpenSSL_Engine_to_use_indigenous_ECDH_ECDSA_and_HASH_Algorithms#Author\nç›´æ¥è¿›å…¥æ­£é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆæŸ¥çœ‹ä¸€ä¸ªOpenSSL Engineçš„ä¾‹å­ï¼š\nhttps://github.com/nibrunie/OSSL_EngineX\nç›´æ¥æŸ¥çœ‹bindä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static int bind(ENGINE* e, const char* id) { int ret = 0; if (!ENGINE_set_id(e, engine_id)) { fprintf(stderr, \u0026#34;ENGINE_set_id failed\\n\u0026#34;); goto end; } if (!ENGINE_set_name(e, engine_name)) { printf(\u0026#34;ENGINE_set_name failed\\n\u0026#34;); goto end; } if (!ENGINE_set_digests(e, digest_selector)) { printf(\u0026#34;ENGINE_set_digest failed\\n\u0026#34;); goto end; } ret = 1; end: return ret; } IMPLEMENT_DYNAMIC_BIND_FN(bind) IMPLEMENT_DYNAMIC_CHECK_FN()   å¯ä»¥çœ‹åˆ°OpenSSLå»åŠ è½½Engineçš„åŠ¨æ€åº“æ—¶ï¼Œéœ€è¦åŠ¨æ€åº“å»è°ƒç”¨ IMPLEMENT_DYNAMIC_BIND_FN å®Œæˆengineç»‘å®šåˆå§‹åŒ–ã€‚\nåŸºæœ¬ä¸Šæ‰€ä»¥æ•™ä½ å†™engineçš„æ•™ç¨‹åˆ°è¿™å°±ç»“æŸäº†ï¼Œä½†æ˜¯å†…éƒ¨åˆ°åº•æ˜¯æ€ä¹ˆè¦å…³è”ä¸Šè¿™ä¸ªå‡½æ•°ï¼Œå¹¶ä¸”è§¦å‘ä¸Šé¢çš„bindå‡½æ•°çš„å‘¢ï¼Ÿæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹è¿™ä¸ªå®çš„å…·ä½“å®šä¹‰ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  \\# define IMPLEMENT_DYNAMIC_BIND_FN(fn) \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \\ if (ENGINE_get_static_state() == fns-\u0026gt;static_state) goto skip_cbs; \\ CRYPTO_set_mem_functions(fns-\u0026gt;mem_fns.malloc_fn, \\ fns-\u0026gt;mem_fns.realloc_fn, \\ fns-\u0026gt;mem_fns.free_fn); \\ skip_cbs: \\ if (!fn(e, id)) return 0; \\ /* è°ƒç”¨äº†ä¸Šé¢ä¾‹å­ä¸­çš„bindå‡½æ•° */ return 1; }   å¯ä»¥çœ‹åˆ°æ­¤å¤„å®šä¹‰äº†å‡½æ•°bind_engineï¼Œä»–ä¼šå»æ‰§è¡Œç”¨å®åŒ…è£¹ä½çš„å‡½æ•°ï¼Œä»¥å®Œæˆåˆå§‹åŒ–ã€‚ç„¶è€Œä½ å»æœç´¢è¿™ä¸ªå‡½æ•°åœ¨OpenSSLä¸­è°ƒç”¨ä½ ä¸€å®šä¼šå¾ˆå¤±æœ›ï¼Œè‚¯å®šæ²¡æœ‰ä½ æƒ³è¦çš„ç»“æœã€‚æœç„¶ä¸æ˜¯è¿™ä¹ˆç®€å•çš„ï¼Œåˆæ˜¯ä»€ä¹ˆé’©å­æŒ‚åœ¨äº†ä»€ä¹ˆctxä¸Šå§ï¼Œåº”è¯¥ä¹Ÿä¸éš¾ã€‚\næˆ‘æ‰¾äº†ä¸å°‘èµ„æ–™ï¼ŒåŸºæœ¬æ²¡å‘ç°å•¥é è°±çš„åˆ†æï¼Œæ²¡åŠæ³•è‡ªå·±çœ‹æºç å§ã€‚ç»“æœç»è¿‡åˆ†æï¼Œæˆ‘æ·±åˆ»çš„ç†è§£äº†OpenSSLçš„é­”é¬¼è°ƒç”¨ï¼Œé’©å­çš„æŒ‚è½½å¯ä»¥è¯´æ˜¯å¾ˆé­”å¹»ã€‚æ­¤å¤„æºç åˆ†æåŸºäºç›®å‰çš„ä¸»çº¿masterï¼Œåº”è¯¥ä¹Ÿæ˜¯æœªæ¥OpenSSL 3.0çš„æ¶æ„äº†ã€‚\nè‡³äºEngineæ˜¯æ€ä¹ˆè®¾ç½®ä¸Šé‡ç½®åçš„å¯†ç ç®—æ³•çš„ï¼Œå°†åœ¨åç»­æ›´æ–°ã€‚\nä»åŠ è½½Engineçš„mainå‡½æ•°åˆ†æèµ· è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬æŸ¥çœ‹æ‰§è¡ŒengineåŠ è½½çš„å¯æ‰§è¡Œç¨‹åºçš„æºç :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int main(void) { // initializing OpenSSL library  OPENSSL_load_builtin_modules(); ENGINE_load_dynamic(); // building OpenSSL\u0026#39;s configuration file path  char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { fprintf(stderr, \u0026#34;OpenSSL failed to load required configuration\\n\u0026#34;); ERR_print_errors_fp(stderr); return 1; } ENGINE* eng = ENGINE_by_id(\u0026#34;engineX\u0026#34;); if(NULL == eng) { printf(\u0026#34;failed to retrieve engine by id (mppa)\\n\u0026#34;); return 1; } printf(\u0026#34;EngineX has been successfully loaded \\n\u0026#34;); ... }   å¯ä»¥çœ‹åˆ°æˆ‘ä»¬è¿™ä¸ªä¾‹å­æ˜¯ä»ä¸€ä¸ªcnfé…ç½®æ–‡ä»¶å»åŠ è½½å¯¹åº”çš„engineçš„ï¼Œè¿™é‡Œæä¸€å¥ï¼ŒåŠ è½½engineæœ‰å‡ ä¸ªæ–¹å¼ï¼Œå¦‚å‘½ä»¤è¡ŒåŠ è½½ï¼Œæ‰‹åŠ¨ä»£ç åŠ è½½ç­‰ã€‚è¿™é‡Œç”¨é…ç½®æ–‡ä»¶åŠ è½½åšä¾‹å­æ˜¯å› ä¸ºè¿™ä¸ªåœºæ™¯æ›´åŠ æ¥è¿‘å®é™…ä¸šåŠ¡åœºæ™¯ï¼Œè€Œä¸”æµç¨‹åŸºæœ¬æ¶µç›–å…¨æµç¨‹ï¼Œå€¼å¾—æºç å»åˆ†æã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æŒ‰ç…§è°ƒç”¨é¡ºåºæ¥åˆ†æè¿™æ ·ä¸€ä¸ªæ¼«é•¿çš„è°ƒç”¨è¿‡ç¨‹ã€‚\nOPENSSL_load_builtin_modules ç¬¬ä¸€ä¸ªå‡½æ•°ï¼Œåˆå§‹åŒ–äº†ä¸€ä¸ªé»˜è®¤çš„conf_module, ä¸”åå­—å«åš\u0026rsquo;engines\u0026rsquo;ã€‚ç›´æ¥çœ‹æºç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void OPENSSL_load_builtin_modules(void) { ... /* æˆ‘ä»¬å…¶ä»–çš„éƒ½ä¸é‡è¦ï¼Œç›´æ¥çœ‹è¿™ä¸ªå’ŒEngineç›¸å…³çš„ */ #ifndef OPENSSL_NO_ENGINE  ENGINE_add_conf_module(); #endif \t... } void ENGINE_add_conf_module(void) { CONF_module_add(\u0026#34;engines\u0026#34;, int_engine_module_init, int_engine_module_finish); }   æ¥åˆ°æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªå¤§å‘ï¼ŒOpenSSLçš„åŠ¨æ€é…ç½®æ–‡ä»¶åŠ è½½ï¼Œä½†è¿™é‡Œæˆ‘ä»¬ä¸éœ€è¦ç»†è‡´äº†è§£ï¼Œå…ˆç®€å•åˆ†æä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  int CONF_module_add(const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { if (module_add(NULL, name, ifunc, ffunc)) return 1; else return 0; } /* é‡è¦çš„ç»“æ„ä½“ä¸å…¨å±€å˜é‡ */ static STACK_OF(CONF_MODULE) *supported_modules = NULL; static STACK_OF(CONF_IMODULE) *initialized_modules = NULL; struct conf_module_st { /* DSO of this module or NULL if static */ DSO *dso; /* Name of the module */ char *name; /* Init function */ conf_init_func *init; /* Finish function */ conf_finish_func *finish; /* Number of successfully initialized modules */ int links; void *usr_data; }; typedef struct conf_module_st CONF_MODULE; static CONF_MODULE *module_add(DSO *dso, const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { CONF_MODULE *tmod = NULL; /* è‹¥supported_modulesä¸ºç©ºï¼Œ åˆ™åˆå§‹åŒ–æ­¤å…¨å±€å˜é‡ï¼Œå³å †æ ˆçš„åˆå§‹åŒ– */ if (supported_modules == NULL) supported_modules = sk_CONF_MODULE_new_null(); if (supported_modules == NULL) return NULL; /* ç”³è¯·é…ç½®æ–‡ä»¶æ¨¡å—ç»“æ„ä½“conf_module_stçš„ç©ºé—´ */ if ((tmod = OPENSSL_zalloc(sizeof(*tmod))) == NULL) { CONFerr(CONF_F_MODULE_ADD, ERR_R_MALLOC_FAILURE); return NULL; } /* * æ­¤å¤„ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼Œdsoä¸ºNULLï¼› * dso = dynamic shared object, å¯ä»¥ç†è§£ä¸ºæ˜¯ä¸€ä¸ªOpenSSLå»åŠ è½½åŠ¨æ€åº“çš„ç»“æ„ä½“ï¼› */ tmod-\u0026gt;dso = dso; /* æ­¤å¤„è®°ä½ï¼Œå°†åˆå§‹åŒ–ä¸€ä¸ªå«\u0026#34;engines\u0026#34;çš„conf_module */ tmod-\u0026gt;name = OPENSSL_strdup(name); /* é…ç½®æ–‡ä»¶initå‡½æ•°ï¼Œ æ­¤å¤„å³int_engine_module_initã€‚è¿™ä¸ªå‡½æ•°æ˜¯å…³é”® */ tmod-\u0026gt;init = ifunc; /* é…ç½®æ–‡ä»¶finishå‡½æ•°ï¼Œ æ­¤å¤„å³int_engine_module_finish */ tmod-\u0026gt;finish = ffunc; if (tmod-\u0026gt;name == NULL) { OPENSSL_free(tmod); return NULL; } /* å°†è¿™ä¸ªçš„conf_moduleç»“æ„ä½“å…¥æ ˆè¿›supported_modulesè¿™ä¸ªå…¨å±€å˜é‡æ ˆä¸­ */ if (!sk_CONF_MODULE_push(supported_modules, tmod)) { OPENSSL_free(tmod-\u0026gt;name); OPENSSL_free(tmod); return NULL; } return tmod; }   æ­¤å¤„æœ‰ä¸€ä¸ªOpenSSLçš„ä¸€ä¸ªçŸ¥è¯†ç‚¹ï¼ŒOpenSSLä¸­å¯ä»¥å®šä¹‰ä»»æ„ç±»å‹çš„å®‰å…¨æ ˆï¼Œå¹¶ä¸”ç”Ÿæˆæ“ä½œè¿™ä¸ªç±»å‹æ ˆçš„å‡½æ•°æ—ã€‚ä¾‹å¦‚æœ‰ä¸€ä¸ªç»“æ„ä½“å«XXï¼Œåˆ™å¯ä»¥é€šè¿‡DEFINE_STACK_OF(XX)è¿™ä¸ªå®æ¥å®šä¹‰XXç»“æ„ä½“çš„æ ˆå’Œå‡½æ•°æ—ï¼Œé€šè¿‡STACK_OF(XX)æ¥å£°æ˜ä¸€ä¸ªæ ˆã€‚äº‹å®ä¸Šï¼Œå½“æˆ‘ä»¬çœ‹OpenSSLæºç æ—¶çœ‹åˆ°sk_è¿™ç§å‰ç¼€çš„éƒ½æ˜¯å †æ ˆæ“ä½œï¼Œè€Œä¸”æ˜¯æœç´¢ä¸åˆ°å®ç°çš„ (1.0.2ç‰ˆæœ¬åº”è¯¥å¯ä»¥æ‰¾åˆ°ï¼Œä¹‹åçš„ç‰ˆæœ¬éƒ½æ³›åŒ–äº†ï¼Œä»£ç å†™çš„ç§€ï¼Œçœ‹ä»£ç çš„è‡ªé—­)ã€‚\nè¯¦è§å®˜æ–¹æ–‡æ¡£ï¼šhttps://www.openssl.org/docs/man1.1.0/man3/DEFINE_STACK_OF.html\næ­¤å¤„æœ‰ä¸¤ä¸ªæ ˆæ“ä½œ: åˆå§‹åŒ–æ—¶supported_modulesä¸ºç©ºï¼Œæ‰€ä»¥å°†è°ƒç”¨sk_CONF_MODULE_new_nullå…ˆå»ºç«‹ä¸Šä¸€ä¸ªç©ºå®¹å™¨ã€‚ä¹‹åsk_CONF_MODULE_pushä½¿ä¸Šé¢åˆå§‹åŒ–çš„çš„CONF_MODULEå…¥æ ˆï¼Œä¹‹åæƒ³è¦å–åˆ°è¿™ä¸ªmoduleåˆ™éœ€è¦é€šè¿‡supported_modulesè¿™ä¸ªå…¨å±€æ ˆæ¥å–ã€‚\næ­¤å¤„å¤šæä¸€å¥ï¼ŒOpenSSLè¿˜æœ‰ä¸€ä¸ªç±»ä¼¼çš„ç»“æ„ä½“LHASHï¼Œå®ƒæ˜¯OpenSSLå†…éƒ¨çš„å“ˆå¸Œè¡¨ï¼Œå¦‚æœè¿™ç¯‡æ–‡ç« æœ‰ä¸‹æˆ‘ä»¬åº”è¯¥ä¼šç¢°åˆ°å®ƒï¼Œç›´æ¥ç†è§£æˆæ˜¯ä¸€ä¸ªkv_mapå°±å¥½ã€‚æ‰€æœ‰lh_å‰ç¼€å¼€å¤´çš„ä¹Ÿéƒ½æ˜¯å“ˆå¸Œè¡¨æ“ä½œã€‚\nENGINE_load_dynamic ç¬¬äºŒä¸ªå‡½æ•°ï¼Œæ¯”è¾ƒç»•ï¼Œç®€å•ç†è§£å°±æ˜¯ï¼šåˆå§‹åŒ–äº†ä¸€ä¸ªengine, åå­—å«åšdynamicï¼ŒOpenSSLç”¨è¿™ä¸ªengineæ¥åŠ¨æ€åŠ è½½åˆ«çš„engine\u0026hellip;\né¡ºä¾¿æä¸€å¥ï¼ŒENGINE_load_dynamic åœ¨1.1.xç‰ˆæœ¬å·²ç»åºŸå¼ƒäº†ï¼Œç»Ÿä¸€éƒ½æ˜¯è°ƒç”¨OPENSSL_init_cryptoè¿™ä¸ªå‡½æ•°ï¼Œopts = OPENSSL_INIT_ENGINE_DYNAMICã€‚è¿™åˆæ˜¯OpenSSLéå¸¸æ¶å¿ƒçš„åœ°æ–¹äº†ï¼Œç‰ˆæœ¬å…¼å®¹å¯ä»¥è¯´æ˜¯ç›¸å½“emmmmmmmm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \\# define ENGINE_load_dynamic() \\ OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_DYNAMIC, NULL) int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings) { ... /* * RUN_ONCEæ˜¯å¤šçº¿ç¨‹æ—¶éœ€è¦å…³å¿ƒçš„ï¼Œæˆ‘ä»¬è¿™é‡Œä¸å…³å¿ƒï¼Œå°±ç­‰äºè°ƒç”¨ossl_init_engine_dynamic * æœ€åä¸€æ³¢å®å±•å¼€ï¼Œè°ƒç”¨çš„æ˜¯ engine_load_dynamic_int è¿™ä¸ªå‡½æ•° */ if ((opts \u0026amp; OPENSSL_INIT_ENGINE_DYNAMIC) \u0026amp;\u0026amp; !RUN_ONCE(\u0026amp;engine_dynamic, ossl_init_engine_dynamic)) return 0; ... } void engine_load_dynamic_int(void) { ENGINE *toadd = engine_dynamic(); /* è¿™å‘½åçœŸæ˜¯ç»äº†Orz */ if (!toadd) return; ENGINE_add(toadd); /* * If the \u0026#34;add\u0026#34; worked, it gets a structural reference. So either way, we * release our just-created reference. */ ENGINE_free(toadd); /* * If the \u0026#34;add\u0026#34; didn\u0026#39;t work, it was probably a conflict because it was * already added (eg. someone calling ENGINE_load_blah then calling * ENGINE_load_builtin_engines() perhaps). */ ERR_clear_error(); }   engine_dynamic ä¸¤ä¸ªæ ¸å¿ƒå‡½æ•°ï¼Œç¬¬ä¸€ä¸ª engine_dynamic æ–°å»ºäº†ä¸€ä¸ªidå«åš'dynamic'çš„engineï¼ŒæŒ‚ä¸Šäº†è¿™ä¸ªengineçš„å…·ä½“å¤„ç†å‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static ENGINE *engine_dynamic(void) { /* OpenSSLç”³è¯·ç»“æ„ä½“ç©ºé—´ç»å¸¸ä½¿ç”¨çš„xx_new */ ENGINE *ret = ENGINE_new(); if (ret == NULL) return NULL; if (!ENGINE_set_id(ret, engine_dynamic_id) || !ENGINE_set_name(ret, engine_dynamic_name) || !ENGINE_set_init_function(ret, dynamic_init) || !ENGINE_set_finish_function(ret, dynamic_finish) || !ENGINE_set_ctrl_function(ret, dynamic_ctrl) || !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) || !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) { ENGINE_free(ret); return NULL; } return ret; }   æˆ‘ä»¬æ‰«ä¸€çœ¼ENGINEç»“æ„ä½“ï¼Œé¦–å…ˆè¦æœ‰ä¸€ä¸ªæ¦‚å¿µï¼ŒENGINE_set_xx å°±æ˜¯å»è®¾ç½®è¿™ä¸ªç»“æ„ä½“çš„ç›¸åº”å­—æ®µï¼Œæ‰€ä»¥å¯ä»¥è®°å½•ä¸€ä¸‹è¿™ä¸ªç»“æ„ä½“è¢«åˆå§‹åŒ–æˆå•¥æ ·äº†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct engine_st { const char *id; const char *name; const RSA_METHOD *rsa_meth; const DSA_METHOD *dsa_meth; const DH_METHOD *dh_meth; const EC_KEY_METHOD *ec_meth; const RAND_METHOD *rand_meth; /* Cipher handling is via this callback */ ENGINE_CIPHERS_PTR ciphers; /* Digest handling is via this callback */ ENGINE_DIGESTS_PTR digests; /* Public key handling via this callback */ ENGINE_PKEY_METHS_PTR pkey_meths; /* ASN1 public key handling via this callback */ ENGINE_PKEY_ASN1_METHS_PTR pkey_asn1_meths; ENGINE_GEN_INT_FUNC_PTR destroy; ENGINE_GEN_INT_FUNC_PTR init; ENGINE_GEN_INT_FUNC_PTR finish; ENGINE_CTRL_FUNC_PTR ctrl; ENGINE_LOAD_KEY_PTR load_privkey; ENGINE_LOAD_KEY_PTR load_pubkey; ENGINE_SSL_CLIENT_CERT_PTR load_ssl_client_cert; const ENGINE_CMD_DEFN *cmd_defns; int flags; /* reference count on the structure itself */ CRYPTO_REF_COUNT struct_ref; /* * reference count on usability of the engine type. NB: This controls the * loading and initialisation of any functionality required by this * engine, whereas the previous count is simply to cope with * (de)allocation of this structure. Hence, running_ref \u0026lt;= struct_ref at * all times. */ int funct_ref; /* A place to store per-ENGINE data */ CRYPTO_EX_DATA ex_data; /* Used to maintain the linked-list of engines. */ struct engine_st *prev; struct engine_st *next; }   æ•´ç†å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  static const char *engine_dynamic_id = \u0026#34;dynamic\u0026#34;; static const char *engine_dynamic_name = \u0026#34;Dynamic engine loading support\u0026#34;; static const ENGINE_CMD_DEFN dynamic_cmd_defns[] = { {DYNAMIC_CMD_SO_PATH, \u0026#34;SO_PATH\u0026#34;, \u0026#34;Specifies the path to the new ENGINE shared library\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_NO_VCHECK, \u0026#34;NO_VCHECK\u0026#34;, \u0026#34;Specifies to continue even if version checking fails (boolean)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_ID, \u0026#34;ID\u0026#34;, \u0026#34;Specifies an ENGINE id name for loading\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LIST_ADD, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_LOAD, \u0026#34;DIR_LOAD\u0026#34;, \u0026#34;Specifies whether to load from \u0026#39;DIR_ADD\u0026#39; directories (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_ADD, \u0026#34;DIR_ADD\u0026#34;, \u0026#34;Adds a directory from which ENGINEs can be loaded\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LOAD, \u0026#34;LOAD\u0026#34;, \u0026#34;Load up the ENGINE specified by other settings\u0026#34;, ENGINE_CMD_FLAG_NO_INPUT}, {0, NULL, NULL, 0} }; /* åŠ è½½åŠ¨æ€engineæ—¶çš„å‘½ä»¤ */ # define ENGINE_FLAGS_BY_ID_COPY (int)0x0004  ENGINE dynamic = {.id = engine_dynamic_id, .name = engine_dynamic_name, .init = dynamic_init, /* ç©ºå‡½æ•°ï¼Œç›´æ¥return 0 */ .finish = dynamic_finish, /* ç©ºå‡½æ•°ï¼Œç›´æ¥return 0 */ .ctrl = dynamic_ctrl, /* æœ€é‡è¦çš„å‡½æ•°ï¼Œåæ–‡å°†åˆ†æå¦‚ä½•è°ƒç”¨åˆ°è¿™æ¥ */ .flags = ENGINE_FLAGS_BY_ID_COPYï¼Œ .cmd_defns = dynamic_cmd_defns /*å®šä¹‰äº†dynamicè¿™ä¸ªengine ctrlä¸‹çš„åˆæ³•cmd*/ .prev = NULL, .next = NULL /* è¯´æ˜engineéƒ½æ˜¯ä»¥åŒå‘é“¾è¡¨å½¢å¼ç®¡ç† */ };   å®Œæˆåˆå§‹åŒ–åï¼Œå°†è¿”å›ä¸Šè¿™ä¸ªnewå‡ºæ¥çš„ENGINEç»“æ„ä½“ã€‚éšåä¸¢åˆ°ENGINE_add é‡Œã€‚\nENGINE_add ä¸Šé¢ç»“æ„ä½“åˆ†æå…¶å®å·²ç»å¯ä»¥çœ‹åˆ°ï¼Œæ‰€æœ‰çš„engineéƒ½å°†ä»¥åŒå‘é“¾è¡¨å½¢å¼ç®¡ç†ï¼Œé“¾è¡¨å»ºç«‹ç®€å•ç²—æš´ï¼Œç›´æ¥å®šä¹‰å…¨å±€å˜é‡ä¸€å¤´ä¸€å°¾ï¼Œæ·»åŠ æ—¶å°±å¾€å°¾å·´åŠ ï¼Œæœç´¢å°±ä»å¤´ç»“ç‚¹å¼€å§‹æœç´¢ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  static ENGINE *engine_list_head = NULL; static ENGINE *engine_list_tail = NULL; /* Add another \u0026#34;ENGINE\u0026#34; type into the list. */ int ENGINE_add(ENGINE *e) { int to_return = 1; /* ä¸€äº›å…¥å‚æ£€æŸ¥ï¼Œomit */ ... /* å…¨å±€å˜é‡æ“ä½œæ—¶éœ€è¦åŠ é”ä»¥æ”¯æŒå¤šçº¿ç¨‹ */ CRYPTO_THREAD_write_lock(global_engine_lock); /* æ ¸å¿ƒå‡½æ•°ï¼Œå°†åˆšåˆšnewå‡ºæ¥çš„dynamicåŠ å…¥å…¨å±€é“¾è¡¨ä¸­ */ if (!engine_list_add(e)) { ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR); to_return = 0; } CRYPTO_THREAD_unlock(global_engine_lock); return to_return; } static int engine_list_add(ENGINE *e) { int conflict = 0; ENGINE *iterator = NULL; if (e == NULL) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER); return 0; } /* ä»é“¾è¡¨å¤´å¼€å§‹è¿­ä»£ */ iterator = engine_list_head; /* ç›´æ¥éå†åˆ°å°¾éƒ¨æŸ¥çœ‹æœ‰æ²¡æœ‰é‡idçš„æƒ…å†µï¼Œé‡idç›´æ¥æŠ¥é”™é€€å‡º */ while (iterator \u0026amp;\u0026amp; !conflict) { conflict = (strcmp(iterator-\u0026gt;id, e-\u0026gt;id) == 0); iterator = iterator-\u0026gt;next; } if (conflict) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } if (engine_list_head == NULL) { /* We are adding to an empty list. */ if (engine_list_tail) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* engine_listä¸ºç©ºçš„è¯åˆ™é“¾è¡¨å¤´ä¸ºæ–°å»ºçš„engine */ engine_list_head = e; e-\u0026gt;prev = NULL; /* * The first time the list allocates, we should register the cleanup. */ engine_cleanup_add_last(engine_list_cleanup); } else { /* We are adding to the tail of an existing list. */ if ((engine_list_tail == NULL) || (engine_list_tail-\u0026gt;next != NULL)) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* å°†æ–°engineåŠ åˆ°é˜Ÿå°¾çš„åé¢ */ engine_list_tail-\u0026gt;next = e; e-\u0026gt;prev = engine_list_tail; } /* * Having the engine in the list assumes a structural reference. */ e-\u0026gt;struct_ref++; engine_ref_debug(e, 0, 1); /* å°†é˜Ÿå°¾æŒ‡å‘æ–°engine */ engine_list_tail = e; e-\u0026gt;next = NULL; return 1; }   è¿™æ ·ï¼Œidä¸º'dynamic'è¢«åŠ å…¥äº†å…¨å±€engineåˆ—è¡¨å½“ä¸­ï¼Œè¢«ç®¡ç†èµ·æ¥ã€‚\nCONF æˆ‘ä»¬è¿™é‡Œå¯¹OpenSSLçš„åŠ¨æ€é…ç½®confä¸éœ€è¦ç»†è‡´åˆ†æï¼Œéšç€ä»£ç åˆ†æå³å¯ã€‚å®˜æ–¹æ–‡æ¡£å…¶å®å¯¹confæ ¼å¼è®²è§£çš„å¾ˆæ¸…æ¥šï¼Œå¯ä»¥å­¦ä¹ :\nhttps://www.openssl.org/docs/man1.1.1/man5/config.html\nEngine Configuration Moduleè¿™ä¸ªå°èŠ‚\nä¾‹å­ä¸­confæ–‡ä»¶ é¦–å…ˆæˆ‘ä»¬æ¥çœ‹engineXä¾‹å­ä¸­çš„confæ˜¯æ€ä¹ˆå†™çš„ï¼š\nopenssl_conf = openssl_def [openssl_def] engines = engine_section [engine_section] engine_x = engine_x_section [engine_x_section] engine_id = engineX dynamic_path = ${ENV::PWD}/build/engine_ex.so default_algorithms = ALL init = 1 ç®€å•å­¦ä¹ ä¸€ä¸‹confä¹‹åï¼Œæˆ‘ä»¬ä¹‹åè¿™ä¸ªé…ç½®æ–‡ä»¶æ ¸å¿ƒçš„sectionå°±æ˜¯engine_sectionï¼Œå…¶ä¸­dynamic_pathå®šä¹‰ä¸Šäº†è¯¥engineå…±äº«åº“çš„è·¯å¾„ã€‚æˆ‘ä»¬çœ‹çœ‹ä¾‹å­ä¸­æ˜¯å¦‚ä½•æ ¹æ®è¿™ä¸ªé…ç½®æ–‡ä»¶å»åŠ è½½å¯¹åº”çš„engineçš„\nCONF_modules_load_file 1 2 3 4 5 6 7 8  ... char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { ... } ...   CONF_modules_load_fileæ˜¯å»åŠ è½½é…ç½®å¹¶ä½¿èƒ½é…ç½®çš„æ¥å£ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸»è¦å…³å¿ƒå¦‚ä½•å»æ ¹æ®é…ç½®æ–‡ä»¶å»åŠ è½½åŠ¨æ€åº“ï¼Œå…·ä½“æ€ä¹ˆå®Œæˆé…ç½®æ–‡ä»¶è§£æçš„æµç¨‹è¿™é‡Œä¸è®¨è®ºã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  int CONF_modules_load_file(const char *filename, const char *appname, unsigned long flags) { return CONF_modules_load_file_with_libctx(NULL, filename, appname, flags); } int CONF_modules_load_file_with_libctx(OPENSSL_CTX *libctx, const char *filename, const char *appname, unsigned long flags) { char *file = NULL; CONF *conf = NULL; int ret = 0; conf = NCONF_new_with_libctx(libctx, NULL); if (conf == NULL) goto err; if (filename == NULL) { file = CONF_get1_default_config_file(); if (file == NULL) goto err; } else { file = (char *)filename; } if (NCONF_load(conf, file, NULL) \u0026lt;= 0) { if ((flags \u0026amp; CONF_MFLAGS_IGNORE_MISSING_FILE) \u0026amp;\u0026amp; (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) { ERR_clear_error(); ret = 1; } goto err; } ret = CONF_modules_load(conf, appname, flags); err: if (filename == NULL) OPENSSL_free(file); NCONF_free(conf); if (flags \u0026amp; CONF_MFLAGS_IGNORE_RETURN_CODES) return 1; return ret; }   å¯ä»¥çœ‹åˆ°è¿™é‡Œä¸»è¦æœ‰ä¸‰æ­¥æ“ä½œNCONF_new_with_libctxã€NCONF_loadã€CONF_modules_loadï¼Œæˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªåˆ†æã€‚\nNCONF_new_with_libctx è¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯åˆå§‹åŒ–ä¸Šäº†ä¸€ä¸ªCONFç»“æ„ä½“ï¼ŒåŒæ—¶å°†è¿™ä¸ªç»“æ„ä½“çš„METHODå®šä¹‰æˆäº†é»˜è®¤æ–¹æ³•ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  /* é…ç½®æ–‡ä»¶çš„methodæ¨¡æ¿ */ struct conf_method_st { const char *name; CONF *(*create) (CONF_METHOD *meth); int (*init) (CONF *conf); int (*destroy) (CONF *conf); int (*destroy_data) (CONF *conf); int (*load_bio) (CONF *conf, BIO *bp, long *eline); int (*dump) (const CONF *conf, BIO *bp); int (*is_number) (const CONF *conf, char c); int (*to_int) (const CONF *conf, char c); int (*load) (CONF *conf, const char *name, long *eline); }; /* * æ‰€æœ‰çš„ AA = BB éƒ½ä¼šæŒ‰ç…§è¿™ä¸ªæ ¼å¼ä¿å­˜ * å¦‚[openssl_def] engines = engine_section * æ­¤æ—¶è¿™ä¸ªåº•ä¸‹conf_stçš„å“ˆå¸Œè¡¨ä¸­å°†ä¿å­˜ä¸Šä¸€ä»½ * {.section = \u0026#34;openssl_def\u0026#34;, .name = \u0026#34;engines\u0026#34;, value = \u0026#34;engine_section\u0026#34;} */ typedef struct { char *section; char *name; char *value; } CONF_VALUE; struct conf_st { CONF_METHOD *meth; /* åŠ¨æ€é…ç½®çš„æ–¹æ³•ï¼Œè¿™é‡Œä½¿ç”¨default */ void *meth_data; LHASH_OF(CONF_VALUE) *data; /* ä¸Šæ–‡æœ‰æåˆ°çš„å“ˆå¸Œè¡¨ */ unsigned int flag_dollarid:1; OPENSSL_CTX *libctx; }; /* * The following section contains the \u0026#34;New CONF\u0026#34; functions. They are * completely centralised around a new CONF structure that may contain * basically anything, but at least a method pointer and a table of data. * These functions are also written in terms of the bridge functions used by * the \u0026#34;CONF classic\u0026#34; functions, for consistency. */ CONF *NCONF_new_with_libctx(OPENSSL_CTX *libctx, CONF_METHOD *meth) { CONF *ret; if (meth == NULL) meth = NCONF_default(); ret = meth-\u0026gt;create(meth); if (ret == NULL) { CONFerr(0, ERR_R_MALLOC_FAILURE); return NULL; } /* è¿™ä¸ªæµç¨‹ä¸­æ˜¯NULLï¼Œä¸éœ€è¦åˆ†æ */ ret-\u0026gt;libctx = libctx; return ret; }   æˆ‘ä»¬å…ˆçœ‹NCONF_defaultï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* æ ‡è®°ä¸Šè¿™äº›æ–¹æ³•ï¼Œç›¸å…³å®šä¹‰åç»­ä¼šç»™å‡ºï¼Œä¸”å°†ä¼šä½¿ç”¨ */ static CONF_METHOD default_method = { \u0026#34;OpenSSL default\u0026#34;, def_create, def_init_default, def_destroy, def_destroy_data, def_load_bio, def_dump, def_is_number, def_to_int, def_load }; CONF_METHOD *NCONF_default(void) { return \u0026amp;default_method; }   ç¬¬ä¸€ä¸ªåœ¨default_methodè¢«ä½¿ç”¨çš„æ–¹æ³•å°±æ˜¯def_create, å¾ˆæ˜æ˜¾æ˜¯å»ç”³è¯·ä¸€å—CONFç»“æ„ä½“å†…å­˜ï¼Œä¹‹åè°ƒç”¨def_init_defaultå»åˆå§‹åŒ–ç»“æ„ä½“ :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  static CONF *def_create(CONF_METHOD *meth) { CONF *ret; ret = OPENSSL_malloc(sizeof(*ret)); if (ret != NULL) /* è¿™é‡Œè°ƒç”¨`def_init_default` */ if (meth-\u0026gt;init(ret) == 0) { OPENSSL_free(ret); ret = NULL; } return ret; } static int def_init_default(CONF *conf) { if (conf == NULL) return 0; memset(conf, 0, sizeof(*conf)); /* å°†æ–°ç”³è¯·çš„CONFç»“æ„ä½“çš„methodå­—æ®µè®¾ç½®ä¸ºé»˜è®¤method */ conf-\u0026gt;meth = \u0026amp;default_method; /* meth_dataçš„è®¾ç½®ï¼Œè¿™ä¸ªæ˜¯.confæ–‡ä»¶å­—ç¬¦è§£ææ—¶å€™ä½¿ç”¨çš„ï¼Œæˆ‘ä»¬è¿™é‡Œä¸è®² */ conf-\u0026gt;meth_data = (void *)CONF_type_default; return 1; }   NCONF_load åˆå§‹åŒ–å¥½CONFç»“æ„ä½“ï¼Œç¡®å®šå¥½å¯¹åº”é…ç½®æ–‡ä»¶åï¼Œå¼€å§‹å¯¹é…ç½®æ–‡ä»¶è¿›è¡Œè§£æï¼ŒNCONF_load ï¼ˆOpenSSLè¿é…ç½®æ–‡ä»¶æ ¼å¼éƒ½è‡ªå·±å®šä¹‰è‡ªå·±è§£æï¼Œç¡¬æ ¸ç¡¬æ ¸ï¼‰å°†è°ƒç”¨åˆ°é»˜è®¤æ–¹æ³•ä¹‹ def_load\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  int NCONF_load(CONF *conf, const char *file, long *eline) { if (conf == NULL) { CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF); return 0; } return conf-\u0026gt;meth-\u0026gt;load(conf, file, eline); } static int def_load(CONF *conf, const char *name, long *line) { int ret; BIO *in = NULL; /* è¿™é‡Œé€šè¿‡BIOè¯»å…¥æ–‡ä»¶(Binary IO, opensslè‡ªå·±å®šä¹‰çš„ioï¼Œç®€å•ç†è§£å°±æ˜¯ä¸€å—å†…å­˜Orz) */ #ifdef OPENSSL_SYS_VMS  in = BIO_new_file(name, \u0026#34;r\u0026#34;); #else  in = BIO_new_file(name, \u0026#34;rb\u0026#34;); #endif \t... /* æ­£å¼è§£æï¼ŒæŒ‰æ®µè§£æï¼› * è¿™é‡Œä¸åˆ†æå’‹è§£æçš„ï¼Œå¾ˆå¤æ‚å¾ˆé•¿ï¼Œç”šè‡³èƒ½å¤„ç†ä¸€äº›ç¯å¢ƒå˜é‡$(xxx)... æœ * æœ€åç»“æœéƒ½å­˜åœ¨å“ˆå¸Œè¡¨dataä¸­ */ ret = def_load_bio(conf, in, line); BIO_free(in); return ret; }   CONF_modules_load æ ¸å¿ƒè¿‡ç¨‹ï¼Œä»CONFå»åŠ è½½ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„'engines'è¿™ä¸ªmodule:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  int CONF_modules_load(const CONF *cnf, const char *appname, unsigned long flags) { STACK_OF(CONF_VALUE) *values; CONF_VALUE *vl; char *vsection = NULL; int ret, i; if (!cnf) return 1; /* å…ˆè·å–åˆ°å¯¹åº”çš„sectionåï¼Œè¿™é‡Œå°±æ˜¯\u0026#34;openssl_conf\u0026#34; */ if (appname) vsection = NCONF_get_string(cnf, NULL, appname); if (!appname || (!vsection \u0026amp;\u0026amp; (flags \u0026amp; CONF_MFLAGS_DEFAULT_SECTION))) vsection = NCONF_get_string(cnf, NULL, \u0026#34;openssl_conf\u0026#34;); if (!vsection) { ERR_clear_error(); return 1; } OSSL_TRACE1(CONF, \u0026#34;Configuration in section %s\\n\u0026#34;, vsection); /* * æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ®µ openssl_conf * [openssl_def] * engines = engine_section */ values = NCONF_get_section(cnf, vsection); if (!values) return 0; for (i = 0; i \u0026lt; sk_CONF_VALUE_num(values); i++) { vl = sk_CONF_VALUE_value(values, i); /* éå†æ‰€æœ‰çš„valueï¼Œè¿™é‡Œåªæœ‰ä¸€ä¸ª \u0026#39;engines\u0026#39; */ ret = module_run(cnf, vl-\u0026gt;name, vl-\u0026gt;value, flags); OSSL_TRACE3(CONF, \u0026#34;Running module %s (%s) returned %d\\n\u0026#34;, vl-\u0026gt;name, vl-\u0026gt;value, ret); if (ret \u0026lt;= 0) if (!(flags \u0026amp; CONF_MFLAGS_IGNORE_ERRORS)) return ret; } return 1; } static int module_run(const CONF *cnf, const char *name, const char *value, unsigned long flags) { CONF_MODULE *md; int ret; if (!RUN_ONCE(\u0026amp;load_builtin_modules, do_load_builtin_modules)) return -1; /* è¿™é‡Œä¼šåœ¨supported_modulesè¿™ä¸ªæ ˆä¸Šæ‰¾åˆ°\u0026#39;engines\u0026#39;è¿™ä¸ªCONF_MODULEï¼Œå¼€å§‹é­”å¹»è¡¨æ¼” */ md = module_find(name); ... /* initè¿™ä¸ªmoduleï¼Œè¿™é‡Œå°†å»è°ƒç”¨åˆ°\u0026#39;dynamic\u0026#39;è¿™ä¸ªengineï¼Œä¸‹é¢å°†åˆ†æ */ ret = module_init(md, name, value, cnf); ... return ret; } /* initialize a module */ /* æ­¤å¤„å°†ç”³è¯·ä¸Šä¸€ä¸ªæ‰€è°“çš„initialized moduleï¼Œ * ä¹‹åè°ƒç”¨\u0026#39;engines\u0026#39;çš„initå‡½æ•° * è‹¥æˆåŠŸï¼Œå°†\u0026#39;engines\u0026#39; pushè¿›çš„å…¨å±€å˜é‡æ ˆ initialized_modules */ static int module_init(CONF_MODULE *pmod, const char *name, const char *value, const CONF *cnf) { int ret = 1; int init_called = 0; CONF_IMODULE *imod = NULL; /* Otherwise add initialized module to list */ imod = OPENSSL_malloc(sizeof(*imod)); if (imod == NULL) goto err; imod-\u0026gt;pmod = pmod; imod-\u0026gt;name = OPENSSL_strdup(name); /* å³\u0026#39;engines\u0026#39; */ imod-\u0026gt;value = OPENSSL_strdup(value); imod-\u0026gt;usr_data = NULL; if (!imod-\u0026gt;name || !imod-\u0026gt;value) goto memerr; /* Try to initialize module */ if (pmod-\u0026gt;init) { /* è°ƒç”¨enginesçš„initï¼Œå³ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„int_engine_module_initå‡½æ•° */ ret = pmod-\u0026gt;init(imod, cnf); init_called = 1; /* Error occurred, exit */ if (ret \u0026lt;= 0) goto err; } if (initialized_modules == NULL) { initialized_modules = sk_CONF_IMODULE_new_null(); if (!initialized_modules) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } } /* å°†\u0026#39;engines\u0026#39; pushè¿›çš„å…¨å±€å˜é‡æ ˆ initialized_modules */ if (!sk_CONF_IMODULE_push(initialized_modules, imod)) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } pmod-\u0026gt;links++; return ret; err: ... }   CONFçš„ç¬¬ä¸€éƒ¨åˆ†å¤„ç†å®Œæ¯•ï¼Œå¼€å§‹æŸ¥çœ‹å¦‚ä½•ç»§ç»­è§£æè¿™ä¸ªé…ç½®\nint_engine_module_init è¿™éƒ¨åˆ†å¼€å§‹å–enginesè¿™ä¸ªsectionä¸‹çš„æ•°æ®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  static int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf) { STACK_OF(CONF_VALUE) *elist; CONF_VALUE *cval; int i; OSSL_TRACE2(CONF, \u0026#34;Called engine module: name %s, value %s\\n\u0026#34;, CONF_imodule_get_name(md), CONF_imodule_get_value(md)); /* Value is a section containing ENGINEs to configure */ elist = NCONF_get_section(cnf, CONF_imodule_get_value(md)); /* * è·å–engine_sectionä¸‹çš„åˆ—è¡¨ï¼Œè¿™é‡Œå°±ä¸€ä¸ªsectionå«åšengine_x_section * [engine_section] * engine_x = engine_x_section */ if (!elist) { ENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT, ENGINE_R_ENGINES_SECTION_ERROR); return 0; } for (i = 0; i \u0026lt; sk_CONF_VALUE_num(elist); i++) { cval = sk_CONF_VALUE_value(elist, i); /* * name: engine_x, value: engine_x_section * å‡†å¤‡å¼€å§‹åŠ è½½äº† */ if (!int_engine_configure(cval-\u0026gt;name, cval-\u0026gt;value, cnf)) return 0; } return 1; }   int_engine_configure æ˜¯åŠ è½½engineçš„ä¸»è¦æµç¨‹ï¼Œæˆ‘ä»¬æŒ‰é¡ºåºæ¥ä¸€æ­¥ä¸€æ­¥åˆ†æå†…éƒ¨çš„å¾ªç¯\nint_engine_configure  é¦–å…ˆåŠ è½½ä¸Švalueçš„sectionï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { int i; int ret = 0; long do_init = -1; STACK_OF(CONF_VALUE) *ecmds; CONF_VALUE *ecmd = NULL; const char *ctrlname, *ctrlvalue; ENGINE *e = NULL; int soft = 0; name = skip_dot(name); OSSL_TRACE1(CONF, \u0026#34;Configuring engine %s\\n\u0026#34;, name); /* Value is a section containing ENGINE commands */ /* åœ¨confçš„å“ˆå¸Œè¡¨ä¸­æ‰¾ å«åšengine_x_sectionçš„section */ ecmds = NCONF_get_section(cnf, value); /* * æ­¤æ—¶ecmdsæ˜¯ä¸€ä¸ªæ ˆï¼ŒæŒ‰é¡ºåºæœ‰ä»¥ä¸‹CONF_VALUE (å…±æœ‰section = \u0026#34;engine_x_section\u0026#34;) * {.name = \u0026#34;engine_id\u0026#34;, .value = \u0026#34;engineX\u0026#34;} * {.name = \u0026#34;dynamic_path\u0026#34;, .value = \u0026#34;${ENV::PWD}/build/engine_ex.so\u0026#34;(è¿™é‡Œå·²ç»é€šé…ç¬¦è§£æ\t*\täº†)} * {.name = \u0026#34;default_algorithms\u0026#34;, .value = \u0026#34;ALL\u0026#34;} * {.name = \u0026#34;init\u0026#34;, .value = \u0026#34;1\u0026#34;} */ if (!ecmds) { ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE, ENGINE_R_ENGINE_SECTION_ERROR); return 0; } ... }    æŒ‰ç…§é¡ºåºè§£æï¼š\nç¬¬ä¸€ä¸ªæ˜¯engine_id:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { ... /* å¼€å§‹å¯¹ecmdsä¸­æ ˆä¸Šçš„CONF_VALUEéå†ï¼Œè¿™éƒ¨åˆ†ä»£ç éƒ½åœ¨è¿™ä¸ªforå¾ªç¯ä¸­ */ for (i = 0; i \u0026lt; sk_CONF_VALUE_num(ecmds); i++) { ecmd = sk_CONF_VALUE_value(ecmds, i); /* è§£æå‡ºctrlnameå’Œctrlvalueï¼Œå¯¹åº”ç»“æ„ä½“ä¸­.nameå’Œ.value, ä¸‹åŒ */ ctrlname = skip_dot(ecmd-\u0026gt;name); ctrlvalue = ecmd-\u0026gt;value; OSSL_TRACE2(CONF, \u0026#34;ENGINE: doing ctrl(%s,%s)\\n\u0026#34;, ctrlname, ctrlvalue); /* First handle some special pseudo ctrls */ /* Override engine name to use */ if (strcmp(ctrlname, \u0026#34;engine_id\u0026#34;) == 0) /* æŠŠnameåˆ¶æˆconfæ–‡ä»¶ä¸­engine_id */ name = ctrlvalue; ... } ... }   ç¬¬äºŒä¸ªæ˜¯dynamic_pathï¼Œ è¿™ä¸ªå®šä¹‰æœ€å…³é”®ï¼Œæ‰¾åˆ°è¿™ä¸ªnameï¼Œå¼€å§‹æŒ‰ç…§æŒ‡å®šè·¯å¾„åŠ è½½åŠ¨æ€åº“engine:\nfor(\u0026hellip;) {\n\u0026hellip;\nelse if (strcmp(ctrlname, \u0026ldquo;dynamic_path\u0026rdquo;) == 0) {\n/*\n* çœ‹åˆ°è¿™é‡Œæ˜¯ä¸æ˜¯è±ç„¶å¼€æœ—ï¼Œé¦–å…ˆæ‰¾åˆ°ç¬¬äºŒéƒ¨åˆ†åˆå§‹åŒ–çš„å«åšdynamicçš„engine\n* ä½†è¿™ä¸ªåœ°æ–¹æœ‰ä¸ªå€¼å¾—æ³¨æ„çš„ç‚¹ï¼Œåº•ä¸‹åˆ†æENGINE_by_id\n/\ne = ENGINE_by_id(\u0026ldquo;dynamic\u0026rdquo;);\n/ æ‹¿åˆ°\u0026rsquo;dynamic\u0026rsquo;è¿™ä¸ªENGINEç»“æ„ä½“åï¼Œè¿›è¡Œä¸‰æ­¥æ“ä½œï¼Œå®Œæˆäº†engineXè¿™ä¸ªsoçš„åŠ è½½ /\n/ ä¹‹åæˆ‘ä»¬å°†å•ç‹¬æŠŠENGINE_ctrl_cmd_stringæ‹¿å‡ºæ¥åˆ†æï¼Œè§‚å¯Ÿå®ƒæ˜¯å¦‚ä½•å»åŠ è½½çš„*/\nif (!e)\ngoto err;\nif (!ENGINE_ctrl_cmd_string(e, \u0026ldquo;SO_PATH\u0026rdquo;, ctrlvalue, 0))\ngoto err;\nif (!ENGINE_ctrl_cmd_string(e, \u0026ldquo;LIST_ADD\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, 0))\ngoto err;\nif (!ENGINE_ctrl_cmd_string(e, \u0026ldquo;LOAD\u0026rdquo;, NULL, 0))\ngoto err;\n\u0026hellip;\n}\n/*\n   å®Œæˆè¿™ä¸‰æ­¥æ“ä½œåï¼Œ\u0026lsquo;dynamic\u0026rsquo;å‰¯æœ¬è¿™ä¸ªengineå·²ç»è¢«é‡å†™æˆäº† \u0026rsquo;engineX\u0026rsquo;ï¼ åŒæ—¶è¿™ä¸ªengineXä¹ŸåŠ å…¥äº†enginesçš„é˜Ÿåˆ—ä¸­ã€‚\n*/  ENGINE *ENGINE_by_id(const char id)\n{\n/ å…¥å‚æ£€æŸ¥å’Œç¯å¢ƒåˆå§‹åŒ–æ£€æŸ¥ omit /\n\u0026hellip;\n/ åŠ é”åå¼€å§‹éå†é“¾è¡¨ï¼ŒåŒ¹é…id = \u0026ldquo;dynamic\u0026rdquo; */\nCRYPTO_THREAD_write_lock(global_engine_lock);\niterator = engine_list_head;\n while (iterator \u0026amp;\u0026amp; (strcmp(id, iterator-\u0026gt;id) != 0)) iterator = iterator-\u0026gt;next; if (iterator != NULL) { /* * We need to return a structural reference. If this is an ENGINE * type that returns copies, make a duplicate - otherwise increment * the existing ENGINE's reference count. */ /* åŒ¹é…æˆåŠŸåçš„å°æ“ä½œï¼šçœ‹ENGINE_load_dynamicæºç å¯ä»¥çœ‹åˆ° dynamic-\u0026gt;flag è¢«è®¾ç½®æˆäº†\tENGINE_FLAGS_BY_ID_COPY */ if (iterator-\u0026gt;flags \u0026amp; ENGINE_FLAGS_BY_ID_COPY) { ENGINE *cp = ENGINE_new(); if (cp == NULL) iterator = NULL; else { /* æ­¤å¤„å¾ˆé‡è¦ï¼ */ /* æ­¤å¤„å–å‡ºçš„dynamicï¼Œä¸æ˜¯ç›´æ¥å–å‡ºé“¾è¡¨ä¸­çš„engineèŠ‚ç‚¹ï¼Œè€Œæ˜¯å¤åˆ¶äº†ä¸€ä¸ªèŠ‚ç‚¹ */ engine_cpy(cp, iterator); iterator = cp; } } else { iterator-\u0026gt;struct_ref++; engine_ref_debug(iterator, 0, 1); } } CRYPTO_THREAD_unlock(global_engine_lock); if (iterator != NULL) /* ä½œä¸ºå–å‡ºè¿”å›å€¼ï¼Œå¾—åˆ°äº†ä¸€ä¸ªdynamicçš„å‰¯æœ¬ */ return iterator;  }\næ³¨æ„ï¼Œæ­¤æ—¶eè¿™ä¸ªå±€éƒ¨å˜é‡å·²ç»æ˜¯ä¸€ä¸ªidä¸º'engineX'çš„ENGINEç»“æ„ä½“äº†ï¼Œä¹Ÿå°±æ˜¯å®Œæˆäº†åŠ¨æ€åŠ è½½çš„engineï¼\nç¬¬ä¸‰æ­¥æ˜¯default_algorithmsï¼Œæœ‰ç¼˜çš„è¯ï¼Œè¿™ç¯‡æ–‡ç« ç¬¬äºŒéƒ¨åˆ†ä¼šåˆ†æè®¾ç½®è¿‡ç¨‹ :\n1 2 3 4 5  for (...) { else if (strcmp(ctrlname, \u0026#34;default_algorithms\u0026#34;) == 0) { if (!ENGINE_set_default_string(e, ctrlvalue)) ... }   ç¬¬å››æ­¥ï¼Œå®ŒæˆInit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  for (...) { if (strcmp(ctrlname, \u0026#34;init\u0026#34;) == 0) { if (!NCONF_get_number_e(cnf, value, \u0026#34;init\u0026#34;, \u0026amp;do_init)) goto err; if (do_init == 1) { /* * æ­¤å¤„ä¸º1ï¼Œå®Œæˆengine init, * å…·ä½“ä»£ç å°±æ˜¯è°ƒç”¨ENGINE_initå»æ‰§è¡Œe-\u0026gt;init, å¢åŠ å¼•ç”¨æ•°ä¹‹ç±»çš„ï¼Œæˆ‘ä»¬è¿™é‡Œå…¶å®æ˜¯ç©ºçš„ * ä¹‹åå»æŠŠè¿™ä¸ªengineåŒæ—¶åŠ å…¥initialized_enginesè¿™ä¸ªå…¨å±€å˜é‡æ ˆä¸­ã€‚ä»£ç ä¸çœ‹äº† */ if (!int_engine_init(e)) goto err; ... }   å°±æ­¤CONF_modules_loadå…¨éƒ¨è¿è¡Œå®Œæˆï¼ŒengineXåŠ è½½å®Œæ¯•ã€‚åç»­åªéœ€è¦åƒmainå‡½æ•°ä¸­çš„ä½¿ç”¨ENGINE_by_id(\u0026quot;engineX\u0026quot;);å°±å¯ä»¥å–å¾—è¿™ä¸ªengineäº†ã€‚åœ†æ»¡ã€‚\nä½†æ˜¯ bind_engine åœ¨å“ªè°ƒç”¨çš„å‘¢ï¼Œè¿˜æ˜¯æ²¡çœ‹åˆ°ï¼Œé‚£å¿…ç„¶æ˜¯åœ¨ENGINE_ctrl_cmd_stringæµç¨‹ä¸­ã€‚æ‰€ä»¥ä¸‹é¢é‡ç‚¹è®²è®²è¿™ä¸ªå‡½æ•°ã€‚\nENGINE_ctrl_cmd_string ä»cmd_nameå»è·å–cmd_num int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { int num, flags; long l; char *ptr; ... /* å®çš„å‘½åå·²ç»æš´éœ²äº†ä¸€åˆ‡ï¼Œé€šè¿‡cmd_nameå¾—åˆ°cmd_num */ if (e-\u0026gt;ctrl == NULL || (num = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FROM_NAME, 0, (void *)cmd_name, NULL)) \u0026lt;= 0) { ... } ... } int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... /* * Intercept any \u0026#34;root-level\u0026#34; commands before trying to hand them on to * ctrl() handlers. */ switch (cmd) { /* è¿™éƒ¨åˆ†æ˜¯é€šç”¨çš„ctrlï¼ŒèŒƒå›´ä¸º10 ~ 18, å…¨éƒ¨è¿›å…¥int_ctrl_helper */ case ENGINE_CTRL_HAS_CTRL_FUNCTION: return ctrl_exists; case ENGINE_CTRL_GET_FIRST_CMD_TYPE: case ENGINE_CTRL_GET_NEXT_CMD_TYPE: case ENGINE_CTRL_GET_CMD_FROM_NAME: case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: case ENGINE_CTRL_GET_NAME_FROM_CMD: case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: case ENGINE_CTRL_GET_DESC_FROM_CMD: case ENGINE_CTRL_GET_CMD_FLAGS: /* * è¿™é‡Œdynamicçš„flagä¸ºENGINE_FLAGS_BY_ID_COPYï¼Œ0x0004 * ENGINE_FLAGS_MANUAL_CMD_CTRL = 0x0002ï¼Œä¸çš„ç»“æœä¸º0 */ if (ctrl_exists \u0026amp;\u0026amp; !(e-\u0026gt;flags \u0026amp; ENGINE_FLAGS_MANUAL_CMD_CTRL)) return int_ctrl_helper(e, cmd, i, p, f); if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); /* * For these cmd-related functions, failure is indicated by a -1 * return value (because 0 is used as a valid return in some * places). */ return -1; } default: break; } /* Anything else requires a ctrl() handler to exist. */ /* è¿™é‡Œæ˜¯ç¡®å®šå½“å‰engine-\u0026gt;ctrl != NULL */ if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); return 0; } /* è°ƒç”¨ä¸Šé¢çœ‹åˆ°çš„ dynamic-\u0026gt;ctrl = dynamic_ctrl, åé¢ä¼šè°ƒç”¨åˆ°è¿™æ¥ */ return e-\u0026gt;ctrl(e, cmd, i, p, f); } /* è¿™ä¸ªå‡½æ•°ä¹Ÿå°†åå¤è°ƒç”¨ï¼ˆåæ§½ä¸‹opensslè¿™é¬¼ä¹‹è®¾è®¡ï¼‰ï¼Œæˆ‘ä»¬è¿™é‡Œå…ˆçœ‹å½“å‰çš„cmd */ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { int idx; char *s = (char *)p; const ENGINE_CMD_DEFN *cdp; ... /* Now handle cmd_name -\u0026gt; cmd_num conversion */ if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) { /* ä»dynamicçš„cmd_defnsä¸­å»åŒ¹é…cmd_name,å‡è®¾æ˜¯\u0026#34;SO_PATH\u0026#34;, ç›´æ¥å»æŸ¥ç¬¬äºŒéƒ¨åˆ†çš„dynamic_cmd_defnsï¼Œåˆšå¥½åŒ¹é…ä¸Šidx = 0 */ if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(e-\u0026gt;cmd_defns, s)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME); return -1; } /* æŸ¥idx = 0æ—¶çš„ cmd_num = 200 = DYNAMIC_CMD_SO_PATH */ return e-\u0026gt;cmd_defns[idx].cmd_num; } ... } å¯ä»¥çœ‹åˆ°è¿™é‡Œçš„numè¿”å›å›æ¥çš„DYNAMIC_CMD_SO_PATHï¼Œæ˜¯é dynamic.cmd_defnsä¸­çš„ENGINE_CMD_DEFNæ•°ç»„è¡¨æŸ¥è¯¢å¾—åˆ°çš„ã€‚å¾€ä¸‹æ¥ç€çœ‹ENGINE_ctrl_cmd_string\nint ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { /* ç»§ç»­è°ƒç”¨å…¬ç”¨ctrlï¼Œè¿›å…¥åˆ°int_ctrl_helper (çœ‹åº•ä¸‹å¼€æºçš„æ³¨é‡Šï¼Œä¸¤ä¸ªå‡½æ•°åšçš„ctrlæ“ä½œä¸€æ ·çš„ï¼Œä¸ºå•¥è¿™ä¹ˆæä¹Ÿè®¸å°±æ˜¯æœªè§£ä¹‹è°œå§) */ ... if (!ENGINE_cmd_is_executable(e, num)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_CMD_NOT_EXECUTABLE); return 0; } /* é¡¾åæ€ä¹‰ï¼Œæ‹¿åˆ°dynamicçš„flagï¼Œè¿™é‡Œå°†å¾—åˆ°idx = 0æ—¶ï¼Œcmd_defnsè¡¨ä¸­0å¤„çš„ç¬¬å››ä¸ªå…ƒç´  */ flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL); if (flags \u0026lt; 0) { /* * Shouldn\u0026#39;t happen, given that ENGINE_cmd_is_executable() returned * success. */ ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } } static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e-\u0026gt;cmd_defns, (unsigned int)i)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER); return -1; } /* Now the logic splits depending on command type */ cdp = \u0026amp;e-\u0026gt;cmd_defns[idx]; switch (cmd) { ... case ENGINE_CTRL_GET_CMD_FLAGS: /* å¯ä»¥æŸ¥å‡ºæ¥ä¸Šé¢çš„æ˜¯ ENGINE_CMD_FLAG_STRING = 0x0002 */ return cdp-\u0026gt;cmd_flags; } ... } åˆ«é—®ä¸ºå•¥ä¸ä¸€æ¬¡æŸ¥å‡ºæ¥ï¼Œè¦å¤šæ¬¡éå†ï¼Œé—®å°±æ˜¯æ¶æ„ã€‚ç»§ç»­çœ‹ENGINE_ctrl_cmd_stringï¼Œç»ˆäºè¦åšçœŸæ­£çš„æ“ä½œäº†ï¼Œ å¯ä»¥çœ‹åˆ°ï¼Œæœ€åè¿›å…¥äº†dynamic_ctrlï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { ... /* ENGINE_CMD_FLAG_NO_INPUT = 0x0004 */ if (flags \u0026amp; ENGINE_CMD_FLAG_NO_INPUT) { /* å¦‚æœå‘½ä»¤æŸ¥å‡ºæ¥çš„flagåº”è¯¥æ²¡æœ‰arg_input, ä½†argéç©ºï¼Œç›´æ¥é€€å‡º???? */ if (arg != NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_NO_INPUT); return 0; } /* * We deliberately force the result of ENGINE_ctrl() to 0 or 1 rather * than returning it as \u0026#34;return data\u0026#34;. This is to ensure usage of * these commands is consistent across applications and that certain * applications don\u0026#39;t understand it one way, and others another. */ /* æœ€å\u0026#34;LOAD\u0026#34;å‘½ä»¤èµ°çš„è¿™ */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* So, we require input */ if (arg == NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_INPUT); return 0; } /* ä¸€å®šæœ‰æ›´å¥½çš„å†™æ³•å§ï¼Œè¿™ç§åˆ¤æ–­ä¹Ÿå¤ªè¿·æƒ‘äº†ã€‚ã€‚ */ /* If it takes string input, that\u0026#39;s easy */ if (flags \u0026amp; ENGINE_CMD_FLAG_STRING) { /* Same explanation as above */ /* æ‰€ä»¥åº”è¯¥è°ƒç”¨åˆ°è¿™ï¼Œæ³¨æ„æ­¤æ—¶num å°†å¤§äº200, è‚¯å®šä¸æ˜¯é»˜è®¤çš„æµç¨‹ï¼Œ è¿™å°±èµ°åˆ°äº†return e-\u0026gt;ctrl(e, cmd, i, p, f); å³ dynamic_ctrl */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* æ­¤æ—¶argæ˜¯æ•°å­—ï¼Œéœ€è¦ä»strè½¬intï¼ŒLIST_ADDèµ°è¿™ */ if (!(flags \u0026amp; ENGINE_CMD_FLAG_NUMERIC)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } l = strtol(arg, \u0026amp;ptr, 10); if ((arg == ptr) || (*ptr != \u0026#39;\\0\u0026#39;)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER); return 0; } /* * Force the result of the control command to 0 or 1, for the reasons * mentioned before. */ if (ENGINE_ctrl(e, num, l, NULL, NULL) \u0026gt; 0) return 1; ... }   æ‰€ä»¥è¿™ä¸ªå‡½æ•°çš„ä¸»è¦æ­¥éª¤å°±æ˜¯æ ¹æ®è¾“å…¥çš„cmd_nameä»dynamicä¸­æŒ‚è½½çš„cmd_defnså–å‡ºå¯¹åº”çš„cmd_numå’Œflagï¼Œä¹‹åç”¨cmd_numè°ƒç”¨åˆ°dynamicæŒ‚è½½çš„ctrlå­—æ®µå‡½æ•°å»åšçœŸæ­£çš„æ“ä½œã€‚æˆ‘ä»¬ç”¨ä¸€å¼ è¡¨ç»Ÿè®¡ä¸‹ä¸‰æ¬¡å–åˆ°çš„ç»“æœï¼š\n   cmd_name cmd_num flag     \u0026ldquo;SO_PATH\u0026rdquo; DYNAMIC_CMD_SO_PATH = 200 ENGINE_CMD_FLAG_STRING 0x0002   \u0026ldquo;LIST_ADD\u0026rdquo; DYNAMIC_CMD_LIST_ADD = 203 ENGINE_CMD_FLAG_NUMERIC 0x0001   \u0026ldquo;LOAD\u0026rdquo; DYNAMIC_CMD_LOAD = 206 ENGINE_CMD_FLAG_NO_INPUT 0x0004    æ ¹æ®è¿™ä¸ªè¡¨ï¼Œæˆ‘ä»¬å»çœ‹å¯¹äºdynamic-\u0026gt;ctrlå³dynamic_ctrlå‡½æ•°å¯¹è¿™å‡ ä¸ªcmdçš„æ“ä½œ\ndynamic_ctrl å…ˆçœ‹è¿™ä¸ªå‡½æ•°çš„å…¬å…±éƒ¨åˆ†ï¼Œå¯¹ç›¸åŒçš„engineä¼šåˆå§‹åŒ–ä¸Šä¸€ä¸ªctxä¸Šä¸‹æ–‡ï¼š\n/* åŠ¨æ€åº“åŠ è½½çš„ä¸Šä¸‹æ–‡ */ struct st_dynamic_data_ctx { /* The DSO object we load that supplies the ENGINE code */ DSO *dynamic_dso; /* * The function pointer to the version checking shared library function */ dynamic_v_check_fn v_check; /* * The function pointer to the engine-binding shared library function */ dynamic_bind_engine bind_engine; /* The default name/path for loading the shared library */ char *DYNAMIC_LIBNAME; /* Whether to continue loading on a version check failure */ int no_vcheck; /* If non-NULL, stipulates the \u0026#39;id\u0026#39; of the ENGINE to be loaded */ char *engine_id; /* * If non-zero, a successfully loaded ENGINE should be added to the * internal ENGINE list. If 2, the add must succeed or the entire load * should fail. */ int list_add_value; /* The symbol name for the version checking function */ const char *DYNAMIC_F1; /* The symbol name for the \u0026#34;initialise ENGINE structure\u0026#34; function */ const char *DYNAMIC_F2; /* * Whether to never use \u0026#39;dirs\u0026#39;, use \u0026#39;dirs\u0026#39; as a fallback, or only use * \u0026#39;dirs\u0026#39; for loading. Default is to use \u0026#39;dirs\u0026#39; as a fallback. */ int dir_load; /* A stack of directories from which ENGINEs could be loaded */ STACK_OF(OPENSSL_STRING) *dirs; }; static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { /* è¿™ä¸ªå‡½æ•°å°†ä¼šåˆå§‹åŒ–å¹¶ä¿å­˜åŠ¨æ€åº“æ•°æ®çš„ctxï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå¯ä»¥åå¤è°ƒç”¨è¿™ä¸ªæ¥å£çš„åŸå›  */ dynamic_data_ctx *ctx = dynamic_get_data_ctx(e); int initialised; if (!ctx) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED); return 0; } /* å¯ä»¥çœ‹åˆ°ï¼ŒåŠ è½½å®Œæˆçš„æ ‡å¿—æ˜¯dynamic_dsoé’©å­å·²ç»æŒ‚ä¸Šäº† */ initialised = ((ctx-\u0026gt;dynamic_dso == NULL) ? 0 : 1); /* All our control commands require the ENGINE to be uninitialised */ if (initialised) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED); return 0; } /* cmdè§£æï¼Œåº•ä¸‹é€ä¸ªåˆ†æ */ ... } /* * This function retrieves the context structure from an ENGINE\u0026#39;s \u0026#34;ex_data\u0026#34;, * or if it doesn\u0026#39;t exist yet, sets it up. */ static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e) { dynamic_data_ctx *ctx; if (dynamic_ex_data_idx \u0026lt; 0) { /* * Create and register the ENGINE ex_data, and associate our \u0026#34;free\u0026#34; * function with it to ensure any allocated contexts get freed when * an ENGINE goes underground. */ int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, dynamic_data_ctx_free_func); if (new_idx == -1) { ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX); return NULL; } CRYPTO_THREAD_write_lock(global_engine_lock); /* Avoid a race by checking again inside this lock */ if (dynamic_ex_data_idx \u0026lt; 0) { /* Good, someone didn\u0026#39;t beat us to it */ dynamic_ex_data_idx = new_idx; new_idx = -1; } CRYPTO_THREAD_unlock(global_engine_lock); /* * In theory we could \u0026#34;give back\u0026#34; the index here if (new_idx\u0026gt;-1), but * it\u0026#39;s not possible and wouldn\u0026#39;t gain us much if it were. */ } ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx); /* Check if the context needs to be created */ if ((ctx == NULL) \u0026amp;\u0026amp; !dynamic_set_data_ctx(e, \u0026amp;ctx)) /* \u0026#34;set_data\u0026#34; will set errors if necessary */ return NULL; return ctx; } /* * ç®€å•çš„è¯´å°±æ˜¯å»æŸ¥æŒ‚åœ¨engine-\u0026gt;ex_dataï¼Œ * è¿™ä¸ªå°±æ˜¯åŠ¨æ€åº“åŠ è½½çš„ä¸Šä¸‹æ–‡ï¼Œex_dataæ˜¯ä¸ªæ ˆå¯èƒ½æœ‰å¤šä¸ªä¸Šä¸‹æ–‡ï¼Œ * æ ¹æ®ä¸€ä¸ªå…¨å±€å˜é‡dynamic_ex_data_idxç¡®å®šå½“å‰ä½¿ç”¨ä¸Šä¸‹æ–‡ * å½“ç„¶ç¬¬ä¸€æ¬¡è°ƒç”¨ctxæ˜¯ç©ºçš„ï¼Œæ‰€ä»¥éœ€è¦è°ƒç”¨ä¸€ä¸‹dynamic_set_data_ctxåˆå§‹åŒ– */ static int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx) { /* ç”³è¯·ctxçš„mem */ dynamic_data_ctx *c = OPENSSL_zalloc(sizeof(*c)); int ret = 1; if (c == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); return 0; } c-\u0026gt;dirs = sk_OPENSSL_STRING_new_null(); if (c-\u0026gt;dirs == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); OPENSSL_free(c); return 0; } /* åˆå§‹åŒ–ä¸€äº›å­—æ®µï¼Œä¸‹é¢æ€»ç»“ */ c-\u0026gt;DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, ; c-\u0026gt;DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;; c-\u0026gt;dir_load = 1; CRYPTO_THREAD_write_lock(global_engine_lock); /* ç¬¬ä¸€æ¬¡è¿›æ¥ä¸ºNULL(ç„¶è€Œæ­£å¸¸æ˜¯ä¸ºctx = NULLæ‰ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œå¯èƒ½æ˜¯å†—ä½™æ ¡éªŒ)*/ if ((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx)) == NULL) { /* Good, we\u0026#39;re the first */ /* æŠŠctxæŒ‚åœ¨engine-\u0026gt;ex_dataä¸Š */ ret = ENGINE_set_ex_data(e, dynamic_ex_data_idx, c); if (ret) { *ctx = c; c = NULL; } } CRYPTO_THREAD_unlock(global_engine_lock); /* * If we lost the race to set the context, c is non-NULL and *ctx is the * context of the thread that won. */ if (c) sk_OPENSSL_STRING_free(c-\u0026gt;dirs); OPENSSL_free(c); return ret; } /* * å¾—åˆ°æœ€åçš„ç»“æœ dynamic-\u0026gt;ex_data = ctx; * ctx = {.DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, .DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;, c-\u0026gt;dir_load = 1} * æƒŠå¥‡çš„å‘ç°äº† bind_engine è™½ç„¶ä»–åªæ˜¯ä¸ªå­—ç¬¦ä¸²ï¼Œä½†æ˜¯æˆ‘ç›¸ä¿¡ä½ å·²ç»çŸ¥é“åŸå› äº† * ä»–éœ€è¦åœ¨åŠ¨æ€åº“ä¸­å»å¯»æ‰¾è¿™ä¸ªç¬¦å· */ ä¹‹åæˆ‘ä»¬é€ä¸€åˆ†æè¿™ä¸‰ä¸ªcmd\nDYNAMIC_CMD_SO_PATHå’ŒDYNAMIC_CMD_LIST_ADD static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { /* æ³¨æ„ï¼Œ på°±æ˜¯ctrlvalueï¼Œå³ä»confä¸­å–ä¸‹æ¥çš„å€¼ */ case DYNAMIC_CMD_SO_PATH: /* a NULL \u0026#39;p\u0026#39; or a string of zero-length is the same thing */ if (p \u0026amp;\u0026amp; (strlen((const char *)p) \u0026lt; 1)) p = NULL; OPENSSL_free(ctx-\u0026gt;DYNAMIC_LIBNAME); if (p) /* å¾ˆæ˜æ˜¾åªæ˜¯åšäº†ä¸ªç®€å•çš„å¤åˆ¶ï¼Œæ­¤æ—¶è·¯å¾„å·²ç»èµ‹å€¼ä¸Šäº† */ ctx-\u0026gt;DYNAMIC_LIBNAME = OPENSSL_strdup(p); else ctx-\u0026gt;DYNAMIC_LIBNAME = NULL; return (ctx-\u0026gt;DYNAMIC_LIBNAME ? 1 : 0); case DYNAMIC_CMD_LIST_ADD: if ((i \u0026lt; 0) || (i \u0026gt; 2)) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT); return 0; } /* å¾ˆç®€å•ï¼Œèµ‹å€¼è€Œå·² */ ctx-\u0026gt;list_add_value = (int)i; return 1; ...\t} } è¿™ä¸¤ä¸ªéƒ½å¾ˆç®€å•ï¼Œæœ€åéš¾ç‚¹éƒ½ç»™äº†LOAD\nDYNAMIC_CMD_LOAD æœ€å…³é”®çš„å‡½æ•°ï¼Œå®Œæˆäº†å…¨éƒ¨çš„åŠ è½½ï¼Œè§£é‡Šéƒ½åœ¨æ³¨é‡Šé‡Œï¼š\nstatic int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { case DYNAMIC_CMD_LOAD: return dynamic_load(e, ctx);\t...\t} } static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx) { ENGINE cpy; dynamic_fns fns; /* * å…ˆnewä¸€ä¸ªDSOç»“æ„ä½“ï¼ŒDSOè¿™ä¸€å¥—å‡½æ•°æ€ä¹ˆç©çš„è¿™é‡Œå…ˆä¸è®²äº†ï¼Œ * å¯ä»¥ç†è§£ä¸ºå†…éƒ¨ä¹Ÿæœ‰ä¸€ä¸ªåŠ è½½é’©å­ï¼Œæœ‰4ä¸ªæŒ‚è½½ç‚¹ï¼Œä¼°è®¡å†å±•å¼€è®²è¯»è€…ç–¯äº† */ if (ctx-\u0026gt;dynamic_dso == NULL) ctx-\u0026gt;dynamic_dso = DSO_new(); if (ctx-\u0026gt;dynamic_dso == NULL) return 0; /* æ­¤å¤„æ£€æŸ¥DYNAMIC_LIBNAMEä¸èƒ½ä¸ºç©ºï¼Œè¿™ä¸ªå°±æ˜¯dsoçš„åŠ è½½åœ°å€ */ if (!ctx-\u0026gt;DYNAMIC_LIBNAME) { if (!ctx-\u0026gt;engine_id) return 0; DSO_ctrl(ctx-\u0026gt;dynamic_dso, DSO_CTRL_SET_FLAGS, DSO_FLAG_NAME_TRANSLATION_EXT_ONLY, NULL); ctx-\u0026gt;DYNAMIC_LIBNAME = DSO_convert_filename(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;engine_id); } /* æ ¸å¿ƒåŠ è½½å‡½æ•°int_loadï¼Œçœ‹ä¸‹é¢åˆ†æ */ if (!int_load(ctx)) { ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_NOT_FOUND); DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; return 0; } /* We have to find a bind function otherwise it\u0026#39;ll always end badly */ /* * æ­¤æ—¶engineåŠ¨æ€åº“å·²ç»åŠ è½½å¦‚å†…å­˜ï¼Œç¬¦å·è¡¨ä¸å¯¹åº”åœ°å€ä¹Ÿå‡†å¤‡å®Œæˆ * æ‰€ä»¥è‚¯å®šæ˜¯éœ€è¦å»å¯»æ‰¾è¿™ä¸ªç»‘å®šengineå®ŒæˆåŠ è½½çš„å‡½æ•°äº†ï¼Œèƒœåˆ©çš„æ›™å…‰ * DSO_bind_funcä¼šåœ¨ç¬¦å·è¡¨ä¸­å»åŒ¹é…ç¬¬äºŒä¸ªå‚æ•°å­—ç¬¦ä¸²ï¼Œè¿™é‡Œå°±æ˜¯æˆ‘ä»¬è¦çš„\u0026#34;bind_engine\u0026#34; * å¹¶è¿”å›ä¸Šå®ƒçš„å‡½æ•°åœ°å€ï¼ŒæŒ‚è½½åœ¨ctx-\u0026gt;bind_engineä¸Š */ if (! (ctx-\u0026gt;bind_engine = (dynamic_bind_engine) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F2))) { ctx-\u0026gt;bind_engine = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE); return 0; } /* Do we perform version checking? */ if (!ctx-\u0026gt;no_vcheck) { unsigned long vcheck_res = 0; /* * Now we try to find a version checking function and decide how to * cope with failure if/when it fails. */ ctx-\u0026gt;v_check = (dynamic_v_check_fn) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F1); if (ctx-\u0026gt;v_check) vcheck_res = ctx-\u0026gt;v_check(OSSL_DYNAMIC_VERSION); /* * We fail if the version checker veto\u0026#39;d the load *or* if it is * deferring to us (by returning its version) and we think it is too * old. */ if (vcheck_res \u0026lt; OSSL_DYNAMIC_OLDEST) { /* Fail */ ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_VERSION_INCOMPATIBILITY); return 0; } } /* * First binary copy the ENGINE structure so that we can roll back if the * hand-over fails */ memcpy(\u0026amp;cpy, e, sizeof(ENGINE)); /* * Provide the ERR, \u0026#34;ex_data\u0026#34;, memory, and locking callbacks so the * loaded library uses our state rather than its own. FIXME: As noted in * engine.h, much of this would be simplified if each area of code * provided its own \u0026#34;summary\u0026#34; structure of all related callbacks. It * would also increase opaqueness. */ fns.static_state = ENGINE_get_static_state(); CRYPTO_get_mem_functions(\u0026amp;fns.mem_fns.malloc_fn, \u0026amp;fns.mem_fns.realloc_fn, \u0026amp;fns.mem_fns.free_fn); /* * Now that we\u0026#39;ve loaded the dynamic engine, make sure no \u0026#34;dynamic\u0026#34; * ENGINE elements will show through. */ engine_set_all_null(e); /* Try to bind the ENGINE onto our own ENGINE structure */ /* !!!!Attension, ç»ˆäºè°ƒç”¨æˆåŠŸäº†ï¼Œæˆ‘ä»¬çš„engineXç»ˆäºè¢«è®¾ç½®å¥½äº†ï¼ */ if (!ctx-\u0026gt;bind_engine(e, ctx-\u0026gt;engine_id, \u0026amp;fns)) { ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED); /* Copy the original ENGINE structure back */ memcpy(e, \u0026amp;cpy, sizeof(ENGINE)); return 0; } /* Do we try to add this ENGINE to the internal list too? */ /* æŠŠè¿™ä¸ªengineçš„å‰¯æœ¬addè¿›ä¸Šé¢engineå…¨å±€é“¾è¡¨ï¼Œå¤§åŠŸå‘Šæˆï¼*/ if (ctx-\u0026gt;list_add_value \u0026gt; 0) { if (!ENGINE_add(e)) { /* Do we tolerate this or fail? */ if (ctx-\u0026gt;list_add_value \u0026gt; 1) { /* * Fail - NB: By this time, it\u0026#39;s too late to rollback, and * trying to do so allows the bind_engine() code to have * created leaks. We just have to fail where we are, after * the ENGINE has changed. */ ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } /* Tolerate */ ERR_clear_error(); } } return 1; } static int int_load(dynamic_data_ctx *ctx) { int num, loop; /* Unless told not to, try a direct load */ /* * DSO_loadå»æ‰“å¼€ctx-\u0026gt;DYNAMIC_LIBNAMEï¼ŒæŠŠegineå¯¹åº”çš„libåº“åŠ è½½è¿›å†…å­˜ * è§£æç¬¦å·è¡¨å’Œå¯¹åº”åœ°å€åˆ°ä¸Šé¢ç”³è¯·å¥½çš„ctx-\u0026gt;dynamic_dsoç»“æ„ä½“ä¸­ */ if ((ctx-\u0026gt;dir_load != 2) \u0026amp;\u0026amp; (DSO_load(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, NULL, 0)) != NULL) return 1; /* If we\u0026#39;re not allowed to use \u0026#39;dirs\u0026#39; or we have none, fail */ if (!ctx-\u0026gt;dir_load || (num = sk_OPENSSL_STRING_num(ctx-\u0026gt;dirs)) \u0026lt; 1) return 0; for (loop = 0; loop \u0026lt; num; loop++) { /* è¿˜æœ‰é“¾æ¥çš„dsoè¿™é‡Œä¼šå¤„ç†é€’å½’çš„å»åŠ è½½ï¼Œå¯¹åº”çš„éœ€è¦åœ¨ctx-\u0026gt;dirsä¸­ */ const char *s = sk_OPENSSL_STRING_value(ctx-\u0026gt;dirs, loop); char *merge = DSO_merge(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, s); if (!merge) return 0; if (DSO_load(ctx-\u0026gt;dynamic_dso, merge, NULL, 0)) { /* Found what we\u0026#39;re looking for */ OPENSSL_free(merge); return 1; } OPENSSL_free(merge); } return 0; } ç»ˆäºç»ˆäºç»ˆäºï¼Œæ‰¾åˆ°ç›®æ ‡äº†ï¼Œè¿™ä¸ªå«åš'dynamic'çš„engineå‰¯æœ¬å®Œæˆäº†å˜æˆengineXçš„èœ•å˜ã€‚\nåç»­ éš¾æ€ªè¿™ä¹ˆå¤šäººå–·OpenSSLçƒ‚ï¼Œè¿™å¤æ‚çš„æµç¨‹ï¼Œè¿™ä¸€ä¸ªåˆä¸€ä¸ªçš„é’©å­ã€‚ä¸è¿‡è¿™ä¸€ä¸²æºç è¯»ä¸‹æ¥çœ‹æ˜ç™½çš„æ—¶å€™è¿˜æ˜¯æœ‰ç¥æ¸…æ°”çˆ½çš„æ„Ÿè§‰ã€‚\næœ‰ç¼˜åé¢ä¼šåˆ†æå¯†ç ç®—æ³•å…·ä½“æŒ‚è½½ï¼Œå¦‚ENGINE_set_digestsã€‚\næˆ‘å¾ˆèœï¼Œæœ‰é”™è¯¯çš„åœ°æ–¹æ¬¢è¿æŒ‡æ­£\n","description":"OpenSSL Engineæ’ä»¶çš„åŠ è½½è¿‡ç¨‹æºç åˆ†æ","id":4,"section":"posts","tags":["OpenSSL"],"title":"OpenSSL EngineåŠ è½½","uri":"https://summersummer3.github.io/posts/openssl_engine/"},{"content":"æ¤­åœ†æ›²çº¿åŸºæœ¬å­¦ä¹  æ–‡ç« ï¼šhttps://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#elliptic-curves\nä¹¦ç±ï¼šå¯†ç å­¦åŸç†ä¸å®è·µ ç¬¬6ç« \næ¤­åœ†æ›²çº¿æ–¹ç¨‹ $$\n\\left\\lbrace (x, y) \\in \\mathbb{R}^2\\ |\\ y^2 = x^3 + ax + b,\\ 4 a^3 + 27 b^2 \\ne 0 \\right\\rbrace\\ \\cup\\ \\left\\lbrace 0 \\right\\rbrace\n$$\nç¾¤ä¸é˜¿è´å°”ç¾¤ â€‹\t$\\mathbb{G}$ æ˜¯ä¸€ä¸ª ç¾¤ (Group) å¦‚æœè¯¥é›†åˆä¸Šå®šä¹‰äº†ä¸€ç§è¿ç®— $ + $:\n å°é—­æ€§: $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ ,åˆ™ $a + b \\in \\mathbb{G}$ ; ç»“åˆå¾‹: $a \\in \\mathbb{G}, b \\in \\mathbb{G}, c \\in \\mathbb{G}$, $ (a + b) + c = a + (b +c)$ ; å­˜åœ¨å•ä½å…ƒ $0 \\in \\mathbb{G}$, ä½¿å¾— $a \\in \\mathbb{G}$ï¼Œ$a + 0 = 0 + a = a$; æ¯ä¸€ä¸ªå…ƒç´ å­˜åœ¨é€†å…ƒï¼šå¯¹äºé›†åˆå†…ä»»æ„å…ƒç´ $a, \\exists b \\in \\mathbb{G}$ æ»¡è¶³ $a + b = 0$ï¼Œè®°åš$a = -b$  å¦‚æœè¯¥ç¾¤è¿˜æ»¡è¶³:\näº¤æ¢å¾‹ï¼š $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ï¼Œ $a + b = b + a$  åˆ™è¯¥ç¾¤è¢«ç§°ä¸ºé˜¿è´å°”ç¾¤.\næœ‰é™åŸŸ $\\mathbb{F}$ æ˜¯ä¸€ä¸ª åŸŸ(Field) å¦‚æœè¯¥é›†åˆä¸Šå®šä¹‰äº†ä¸¤ç§è¿ç®— $(\\cdot\\ ;+)$\n å°é—­æ€§: $a \\in \\mathbb{F}, b \\in \\mathbb{F}$ï¼Œåˆ™ $a + b \\in \\mathbb{G}; a \\cdot b \\in \\mathbb{G}$ ç»“åˆå¾‹: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$ï¼Œ$ (a + b) + c = a + (b +c);\\ (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ å­˜åœ¨åŠ æ³•å•ä½å…ƒ $0 \\in \\mathbb{F}$ï¼Œä½¿å¾— $a \\in \\mathbb{F}$ï¼Œ$a + 0 = 0 + a = a$ å­˜åœ¨ä¹˜æ³•å•ä½å…ƒ $e \\in \\mathbb{F}$ï¼Œä½¿å¾— $a \\in \\mathbb{F}$ï¼Œ$a \\cdot e = e \\cdot a = a$ äº¤æ¢å¾‹ï¼š $a \\in \\mathbb{F}, b \\in \\mathbb{F}$ï¼Œ $a + b = b + a$ï¼Œ$a \\cdot b = b \\cdot a$ é€†å…ƒ: å¯¹äºé›†åˆå†…ä»»æ„å…ƒç´ $a, \\exists b \\in \\mathbb{F}; \\exists c \\in \\mathbb{F}$ æ»¡è¶³ $a + b = 0; a \\cdot c = e$ï¼Œ è®°åš$a = -b;\\ a = c^{-1}$ï¼Œ$0^{-1}$æ— æ„ä¹‰ åˆ†é…å¾‹: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$ï¼›$a \\cdot (b + c) = a \\cdot b + a \\cdot c$  æ³¨æ„ï¼šåŠ æ³•é€†å…ƒå®šä¹‰å‡æ³•ï¼Œä¹˜æ³•é€†å…ƒå®šä¹‰é™¤æ³•\næœ‰é™åŸŸæŒ‡çš„æ˜¯å…ƒç´ æœ‰é™çš„åŸŸï¼Œå±äºè®¡ç®—æœºå’Œå¯†ç å­¦çš„åŸºæœ¬æ•°å­¦åŸç†ä¹‹ä¸€\nå…¸å‹çš„æœ‰é™åŸŸä¾‹å­ï¼š$\\mathbb{F}_p = {0, 1, \u0026hellip;, p-1}$, $p$ä¸ºè´¨æ•°ï¼Œ\nå®šä¹‰ (+)ï¼š$a + b \\mod p$\nå®šä¹‰ ($\\cdot$)ï¼š$a \\cdot b \\mod p$\nè®¡ç®— $a ^ {-1}$ : æ‹“å±•æ¬§å‡ é‡Œå¾—ç®—æ³•\næ¤­åœ†æ›²çº¿ä¸Šçš„ç¾¤  æ›²çº¿ä¸Šçš„ç‚¹çš„é›†åˆç»„æˆç¾¤ $x$æ— ç©·è¿œç‚¹ä¸ºå•ä½å…ƒ$0$ ç‚¹$P$ä¸å®ƒçš„é€†$Q$å…³äºç›´çº¿$x = 0$å¯¹ç§° åŠ æ³•å®šä¹‰ï¼š$P + Q + R = 0$ï¼Œå¦‚æœè¿™ä¸‰ç‚¹æ˜¯é0ç‚¹ï¼Œä¸”åœ¨åŒä¸€æ¡ç›´çº¿ä¸Š(å³ä¸€æ¡ç›´çº¿ä¸è¯¥æ›²çº¿ç›¸äº¤äºä¸‰ç‚¹ï¼Œæ— ç©·è¿œç‚¹ä¸º0) $=\u0026gt; P + Q = -R$  åŠ æ³•åŒæ ·éœ€è¦æ»¡è¶³ç»“åˆå¾‹.\nå‡ ä½•æ„ä¹‰ä¸Šçš„åŠ æ³• æœ€é‡è¦çš„æƒ…å†µ:\n å¦‚æœ $P=Q, P + Q$ï¼Œç‰©ç†æ„ä¹‰æ˜¯åˆ‡çº¿, ä¸æ›²çº¿äº¤äºå¦ä¸€ç‚¹$R$, æ»¡è¶³ï¼š$2P = -R$ å¦‚æœ$P, Q$ç›´çº¿çš„ç¬¬ä¸‰ç‚¹åˆšå¥½ä¸º$P\\ or\\ Q$ï¼Œåˆ™ä¹Ÿå°†åŒ…å«ä¸€æ¡åˆ‡çº¿ï¼Œè®¡ç®—ç›¸åŒ: $P + Q + P = 0\\ =\u0026gt; P + Q = -P$  ä»£æ•°æ„ä¹‰ä¸Šçš„åŠ æ³• ä¸åŒä¸¤ç‚¹ç›¸åŠ  $P(P_x, P_y), Q(Q_x, Q_y)ï¼ŒP\\ \\ne Q$, æ±‚ $T(T_x, T_y) = P + Q$\næ›²çº¿æ–¹ç¨‹ï¼š$y^2 = x^3 +ax + b$\n  è®¡ç®—æ–œç‡ $k = \\frac{P_y - Q_y}{P_x - Q_x}$\n  æ›²çº¿æ–¹ç¨‹è¿ç«‹ä¸Šç›´çº¿æ–¹ç¨‹ $y = kx + c$\n=\u0026gt; $ 0 = x^3 - k^2x^2 + (a - 2kc)x + b - c^2$\n  é“­è®°ä¸‰æ¬¡æ±‚æ ¹å…¬å¼ä¹‹ä¸‰æ ¹ä¹‹å’Œæ˜¯äºŒæ¬¡é¡¹ç³»æ•°çš„ç›¸åæ•°: $T_x = k^2 - P_x - Q_x$\n  ç”±äºæ–œç‡ $k = \\frac{T_y - P_y}{T_x - P_x}$ï¼Œ$T_y = k(T_x - P_x) + P_y$\n  ç›¸åŒä¸¤ç‚¹ç›¸åŠ  $P(P_x, P_y)$ï¼Œæ±‚ $T(T_x,T_y) = P + P = 2P$\nå’Œä¸Šé¢åŸºæœ¬ç›¸åŒï¼Œä½†è®¡ç®—ç›´çº¿æ–œç‡éœ€è¦æ ¹æ®åˆ‡çº¿è®¡ç®—\nå¯¹æ›²çº¿æ–¹ç¨‹ä¸¤è¾¹æ±‚éšå¾®åˆ†:\n$\\mathrm{d}(y^2) = \\mathrm{d}(x^3 +ax + b)$ =\u0026gt; $2y\\mathrm{d}y = (3x^2 + a)\\mathrm{d}x$\nå°†$P_x, P_y$å¸¦å…¥ï¼Œè·å¾—æ–œç‡:\n$k = \\frac{\\mathrm{d}y}{\\mathrm{d}x} = \\frac{3P_x^2 + a}{2P_y}$\næ‰€ä»¥ $T_x = k^2 - 2P_x$ï¼Œ$T_y = k(T_x - P_x) + P_y$\næ ‡é‡ç§¯ $P(P_x, P_y)$ï¼Œæ±‚ $nP = \\underbrace{P + P + P + \u0026hellip; + P}_{\\text{n times}}$ï¼Œ$n \u0026gt; 2$\n  å°† $n$ ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºï¼›ä»¥151ä¸ºä¾‹å­ï¼Œ$151_{10} = 10010111_2 = 2^0 + 2^1 + 2^2 + 2^4 + 2^7$\n  $nP = P + 2P + 2^2P + 2^4P + 2^7P$\n  æ ¹æ®ä¸Šé¢ä¸¤é¡¹è®¡ç®—è§„åˆ™ï¼Œåˆ†åˆ«è®¡ç®—$P, 2Pï¼ŒP + 2P$\n  è®¡ç®—$2^2P = 4P = 2 \\cdot 2P$ï¼Œå¯¹$2P$åšç›¸åŒç‚¹ç›¸åŠ å³å¯\n  åŒç†è®¡ç®—$2^3P = 8P = 2 \\cdot 4P$ï¼Œ$2^4P = 16P = 2 \\cdot 8P$, ä¾æ¬¡ç±»æ¨ï¼Œæ¯è®¡ç®—åˆ°ä¸€ä¸ªäºŒè¿›åˆ¶ä¸­ä¸º$1$çš„é˜¶æ•°ï¼Œ å®Œæˆä¸€æ¬¡ä¸¤ç‚¹ç›¸åŠ å³å¯\n  æ›²çº¿ä¸Šçš„æœ‰é™åŸŸ å–å‡ ä½•æ›²çº¿ä¸Šçš„åæ ‡$(x, y)$ï¼Œ$x, y \\in \\mathbb{F}_p$, $p$ æ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œå½¢æˆä¸€æ¡ç¦»æ•£æ›²çº¿ï¼š\n$$\n\\begin{array}{rcl}\n\\left\\lbrace(x, y) \\in (\\mathbb{F}_p)^2 \\right. \u0026amp; \\left. | \\right. \u0026amp; \\left. y^2 \\equiv x^3 + ax + b \\pmod{p}, \\right.\n\\left. 4a^3 + 27b^2 \\not\\equiv 0 \\pmod{p}\\right\\rbrace\\ \\cup\\ \\left\\lbrace0\\right\\rbrace\n\\end{array}\n$$\nä»è¿ç»­æ›²çº¿ä¸Šçš„åŠ æ³•å¯ä»¥æ¨å‡ºæœ‰é™åŸŸä¸Šçš„åŠ æ³•å…¬å¼ï¼š\n$P(P_x, P_y), Q(Q_x, Q_y)ï¼ŒP\\ \\ne Q$, æ±‚ $T(T_x, T_y) = P + Q$\n$$\n\\begin{array}{rcl}\nk \u0026amp; = \u0026amp;(P_y - Q_y)(P_x - Q_x)^{-1} \\bmod{p} \\\nT_x \u0026amp; = \u0026amp; (k^2 - P_x - Q_x) \\bmod{p} \\\nT_y \u0026amp; = \u0026amp; [P_y + k(T_x - P_x)] \\bmod{p} \\\n\\end{array}\n$$\nè‹¥$P\\ = Q$\n$$\nk = (3 P_x^2 + a)(2 P_y)^{-1} \\bmod{p}\n$$\næ›²çº¿ä¸Šçš„å¾ªç¯å­ç¾¤ å¾ªç¯å­ç¾¤çš„é˜¶ å¯¹äºç¦»æ•£æ›²çº¿ä¸Šçš„ä»»æ„ç‚¹$P$, å­˜åœ¨æœ€å°çš„ $n$ ä½¿å¾— $nP = 0$, æ­¤æ—¶ $n$ ç§°ä½œä»¥ $P$ ä¸ºåŸºç‚¹çš„å¾ªç¯å­ç¾¤çš„é˜¶\næ‰¾åŸºç‚¹çš„æ–¹æ³•  è®¡ç®—æ¤­åœ†æ›²çº¿çš„é˜¶$N$ (Schoof\u0026rsquo;s algorithm: https://en.wikipedia.org/wiki/Schoof%27s_algorithm) é€‰æ‹©ä¸€ä¸ªé˜¶ä¸º$n$çš„å­ç¾¤ã€‚nå¿…é¡»æ˜¯ç´ æ•°ä¸”å¿…é¡»æ˜¯$N$çš„å› å­ è®¡ç®—è¾…å› å­ $h = N/n$ åœ¨æ›²çº¿ä¸Šé€‰æ‹©ä¸€ä¸ªéšæœºçš„ç‚¹ $T$ è®¡ç®—$G = hT$ï¼Œç‚¹ä¹˜ å¦‚æœ$G = 0$, è¿”å›4ï¼Œ å¦åˆ™æ‰¾åˆ°åŸºç‚¹ $G$, å­ç¾¤çš„é˜¶ä¸º $n$, $h$ è¢«ç§°ä¸ºè¾…å› å­  åŸç†: æ ¹æ®æ‹‰æ ¼æœ—æ—¥å®šç†ï¼Œ$n$ æ•´é™¤ $N$ ä¸” $n$ ä¸ºè´¨å› å­ï¼Œä¸”ä»»æ„ç‚¹ $T$ æ»¡è¶³$NT = 0$ï¼Œ åˆ™ï¼š$n(hT) = 0$ æ’æˆç«‹, é‚£ä¹ˆè‹¥$hT\\ \\ne 0$ï¼Œåˆ™ $hT$ ä½œä¸ºåŸºç‚¹çš„é˜¶ä¸€å®šä¸º$n$. ($n$ ä¸€å®šæ˜¯ç´ æ•°, å¦åˆ™ä¸æˆç«‹)\næ›²çº¿ä¸Šçš„ç¦»æ•£å¯¹æ•°é—®é¢˜ å¯¹äºæ›²çº¿ä¸Šçš„åŸºç‚¹ $G$ï¼Œ å·²çŸ¥ $n$ è®¡ç®— $P = nG$ æ˜¯å®¹æ˜“çš„\nä½†æ˜¯å·²çŸ¥$P, G$, è®¡ç®— $n$ æ˜¯å¾ˆå›°éš¾çš„\nECDH \u0026amp; ECDSA ECDH  CAé€‰ç”¨å…±åŒæ›²çº¿ï¼Œå¹¶ä¸‹å‘ç›¸åŒåŸºç‚¹$G$ï¼Œå…¶é˜¶æ•°ä¸º $n$, åˆ™ç§é’¥çš„å–å€¼èŒƒå›´ä¸º$d \\in {1, \u0026hellip;, n - 1}$ Aliceéšæœºé€‰æ‹©ç§é’¥$d_A$ï¼Œè®¡ç®— Pubkey: $P_A = d_AG$, é€šè¿‡éå®‰å…¨ä¿¡é“ä¼ é€’ç»™Bob Bobéšæœºé€‰æ‹©ç§é’¥$d_B$ï¼Œè®¡ç®— Pubkey: $P_B = d_BG$ï¼Œé€šè¿‡éå®‰å…¨ä¿¡é“ä¼ é€’ç»™Alice Aliceå’ŒBobåˆ†åˆ«è®¡ç®—$S = d_AP_b = d_BP_A = d_Ad_BG$ï¼Œ å…±äº«ç§˜å¯†æˆåŠŸ  ç§˜å¯†å…±äº«æˆåŠŸåå¯ä»¥æ¯æ¬¡é€šä¿¡æ—¶æ˜æ–‡ä¼ é€’salt, æ¯æ¬¡é€šè¿‡ $key = KDF(salt + S)$ï¼Œå¾—åˆ°å…·ä½“é€šä¿¡å¯¹ç§°ç§˜é’¥ï¼ŒåŠ å¯†é€šè®¯(TLS/SSL)\né€šè¿‡æœåŠ¡å™¨åŠ¨æ€ç”Ÿæˆçš„ECDHä¸€èˆ¬ç§°ä½œECDHE\nECDSA å®šä¹‰ä¾ç„¶ç»§æ‰¿ä¸Šæ–‡ï¼Œ$n$ ä¸º $G$ ä½œä¸ºåŸºç‚¹çš„å­ç¾¤é˜¶æ•°\nå®šä¹‰ $bit(x)$ ä¸ºè¡¨ç¤º $x$ éœ€è¦çš„æ¯”ç‰¹æ•°ï¼›æ³¨æ„è®¡ç®—DSAæ—¶ï¼Œè‹¥æ‘˜è¦å€¼çš„æ¯”ç‰¹æ•° $bits(digest(plain_test)) \u0026gt; bits(n)$ï¼Œåˆ™éœ€è¦æˆªå–æ‘˜è¦å€¼çš„ä½ $bits(n)$ è¿›è¡Œç­¾å.\nç¬¦å·æ ‡è®° æˆªå–å‰n-bitså‡½æ•° ï¼š $trun_{bit(n)}(digest)$\næˆªå–åçš„æ‘˜è¦å€¼ï¼š$z = trun_{bit(n)}(digest(plain_test))$ï¼Œ$digest$ éœ€è¦é€‰æ‹©å®‰å…¨æ‘˜è¦ç®—æ³•ï¼šå†…éƒ¨è¦æ±‚SHA-256ä»¥ä¸Š\nç§é’¥ï¼š$d$\nå…¬é’¥ï¼š$P = dG$\nç­¾åç®—æ³•   éšæœºé€‰æ‹© $k \\in {1, \u0026hellip;, n -1 }$\n  è®¡ç®—$T = kG = (T_x, T_y)$\n  è®¡ç®—æ•°å­— $r = T_x \\mod n$ï¼Œ è‹¥$r = 0$åˆ™è¿”å›1\n  è®¡ç®—$s = k^{-1}(z + rd) \\mod n$, å¦‚æœ$s = 0$ï¼Œè¿”å›1\n  æœ€åç­¾åï¼š$(r, s)$\n  éªŒè¯ç®—æ³•  è®¡ç®— $u_1 = s^{-1}z \\mod n$ è®¡ç®— $u_2 = s^{-1}r \\mod n$ è®¡ç®— $T\u0026rsquo; = u_1G\\ +\\ u_2P$  è‹¥$T\u0026rsquo;_x = r \\mod n$ï¼ŒéªŒç­¾æˆåŠŸï¼Œå¦åˆ™å¤±è´¥\næ­£ç¡®æ€§ æˆ‘ä»¬å°è¯•è®¡ç®—çš„å…¶å®è¿˜æ˜¯$T = kG$ï¼Œè‹¥æ­¤æ—¶ $z$ æ˜¯æ­£ç¡®æ‘˜è¦å€¼ï¼Œåˆ™æœ‰:\n$k = s^{-1}(z + rd)\\ mod\\ n\\ =\u0026gt;\\ k = s^{-1}z + s^{-1}rd \\mod n$\nå¸¦å…¥ä¸Šå¼ $T = s^{-1}zG + s^{-1}rdG = u_1G + u_2(dG) = u1G + u_2P$\næ‰€ä»¥è‹¥ $z$ å‘ç”Ÿæ”¹å˜ï¼Œåˆ™æ­¤æ—¶è®¡ç®—å‡ºæ¥çš„ $T\u0026rsquo;_x\\ \\ne\\ r \\mod n$\néšæœºæ•°ç›¸ç­‰ä¸‹çš„ç§é’¥å¤åŸ è‹¥æ¯æ¬¡å–å‡ºçš„éšæœºæ•° $k$ éƒ½ç›¸ç­‰ï¼š\nè·å–ä¸¤ä»½ç­¾åä¸æ‘˜è¦ï¼š$z_1, (r_1, s_1)$ å’Œ $z_2, (r_2, s_2)$\nå®¹æ˜“å¾—åˆ°: $r_1 = r_2 = (kG)_x \\mod n$\nä¹‹åé€šè¿‡ $s_1 - s_2$ è®¡ç®— $k$ï¼š\n$s_1 - s_2 = k^{-1}(z_1 + rd - z_2 - rd) \\mod n$\n$=\u0026gt; k = (z_1 - z_2)(s_1 - s_2)^{-1} \\mod n$\nä¹‹åè®¡ç®— $d$ å°±å¾ˆç®€å•äº†:\n$ d = r^{-1}(s_1k - z_1) \\mod n$\né€šè¿‡ç­¾åæ¢å¤å…¬é’¥ è‹¥å·²çŸ¥æ›²çº¿ä¸Š $x = r$ å¯¹åº”çš„ä¸¤ç‚¹ $R, R\u0026rsquo;$ï¼Œåˆ™å¯ä»¥ä»ç­¾å$(s, r)$ä¸­æ¢å¤å…¬é’¥$P$:\n$s = k^{-1}(z + rd) \\mod n$\n$=\u0026gt; skG = (z + rd)G$\næ³¨æ„ $kG = R$ æˆ–è€… $kG = R\u0026rsquo;$, åˆ†åˆ«ä½œä¸ºå¤‡é€‰å¸¦å…¥ä¸Šå¼ï¼ŒåŒæ—¶$P = dG$:\n$=\u0026gt;\\ sR - zG = r(dG)\\ =\u0026gt; P = r^{-1}(sR - zG)$\nor $=\u0026gt;\\ P = r^{-1}(sR\u0026rsquo; - zG)$\nå®ç°æ–¹æ³• ç‚¹å‹ç¼©ï¼šå¢åŠ 2bitæ¥æ ‡è¯†ï¼Œä¸€ä¸ªç”¨æ¥æ ‡è¯† $R_x = r\\mod n$ æˆ–è€… $R_x = r$ï¼Œå¦ä¸€ä¸ªæ ‡è¯†$R_y$æ˜¯åŸºæ•°è¿˜æ˜¯å¶æ•°ï¼š\nå› ä¸º$R, R\u0026rsquo;$å…³äº $x$ è½´å¯¹ç§°ï¼Œ$R_y + R\u0026rsquo;_y = 0 \\mod p$ï¼Œ æ‰€ä»¥$R_y ,P\u0026rsquo;_y$ä¸ºä¸€åŸºä¸€å¶ï¼Œå¯ç”¨ä¸€ä¸ªbitæ ‡è¯†\nè¿™æ ·å¯ä»¥è¾¾åˆ°å¤šç”¨å¢åŠ ä¸€ä¸ªbyte(04æ ‡è®°ç­‰)ï¼Œæ¥è¾¾æˆæ— éœ€ä¼ é€’å…¬é’¥å³å¯éªŒç­¾\nç›¸å…³ç®—æ³•ä¸ä»£ç ï¼šhttps://busy.org/@oflyhigh/397bw1\nä¼ªé€ ç­¾å æ„é€ eæ–¹æ³•  éšæœºé€‰æ‹© $a, b \\in {1, \u0026hellip; n}$, è®¡ç®—$T = aG + bP, r = T_x$ è®¡ç®— $s = rb^{-1}, e = arb^{-1}$ è‹¥$e$ ä¸ºä¼ªé€ æ‘˜è¦å€¼, å¯ä¼ªé€ åˆæ³•ç­¾å $(r, s)$  æ­£ç¡®æ€§:\n$u_1 = s^{-1}e \\mod \\ n$\n$u_2 = s^{-1}r \\mod\\ n$\nå°†$s, e$å¸¦å…¥\n$u_1G + u_2P = (rb^{-1})^{-1}(arb^{-1})G + (rb^{-1})^{-1}rP = (rr^{-1})(bb^{-1})aG + (rr^{-1})bP = aG + bP = T$\nç”±äº$r = T_x \\mod n$ï¼Œæ ¡éªŒé€šè¿‡\nç›¸å…³ç®—æ³•ä¸ä»£ç ï¼šhttps://github.com/GoldSaintEagle/ECDSA-SM2-Signing-Attack\nSM2ç­¾å æ ‡è®°ä¸å˜ï¼Œ$z = SM3(message)$ æ˜¯æ¶ˆæ¯çš„æ‘˜è¦å€¼ï¼ˆå›½å¯†è¦æ±‚æ‘˜è¦ä½¿ç”¨SM3ï¼‰ï¼Œ$d$ æ˜¯ç§é’¥ï¼Œ $P = dG$æ˜¯å…¬é’¥\nç­¾åç®—æ³•   éšæœºé€‰æ‹© $k \\in {1, \u0026hellip;, n -1 }$\n  è®¡ç®—$T = kG = (T_x, T_y)$\n  è®¡ç®—æ•°å­— $r = T_x + z \\mod n$ï¼Œ è‹¥$r = 0$åˆ™è¿”å›1\n  è®¡ç®—$s = (1 + d)^{-1}(k - rd) \\mod n$, å¦‚æœ$s = 0$ï¼Œè¿”å›1\n  æœ€åç­¾åï¼š$(r, s)$\n  éªŒè¯ç®—æ³•  è®¡ç®—æ¶ˆæ¯å€¼æ‘˜è¦$z\u0026rsquo; = SM3(message)$ è®¡ç®—$T\u0026rsquo; = sG + (r + s)P$ åˆ¤æ–­$r\\ ?= T\u0026rsquo;_x + z \\mod n$  æ­£ç¡®æ€§ é¦–å…ˆè®¡ç®— $k$ :\n$s = (1 + d)^{-1}(k - rd) \\mod n$\n=\u0026gt; $s(1 + d) + rd = k \\mod n$ =\u0026gt; $s + (s + r)d = k \\mod n$\næ‰€ä»¥ ï¼š\n$T = kG = sG + (s + r)(dG) = sG + (s + r)P = T'$\nå› æ­¤å¯ä»¥æ¨å¯¼ï¼š\n$r = (T_x + z) = (T\u0026rsquo;_x + z) \\mod n$\næ‰€ä»¥å¦‚æœ$r = T\u0026rsquo;_x + z\u0026rsquo; \\mod n$ï¼Œ åˆ™ $z\u0026rsquo;$ éªŒç­¾é€šè¿‡ï¼Œå¦åˆ™ $z\u0026rsquo;$ æ‘˜è¦æœ‰è¯¯\n","description":"æ¤­åœ†æ›²çº¿ç®—æ³•å…¥é—¨åŠECDSAä¸SM2ç®—æ³•è¯¦è§£","id":5,"section":"posts","tags":["å¯†ç å­¦"],"title":"ECDSAä¸SM2","uri":"https://summersummer3.github.io/posts/ecdsa%E4%B8%8Esm2/"}]