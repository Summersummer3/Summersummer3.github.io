[{"content":"A useless security engineer/cn:å¸…å\nå·¥ä½œç»å†\nå­—èŠ‚è·³åŠ¨ï¼šç§»åŠ¨å®‰å…¨é£æ§å·¥ç¨‹å¸ˆï¼Œä¸“æ³¨åè‡ªåŠ¨åŒ–\nåä¸º: ç¡¬ä»¶å®‰å…¨ä¸ç§»åŠ¨å®‰å…¨å·¥ç¨‹å¸ˆï¼ŒTEE/HSM/æ¸—é€æµ‹è¯•/å®‰å…¨å¯åŠ¨ éƒ½åšè¿‡ç‚¹\nå­¦ä¹ ç»å†\næ—¥æœ¬ç­‘æ³¢å¤§å­¦ï¼Œç¤¾ä¼šå·¥å­¦ï¼Œç¡•å£«: å·®åˆ†éšç§ç ”ç©¶\nä¸­å—å¤§å­¦ï¼Œè®¡ç®—æœºç§‘å­¦ä¸æŠ€æœ¯ï¼Œæœ¬ç§‘: çç©å„¿\n","description":"","id":2,"section":"","tags":null,"title":"About Techsum","uri":"https://summersummer3.github.io/about/"},{"content":"èƒŒæ™¯ ç”±äºå¾ˆå¤šheadlessæµè§ˆå™¨çš„webglä¿¡æ¯æ¯”è¾ƒæ˜æ˜¾ï¼Œå¦‚æœæºç«™å°è¯•é‡‡é›†webglå‚æ•°ä¼šæš´éœ²è‡ªåŠ¨åŒ–å·¥å…·çš„ç‰¹å¾ï¼Œæ‰€ä»¥é»‘äº§æ”»å‡»ä¸­éœ€è¦å»æ¬ºéª—webglçš„ä¿¡æ¯ä¸ŠæŠ¥ã€‚\nç›®å‰åœ¨githubä¸Šå¯ä»¥æ‰¾åˆ°ä¸€ä¸ªspoof webglçš„é¡¹ç›®ï¼Œstaræ•°å¹¶ä¸å¤šï¼Œä½†å…¶æ€è·¯åº”è¯¥æ˜¯æ¯”è¾ƒä¸»æµçš„hook webglç›¸å…³æ¥å£çš„æ–¹å¼ã€‚æœ¬æ–‡ä¸»è¦å¯¹è¯¥å·¥å…·çš„ä½¿ç”¨å’Œæºç è¿›è¡Œåˆ†æã€‚\nè¿™ä»½ä»£ç å¹¶ä¸å®Œç¾ï¼Œç”šè‡³èƒ½æ‰¾åˆ°å‡ å¤„bugï¼Œä½†ä¸å¦¨ç¢æˆ‘ä»¬å­¦ä¹ å…¶æ€æƒ³ï¼›githubåœ°å€ï¼šhttps://github.com/siejqa/spoofHeadless\nèƒŒæ™¯çŸ¥è¯†ç®€å•ä»‹ç» Webglå’Œå‚æ•°é‡‡é›† ç®€å•æ¥è¯´webglå°±æ˜¯æµè§ˆå™¨ç»™å‰ç«¯jsä»£ç è°ƒç”¨çš„æ¸²æŸ“ç»˜å›¾APIï¼Œè¯¥APIå¯ä»¥åœ¨åœ¨html canvaså…ƒç´ ä¸­ä½¿ç”¨ï¼Œå¯ä»¥è°ƒç”¨åˆ°ç¡¬ä»¶è¿›è¡ŒåŠ é€Ÿï¼Œæ‰€ä»¥webglçš„å‚æ•°é€šå¸¸ä¸ç¡¬ä»¶å¼ºç›¸å…³ã€‚æ›´å…·ä½“çš„ä»‹ç»å’Œæ•™ç¨‹å¯ä»¥å‚è€ƒï¼šhttps://www.w3cschool.cn/webgl/i4gf1oh1.html\nå…·ä½“é‡‡é›†webglçš„å‚æ•°æ—¶ï¼Œéœ€è¦é¦–å…ˆå…ˆè·å–canvasä¸‹çš„webgl Contextï¼Œä½¿ç”¨getContextæ¥å£ã€‚è€Œé‡‡é›†å…·ä½“å‚æ•°æ˜¯ä½¿ç”¨getParameterå‡½æ•°å®Œæˆï¼ŒgetParameteræ¥å—ä¸€ä¸ªæ•´æ•°ï¼Œæ¯ä¸ªæ•´æ•°å¯¹åº”ä¸€ä¸ªå±æ€§ï¼›ä»¥è·å–GPUå‹å·ä¸ºä¾‹ï¼š\n1 2 3 4 5  // è·å–webgl context var gl = document.createElement(\u0026#34;canvas\u0026#34;).getContext(\u0026#34;webgl\u0026#34;) // é‡‡é›†GPU renderï¼šç¼–å·ä¸º37446 gl.getExtension(\u0026#34;WEBGL_debug_renderer_info\u0026#34;)[\u0026#34;UNMASKED_RENDERER_WEBGL\u0026#34;] gl.getParameter(37446)   å®Œæ•´çš„getParameterå¸¸é‡è¡¨å¯ä»¥å‚è€ƒï¼šhttps://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants\nWebdriver webdriveræœ¬è´¨ä¸Šæ˜¯æµè§ˆå™¨æ ¹æ®w3cå®ç°çš„ä¸€å¥—æ“ä½œæµè§ˆå™¨çš„æ¥å£ï¼Œè€Œæ¯ä¸ªæµè§ˆå™¨éƒ½æœ‰ä¸€ä¸ªç‰¹å®šçš„ WebDriver å®ç°ï¼Œå¦‚chrome webdriverï¼šhttps://chromedriver.chromium.org/downloads\nè€Œç›®å‰æ¯”è¾ƒå¹¿ä¹‰çš„å®šä¹‰ï¼ˆæˆ–è€…è¯´é»‘äº§ä½¿ç”¨çš„æ–¹å¼ï¼‰ï¼Œé€šå¸¸æ˜¯æŒ‡puppeteer/seleniumè¿™ç±»ï¼Œé›†æˆäº†å¤šç§æµè§ˆå™¨ï¼Œå¹¶æä¾›é«˜çº§apiä¾›ä¸Šå±‚åº”ç”¨è°ƒç”¨çš„è‡ªåŠ¨åŒ–å·¥å…·ï¼›å¯ä»¥ç›´æ¥ä½¿ç”¨python(selenium)å’Œnodejs(puppeteer)æ¥ç¼–å†™è„šæœ¬ï¼Œå®Œæˆwebdriverçš„æ§åˆ¶ï¼Œä»è€Œå®Œæˆæµè§ˆå™¨ä¸Šçš„è‡ªåŠ¨åŒ–æ“ä½œã€‚ç›¸å…³èµ„æ–™å¯ä»¥è‡ªè¡Œæœç´¢å­¦ä¹ ã€‚\nSpoofWebGLä½¿ç”¨æ–¹æ³• æ­¤å¤„ä»‹ç»å¦‚ä½•åœ¨seleniumä½¿ç”¨SpoofWebGLå·¥å…·ï¼Œå½“ç„¶è¯¥å·¥å…·ç®€å•æ”¹é€ åå¯ä»¥åœ¨æ‰€æœ‰çš„webdriverä¸Šä½¿ç”¨ã€‚\n å°†é¡¹ç›®cloneä¸‹æ¥ä¹‹åï¼Œä½¿ç”¨å¯ä»¥çœ‹åˆ°srcæ–‡ä»¶å¤¹ä¸‹æœ‰ä¸¤ä¸ªæ–‡ä»¶ï¼Œå…¶ä¸­manifest.jsonæ˜¯extensionçš„é…ç½®æ–‡ä»¶ï¼Œinjectedæ˜¯æºç ã€‚   ä¹‹åç”¨zipå‘½ä»¤å°†srcæ–‡ä»¶å¤¹æ‰“åŒ…ï¼šzip -rj extension.zip src/ å°†zipåç¼€åæ”¹æˆ.crx(chrome extensionçš„åç¼€å) ï¼šmv extension.zip extension.crx ç¼–å†™webdriverè„šæœ¬å¦‚ä¸‹ï¼ˆæ³¨æ„è¦å…ˆå®‰è£…å¥½seleniumå’Œchrome webdriverï¼‰ï¼Œå»è§‚å¯Ÿæˆ‘ä»¬çš„webglå‚æ•°è¯»å–æƒ…å†µï¼ˆæ³¨æ„åŸé¡¹ç›®ä¸­ä½¿ç”¨çš„æ˜¯firefoxçš„webdriverï¼Œæ‰€ä»¥è„šæœ¬è¦åšä¿®æ”¹ï¼‰ï¼š  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver opt = webdriver.ChromeOptions() extension_path = \u0026#39;./extension.crx\u0026#39; opt.add_extension(extension_path) driver = webdriver.Chrome(options=opt) # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   å¯ä»¥çœ‹åˆ°è¿™ä¸ªvendorå’Œrenderå·²ç»ä¸å¤ªæ­£å¸¸äº†ï¼›\n ä½œä¸ºå¯¹æ¯”ï¼Œæ³¨é‡Šæ‰optionsç›´æ¥å¯åŠ¨ï¼Œä¼šæ˜¾ç¤ºæœ¬æœºçš„çœŸå®GPUï¼š  1 2 3 4 5 6 7 8 9 10  from selenium import webdriver # opt = webdriver.ChromeOptions() #  # extension_path = \u0026#39;./extension.crx\u0026#39; # opt.add_extension(extension_path) driver = webdriver.Chrome() # Check what data is spoofed driver.get(\u0026#39;https://browserleaks.com/webgl\u0026#39;)   æ³¨ï¼šæ­¤å¤„æ˜¯ä½¿ç”¨æµè§ˆå™¨ç•Œé¢æ¨¡å¼æ‰“å¼€çš„ï¼Œå®é™…ä¸Šå¦‚æœæ˜¯å¯åŠ¨headlessæ¨¡å¼ï¼Œè¯¥rendererä¼šå’Œæœ¬æœºçš„æœ‰å·®åˆ«ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¦ä½¿ç”¨spoof webglçš„åŸå› \næºç åˆ†æ æ€»ç»“æ¥è¯´ï¼Œè¯¥extensionæ˜¯å°†webglç›¸å…³çš„æ¥å£å…¨éƒ¨è¿›è¡Œäº†hookï¼Œæœ¬è´¨æŠ€æœ¯éš¾åº¦ä¸Šå¹¶ä¸å¤§ï¼Œä¸”å¯ä»¥å¾ˆå®¹æ˜“è¿›è¡Œå®šåˆ¶åŒ–ã€‚ä¸‹é¢å¼€å§‹å¯¹hookæ–¹æ³•è¿›è¡Œåˆ†æ\nwebdriverç›¸å…³ç»•è¿‡ å¼€å§‹çš„ç¬¬ä¸€éƒ¨åˆ†è·Ÿwebglæ£€æµ‹å…³ç³»ä¸å¤§ï¼Œä¸»è¦æ˜¯ç”¨definePropertyæ–¹æ³•å¯¹navigatorä¸‹ä¸€äº›å­—æ®µè¿›è¡Œäº†hookï¼Œç»•è¿‡webdriverç›¸å…³çš„ä¸€äº›æ£€æµ‹ï¼›ä¸»è¦æ˜¯è®¾ç½®ä¸Šæµè§ˆå™¨è¯­è¨€ï¼Œä»¥åŠå°†Navigator.webdriverç½®ä¸ºfalseï¼š\n1 2 3 4 5 6 7 8 9 10  Object.defineProperty(navigator, \u0026#39;languages\u0026#39;, { get: function () { var availableLanguages = Array(\u0026#39;en\u0026#39;, \u0026#39;pl\u0026#39;, \u0026#39;cs\u0026#39;, \u0026#39;ru\u0026#39;, \u0026#39;fr\u0026#39;, \u0026#39;fr-fr\u0026#39;, \u0026#39;lb\u0026#39;, \u0026#39;no\u0026#39;) return [\u0026#39;en-US\u0026#39;, get_random_item(availableLanguages)]; }, }); // fake webdriver property (headless has it as true) Object.defineProperty(navigator, \u0026#39;webdriver\u0026#39;, { get: () =\u0026gt; false, });   WebGL Hook æ ¹æ®ä¸Šæ–‡ä¸­webglè°ƒç”¨ç¤ºä¾‹å¯çŸ¥è°ƒç”¨webglæ¥å£é‡‡é›†å‚æ•°ä¸»è¦åˆ†ä¸ºä¸‰æ­¥ï¼š\n ä½¿ç”¨getContextè·å–webgl Context ä½¿ç”¨context.getExtensionè·å–webglæ‹“å±•çš„ç¼–å· ä½¿ç”¨context.getParameterè·å–å…·ä½“å‚æ•°çš„å€¼  å¯¹åº”æ­¥éª¤æˆ‘ä»¬æŸ¥çœ‹è¯¥è„šæœ¬çš„hookæ–¹æ³•ï¼š\nHTMLCanvasElement.getContext Hook è¦hookè¯¥æ–¹æ³•ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå®šä¹‰ä¸€ä¸ªç±»ï¼Œå¦‚ä¸‹ï¼š\n1 2 3 4 5  function WebGLRenderingContext(canvas) { this.canvas = canvas; this.drawingBufferWidth = canvas.width; this.drawingBufferHeight = canvas.height; };   ä¹‹åå°†WebGLRenderingContextä¸­çš„åŸºæœ¬å±æ€§å’Œæ–¹æ³•è¿›è¡Œåˆå§‹åŒ–ï¼Œå³å¯¹Object.prototype.attributeè¿›è¡Œèµ‹å€¼ä¸€ä¸ªç©ºå‡½æ•°ã€‚æ³¨æ„ï¼ŒåŸºç¡€å±æ€§æœ¬è´¨ä¸Šéƒ½æ˜¯ä¸€äº›ç¼–å·ï¼Œå¦‚ä¸Šæ–‡ä¸­çš„ä¾‹å­ä¸€æ ·ï¼Œä»–æ˜¯ç”¨æ¥ä¼ å…¥getParameteråšå…¥å‚çš„ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  // åŸwebgl Contextä¸­çš„åŸºæœ¬æ–¹æ³•é›†åˆ var functions = [ \u0026#39;viewport\u0026#39;, \u0026#39;vertexAttribPointer\u0026#39;, \u0026#39;vertexAttrib4fv\u0026#39;, \u0026#39;vertexAttrib4f\u0026#39;, \u0026#39;vertexAttrib3fv\u0026#39;, ... ] // åŸwebgl Contextä¸­çš„åŸºæœ¬å±æ€§é›†åˆï¼Œè¿™é‡ŒæŒ‘é€‰ä¸€äº›ç»å¸¸è¢«æ”¶é›†çš„ä½œä¸ºä¾‹å­ var enumerates = { ... \u0026#39;VERSION\u0026#39;: 7938, ... \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446, ... \u0026#39;DEPTH_BITS\u0026#39;: 3414, \u0026#39;GREEN_BITS\u0026#39;: 3411, \u0026#39;BLUE_BITS\u0026#39;: 3412, ... \u0026#39;STENCIL_BITS\u0026#39;: 3415, ... \u0026#39;MAX_VERTEX_UNIFORM_VECTORS\u0026#39;: 36347, \u0026#39;MAX_VERTEX_TEXTURE_IMAGE_UNITS\u0026#39;: 35660, \u0026#39;MAX_VERTEX_ATTRIBS\u0026#39;: 34921, \u0026#39;MAX_VARYING_VECTORS\u0026#39;: 36348, \u0026#39;MAX_TEXTURE_SIZE\u0026#39;: 3379, \u0026#39;MAX_TEXTURE_IMAGE_UNITS\u0026#39;: 34930, \u0026#39;MAX_RENDERBUFFER_SIZE\u0026#39;: 34024, \u0026#39;MAX_FRAGMENT_UNIFORM_VECTORS\u0026#39;: 36349, \u0026#39;MAX_CUBE_MAP_TEXTURE_SIZE\u0026#39;: 34076, \u0026#39;MAX_COMBINED_TEXTURE_IMAGE_UNITS\u0026#39;: 35661, ... }; // å°†åŸæœ¬çš„å‡½æ•°å…¨éƒ¨æ›¿æ¢æˆç©ºå‡½æ•° functions.forEach(function (func) { WebGLRenderingContext.prototype[func] = function () { return {}; }; }); Object.keys(enumerates).forEach(function (key) { WebGLRenderingContext.prototype[key] = enumerates[key]; });   å®é™…ä¸ŠåŸè„šæœ¬ä¹‹åé©¬ä¸Šå¯¹context.getExtensionå®Œæˆäº†èµ‹å€¼ï¼Œé‚£æ­¤å¤„å…¶å®é¡ºåºä¸å½±å“æ‰§è¡Œç»“æœï¼Œæ‰€ä»¥æˆ‘ä»¬ç•™åœ¨ä¸‹ä¸€èŠ‚æè¿°ã€‚\nè¿›å…¥hookçš„ä»£ç ï¼Œå®é™…ä¸Šdocument.createElement(\u0026ldquo;canvas\u0026rdquo;).getContext(\u0026quot;webgl\u0026quot;)è°ƒç”¨åˆ°çš„æ˜¯HTMLCanvasElement.getContextæ–¹æ³•ï¼Œæ‰€ä»¥å¯¹è¯¥æ–¹æ³•è¿›è¡ŒHookï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  try { const getContext = HTMLCanvasElement.prototype.getContext; // åˆ©ç”¨é‡å®šä¹‰HTMLCanvasElement.prototype.getContextå®ŒæˆHookï¼Œæ˜¯å¸¸è§çš„hookæ–¹æ³•  HTMLCanvasElement.prototype.getContext = function () { // è·å–ç¬¬ä¸€ä¸ªå…¥å‚ï¼Œé€šå¸¸ä¸º\u0026#34;webgl\u0026#34;ï¼Œ\u0026#39;webgl-experimental\u0026#39;ç­‰  var name = arguments[0]; console.log(\u0026#34;HTMLCanvasElement app requested extension: \u0026#34; + name); console.log(JSON.stringify(arguments, null, 4)); if (name == \u0026#39;webgl\u0026#39; || name == \u0026#39;webgl-experimental\u0026#39; || name == \u0026#39;experimental-webgl\u0026#39; || name == \u0026#39;moz-webgl\u0026#39;) { // æœ€ç»ˆè¿”å›äº†ä¸Šæ–‡ä¸­è‡ªå®šä¹‰çš„ç±»WebGLRenderingContextï¼Œå®Œæˆhook  var y = new WebGLRenderingContext(this); console.log(\u0026#34;WEBGL \u0026#34; + y); console.log(JSON.stringify(y, null, 4)); return y; } // å…¶ä»–çš„webglç±»å‹ä¸æ”¯æŒï¼Œè¿”å›åŸå§‹æ•°æ®  if (name == \u0026#39;webgl2\u0026#39; || name == \u0026#39;experimental-webgl2\u0026#39; || name == \u0026#39;fake-webgl\u0026#39;) { console.log(\u0026#34;WEBGL2\u0026#34;) return null; } var ext = getContext.apply(this, arguments); console.log(\u0026#34;HTMLCanvasElement extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(ext); return ext; } } catch (e) { }   context.getExtensionå®šä¹‰ å®é™…ä¸Šå¾ˆç®€å•ï¼Œåªéœ€è¦getå¯¹åº”å±æ€§æ—¶è¿”å›æŒ‡å®šç¼–å·å³å¯ï¼Œæ­¤å¤„ä»¥ä¸Šæ–‡ä¸­çš„\u0026quot;WEBGL_debug_renderer_info\u0026quot;ä¸ºä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  var extensions = { // ratified  ... \u0026#39;WEBGL_debug_renderer_info\u0026#39;: { \u0026#39;UNMASKED_VENDOR_WEBGL\u0026#39;: 37445, \u0026#39;UNMASKED_RENDERER_WEBGL\u0026#39;: 37446 }, ... } WebGLRenderingContext.prototype.getExtension = function (ext) { console.log(\u0026#34;WebGLRenderingContext.getExtension\u0026#34; + ext); return extensions[ext]; };   æ³¨æ„æ­¤å¤„æœ‰ä¸€äº›ç‰¹ä¾‹æ˜¯\u0026quot;WEBGL_lose_context\u0026quot;å’Œ\n\u0026ldquo;WEBGL_draw_buffers\u0026rdquo;, ä»–ä»¬çš„å±æ€§å†…éƒ¨åŒ…å«æ–¹æ³•ï¼Œéœ€è¦å®šä¹‰ä¸€ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  function loseContext () { } function restoreContext () { } function drawBuffersWEBGL () { } var extensions = { // ratified  ... \u0026#39;WEBGL_lose_context\u0026#39;: { loseContext, restoreContext }, ... \u0026#39;WEBGL_draw_buffers\u0026#39;: { \u0026#39;MAX_DRAW_BUFFERS_WEBGL\u0026#39;: 34852, \u0026#39;MAX_COLOR_ATTACHMENTS_WEBGL\u0026#39;: 36063, ... drawBuffersWEBGL }, }   context.getParameter å®šä¹‰ï¼Œå®Œæˆå–å€¼çš„Hook ä»£ç å¯ä»¥æ‹†è§£å¦‚ä¸‹ï¼š\n å®šä¹‰éƒ¨åˆ†ï¼Œæ‹¿åˆ°getParameterçš„å‚æ•°ï¼š  1 2 3 4 5 6 7  try { const getParameter = WebGLRenderingContext.prototype.getParameter; WebGLRenderingContext.prototype.getParameter = function () { var name = arguments[0]; console.log(\u0026#34;WebGLRenderingContext - getParameter: \u0026#34; + name); ... } catch (a) { }    Hook UNMASKED_VENDOR_WEBGL å’ŒUNMASKED_RENDERER_WEBGL å‚æ•°ï¼Œä»ä¸€ä¸ªå¤‡é€‰åˆ—è¡¨ä¸­éšæœºè¿”å›ä¸€ä¸ªvendor/rendererï¼Œå¯ä»¥å¾ˆå¥½çš„é˜²æ­¢æ”¶é›†ä¿¡æ¯ç»“æœè¿‡åº¦é›†ä¸­ï¼Œä¹Ÿå¯ä»¥å¾ˆæ–¹ä¾¿çš„è¿›è¡Œæ‹“å±•ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  function get_random_item(list) { return list[Math.floor((Math.random() * list.length))]; } WebGLRenderingContext.prototype.getParameter = function () { ... // UNMASKED_VENDOR_WEBGL  if (name == 37445) { var options = [\u0026#39;Intel Open Source Technology Center\u0026#39;, \u0026#39;X.Org\u0026#39;, \u0026#39;Vendor Google Inc.\u0026#39;]; return get_random_item(options); } else if (name == 37446) { // UNMASKED_RENDERER_WEBGL  var options = [\u0026#39;Mesa DRI Intel(R) Ivybridge Mobile\u0026#39;, \u0026#39;AMD KAVERI (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Renderer Google SwiftShader\u0026#39;, \u0026#39;AMD ARUBA (DRM 2.43.0 / 4.4.0-119-generic, LLVM 5.0.0)\u0026#39;, \u0026#39;Mesa DRI Intel(R) HD Graphics 630 (Kaby Lake GT2)\u0026#39;, \u0026#39;Gallium 0.4 on AMD KAVERI (DRM 2.43.0 / 4.4.0-83-generic, LLVM 3.8.0)\u0026#39;]; return get_random_item(options); } ... }    Hook ä¸€äº›åŸºç¡€å±æ€§, å¦‚RENDERER / VENDOR / SHADING_LANGUAGE_VERSION /  VERSION\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 7936) { // RENDERER // VENDOR  return \u0026#39;Mozilla\u0026#39;; } else if (name == 35724) { // SHADING_LANGUAGE_VERSION  return \u0026#39;WebGL GLSL ES 1.0\u0026#39;; } else if (name == 7937 || name == 7938) { // VERSION  return \u0026#39;WebGL 1.0\u0026#39;; } ... }    Hook ALIASED_LINE_WIDTH_RANGE / ALIASED_POINT_SIZE_RANGE, ä¼šè¿”å›ä¸€ä¸ªfloat arrayï¼Œsizeä¸º2ï¼›è¿™é‡Œä»£ç æœ‰ç‚¹å°é—®é¢˜ï¼Œä¸å½±å“åŠŸèƒ½ï¼Œname == 7937æ˜¯VERSIONï¼Œä¸è¿‡åœ¨ä¸Šé¢å·²ç»åˆ¤æ–­è¿‡äº†ï¼Œä¸ä¼šè¿›åˆ°è¿™ä¸ªåˆ†æ”¯ï¼š  1 2 3 4 5 6 7 8 9  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 7937 || name == 33901 || name == 33902) { // ALIASED_LINE_WIDTH_RANGE // ALIASED_POINT_SIZE_RANGE  var option = new Float32Array([1, 8192]); return option; } ... }    é’ˆå¯¹ä¸€äº›webglä½å®½ä¿¡æ¯è¿›è¡ŒHookï¼Œè¿”å›éšæœºå€¼[2, 4, 8, 16]ä¸­1ä¸ªï¼Œå…·ä½“å‚æ•°è§æ³¨é‡Šï¼š  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3413 || name == 3412 || name == 3411 || name == 3410 || name == 34852) { // ALPHA_BITS // BLUE_BITS // GREEN_BITS // RED_BITS // MAX_DRAW_BUFFERS_WEBGL  return get_random_item([2, 4, 8, 16]); } ... }    é’ˆå¯¹ä¸€äº›ä½å®½ä¿¡æ¯è¿›è¡ŒHookï¼Œè¿”å›å›ºå®šå€¼ï¼Œå‚æ•°è§æ³¨é‡Š  1 2 3 4 5 6 7 8 9 10 11  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3415) // STENCIL_BITS  return 0; } else if (name == 3414) { // DEPTH_BITS  return 24; } ... }    æ¥ä¸‹æ¥æ˜¯è¯¥è„šæœ¬bugçš„åœ°æ–¹ï¼ŒHookå‡ºç°é—®é¢˜ï¼Œå¦‚æœä½¿ç”¨è¯¥è„šæœ¬ä¸åŠ ä¿®æ”¹ï¼Œå¾ˆå®¹æ˜“é€šè¿‡æ­¤bugè¯†åˆ«ï¼›åŸå› ä¸»è¦åœ¨äºä»¥ä¸‹hookçš„ä¸‰ä¸ªå‚æ•°å€¼ç†è®ºä¸Šæ˜¯è¿”å›ä¸€ä¸ªæ•´æ•°ï¼Œä½†ä¸çŸ¥ä¸ºä½•ä½œè€…è¿™é‡Œä½¿ç”¨äº†get_random_items, ä½†æ²¡æœ‰ç»™ç¬¬äºŒä¸ªå‚æ•°ï¼Œæ‰€ä»¥nä¼šä¸ºundefinedï¼Œå¯¼è‡´å›ºå®šè¿”å›ä¸€ä¸ªArrayï¼šundefinedï¼›ä¿®å¤ä¹Ÿå¾ˆç®€å•ï¼Œæ¢æˆget_random_itemå³å¯ã€‚æºä»£ç å¦‚ä¸‹ï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  function get_random_items(list, n) { var result = new Array(n), len = list.length, taken = new Array(len); if (n \u0026gt; len) n = len while (n--) { var x = Math.floor(Math.random() * len); result[n] = list[x in taken ? taken[x] : x]; // æ¯”è¾ƒå·§å¦™çš„å–éšæœºå¤šä¸ªå€¼çš„æ–¹å¼ï¼Œç•™ä¸€ä¸ªarrayæ ‡è®°å¦‚æœä¸‹æ¬¡å†å–åˆ°å…¶ä¸‹æ ‡ä¼šä»ç›®å‰æœªå–æˆçš„æœ€åä¸€ä¸ªå…ƒç´   taken[x] = --len in taken ? taken[len] : len; } return result; } WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 34047 || name == 34921) { // MAX_TEXTURE_MAX_ANISOTROPY_EXT // MAX_VERTEX_ATTRIBS  return get_random_items([2, 4, 8, 16]); } else if (name == 35661) { // MAX_COMBINED_TEXTURE_IMAGE_UNITS  return get_random_items([128, 192, 256]); } ... }    å¯¹ä¸€äº›å…¶ä»–çš„MAXç›¸å…³å±æ€§è¿›è¡ŒHookï¼Œè¿”å›éšæœºå€¼ï¼Œå…·ä½“å±æ€§è§æ³¨é‡Š  1 2 3 4 5 6 7 8 9 10 11 12 13 14  WebGLRenderingContext.prototype.getParameter = function () { ... } else if (name == 34076 || name == 34024 || name == 3379) { // MAX_CUBE_MAP_TEXTURE_SIZE // MAX_RENDERBUFFER_SIZE  return get_random_item([16384, 32768]) ; } else if (name == 36349 || name == 36347) { // MAX_FRAGMENT_UNIFORM_VECTORS // MAX_VERTEX_UNIFORM_VECTORS  return get_random_item([4096, 8192]); } else if (name == 34930 || name == 36348 || name == 35660) { // MAX_TEXTURE_IMAGE_UNITS // MAX_VARYING_VECTORS // MAX_VERTEX_TEXTURE_IMAGE_UNITS  return get_random_item([16, 32, 64]); } ... }    å¯¹MAX_VIEWPORT_DIMSè¿›è¡ŒHookï¼Œä¼šè¿”å›ä¸€ä¸ªé•¿åº¦ä¸º2ä¸”ä¸¤ä¸ªå€¼ç›¸ç­‰çš„Int32Arrayï¼ŒåŒæ ·æ­¤å¤„éšæœºå–å€¼ï¼š  1 2 3 4 5 6 7 8 9 10  WebGLRenderingContext.prototype.getParameter = function () { ... else if (name == 3386) { // MAX_VIEWPORT_DIMS  var value = get_random_item([8192, 16384, 32768]) var options = new Int32Array([value, value]); return options; } ... }    æœ€åï¼Œå‰©ä¸‹çš„å‚æ•°ç»Ÿä¸€éšæœºä»[0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]éšæœºå–å€¼è¿”å›(æ­¤å¤„è¿˜æœ‰ä¸ªå†—ä½™åˆ†æ”¯STENCIL_BITSï¼Œä¸Šé¢å·²ç»åˆ¤æ–­è¿‡äº†ï¼Œå±äºå†—ä½™ä»£ç )  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... else { console.log(\u0026#34;Retuning random value for: \u0026#34; + name); return get_random_item([0, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096]); } ... }    æœ€åçš„è¿·æƒ‘æ“ä½œï¼šç†è®ºä¸Šæ­¤å¤„å·²ç»æ¶µç›–äº†æ‰€æœ‰çš„caseè¿”å›ï¼Œä½†æ˜¯æœ€åè¿˜å¤šäº†ä¸ªè·‘ä¸åˆ°çš„åˆ†æ”¯ï¼š  1 2 3 4 5 6 7 8  WebGLRenderingContext.prototype.getParameter = function () { ... var ext = getParameter.apply(this, arguments); console.log(\u0026#34;WebGLRenderingContext extension \u0026#34; + name + \u0026#34; \u0026#34; + (ext ? \u0026#34;found\u0026#34; : \u0026#34;not found\u0026#34;)); console.log(JSON.stringify(ext, null, 4)); return ext; }   è¯´å®è¯æˆ‘çŒœæµ‹æ­¤å¤„ä»–æ˜¯æƒ³æ¨¡æ‹Ÿä¸€äº›å‚æ•°ï¼Œä»–ä»¬åœ¨getParameterä¹‹å‰å¿…é¡»å…ˆè°ƒç”¨getExtensionæ–¹æ³•åæ‰å¯ä»¥è·å–ï¼Œä½†æ˜¯æ­¤å¤„åŠ åœ¨æœ€åå±å®çœ‹ä¸æ‡‚ï¼Œä¸ªäººç†è§£åº”è¯¥æ”¾åœ¨è¿™ä¸ªå¤§if\u0026hellip;else\u0026hellip;å‰é¢ï¼›æœ‰æ—¶é—´æˆ‘å¯ä»¥å¥½å¥½ä¿®å¤ä¸€ä¸‹è¿™ä¸ªé¡¹ç›®ğŸ˜‚ğŸ˜‚\nå…¶ä»–çš„ä¸€äº›è¢«Hookçš„æ–¹æ³•  getSupportedExtensionï¼šæ¯”è¾ƒç®€å•ï¼Œéšæœºä»extensionsä¸­é—´é€‰æ‹©éšæœºä¸ªkeyså¹¶è¿”å›ï¼Œå‡ºç°å¼‚å¸¸åˆ™å°†æ‰€æœ‰çš„keyséƒ½è¿”å›ã€‚  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  // extensionsçš„keyså¯ä»¥å‚è§getExtensionéƒ¨åˆ† const getSupportedExtensions = WebGLRenderingContext.prototype.getSupportedExtensions; WebGLRenderingContext.prototype.getSupportedExtensions = function () { try { console.log(\u0026#34;WebGLRenderingContext.getSupportedExtensions\u0026#34;) var availableExtensions = Object.keys(extensions); console.log(availableExtensions); var itemsToGet = Math.floor(Math.random() * (availableExtensions.length - 6) + 5); console.log(itemsToGet); var selectedExtensions = get_random_items(availableExtensions, itemsToGet); console.log(selectedExtensions); return selectedExtensions; } catch (a) { console.log(a) return Object.keys(extensions); } }    é’ˆå¯¹ä¸€äº›headlessæµè§ˆå™¨æœ‰å¯èƒ½ä¼šå‡ºç°canvasçš„ä¸€äº›å±æ€§å¼‚å¸¸ï¼ˆbrokenä¼šä¸º0ï¼‰ï¼Œå¦‚canvasçš„widthå’Œheightï¼Œä»¥åŠoffsetï¼Œè¿›è¡ŒHookï¼Œè¿˜æ˜¯ä½¿ç”¨definePropertyé‡å†™getæ–¹æ³•å¯¹å±æ€§è¿›è¡Œhookï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  // in case of broken image return random height/width var size = 0; [\u0026#39;height\u0026#39;, \u0026#39;width\u0026#39;].forEach(property =\u0026gt; { const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLImageElement.prototype, property); Object.defineProperty(HTMLImageElement.prototype, property, { imageDescriptor, get: function () { // å¦‚æœcanvasç ´æŸï¼Œåˆ™è¿”å›éšæœºsize  if (this.complete \u0026amp;\u0026amp; this.naturalHeight == 0) { if (!size) { // è¿”å›éšæœºçš„é•¿/å®½  size = Math.floor(Math.random() * (30 - 10 + 1)) + 10; } return size; } // æœªç ´æŸåˆ™è¿”å›æ­£å¸¸size  return imageDescriptor.get.apply(this); }, }); }); // hairline feature (headless can\u0026#39;t render it normally) const imageDescriptor = Object.getOwnPropertyDescriptor(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;); Object.defineProperty(HTMLElement.prototype, \u0026#39;offsetHeight\u0026#39;, { ...imageDescriptor, get: function () { if (this.id == \u0026#39;modernizr\u0026#39;) { return 1; } return imageDescriptor.get.apply(this); }, });   æ’ä»¶æ‰§è¡Œ æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œå°†æ•´ä¸ªå¤§å‡½æ•°ä½œä¸ºå­—ç¬¦ä¸²ï¼Œæœ€ååœ¨html documentä¸­æ–°å»ºä¸€ä¸ªscript tagï¼Œscript.textContentèµ‹å€¼ä¸ºå­—ç¬¦ä¸²å³å¯ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  var scriptCode = \u0026#39;(\u0026#39; + function () { ... function WebGLRenderingContext(canvas) { ... }; ... WebGLRenderingContext.prototype.getExtension = function (ext) { ... }; ... WebGLRenderingContext.prototype.getParameter = function () { ... } ... } + \u0026#39;)();\u0026#39;; // è½¬æˆå­—ç¬¦ä¸²ï¼Œå¯ç›´æ¥æ‰§è¡Œ  // æ–°å»ºscriptèŠ‚ç‚¹æ’å…¥documentä¸­ï¼Œå³è‡ªåŠ¨æ‰§è¡Œ var script = document.createElement(\u0026#39;script\u0026#39;); script.textContent = scriptCode; (document.head || document.documentElement).appendChild(script); // æœ€åmoveæ‰ä»£ç å³å¯ script.remove();   ","description":"SpoofWebGL","id":3,"section":"posts","tags":["é»‘äº§å·¥å…·"],"title":"SpoofWebGL","uri":"https://summersummer3.github.io/posts/spoofwebgl/"},{"content":"å¾ˆä¹…æ²¡æœ‰å†™åšå®¢äº†ï¼Œä¸»è¦æ˜¯æœ€è¿‘æ¢äº†ä¸ªåœ°æ‰“å·¥ï¼Œå¼€å§‹å¯¹ä¸€äº›åè‡ªåŠ¨åŒ–çš„å·¥ä½œå¼€å§‹è¿›è¡Œç ”ç©¶ï¼›è¿™æ˜¯ä¸€ç¯‡å­¦ä¹ ç¬”è®°ï¼Œæ¬¢è¿äº¤æµ~\nèƒŒæ™¯ä¸ç½‘ç«™ä»‹ç» Bot Challengeæ˜¯ä¸“é—¨çš„web botæ£€æµ‹çš„ç½‘ç«™ï¼šhttps://bot.incolumitas.com/#botChallenge\nè¯¥ç½‘ç«™å¯¹ç”¨æˆ·è¡Œä¸ºçš„æ£€æµ‹æ‰‹æ®µå¾ˆå®Œæ•´ï¼Œå€¼å¾—å­¦ä¹ ï¼›\nç”¨æˆ·è¡Œä¸ºæ•°æ® æ€»ä½“æ”¶é›†çš„event 1 2 3 4 5 6 7  this.recordedEvents = [\u0026#34;mousemove\u0026#34;, \u0026#34;mousedown\u0026#34;, \u0026#34;mouseup\u0026#34;, \u0026#34;dblclick\u0026#34;, \u0026#34;contextmenu\u0026#34;, \u0026#34;scroll\u0026#34;, \u0026#34;resize\u0026#34;, \u0026#34;keydown\u0026#34;, \u0026#34;keyup\u0026#34;, \u0026#34;touchstart\u0026#34;, \u0026#34;touchmove\u0026#34;, \u0026#34;touchcancel\u0026#34;, \u0026#34;touchend\u0026#34;, \u0026#34;load\u0026#34;, \u0026#34;DOMContentLoaded\u0026#34;, \u0026#34;visibilitychange\u0026#34;, \u0026#34;pagehide\u0026#34;, \u0026#34;beforeunload\u0026#34;, \u0026#34;unload\u0026#34;], this.newRecordedEvents = [\u0026#34;copy\u0026#34;, \u0026#34;paste\u0026#34;, \u0026#34;deviceorientation\u0026#34;, \u0026#34;devicemotion\u0026#34;] this.onlyWindowEvent = [\u0026#34;scroll\u0026#34;, \u0026#34;keydown\u0026#34;, \u0026#34;keyup\u0026#34;, \u0026#34;resize\u0026#34;, \u0026#34;copy\u0026#34;, \u0026#34;paste\u0026#34;, \u0026#34;deviceorientation\u0026#34;, \u0026#34;devicemotion\u0026#34;, \u0026#34;visibilitychange\u0026#34;, \u0026#34;load\u0026#34;, \u0026#34;DOMContentLoaded\u0026#34;, \u0026#34;pagehide\u0026#34;, \u0026#34;beforeunload\u0026#34;, \u0026#34;unload\u0026#34;], this.recordNewEvents \u0026amp;\u0026amp; (this.recordedEvents = this.recordedEvents.concat(this.newRecordedEvents))   å…·ä½“è¡Œä¸ºæ”¶é›†å¯ä»¥åˆ†ä¸ºä»¥ä¸‹å‡ ç±»ï¼Œä¸»è¦åˆ†æä¸‹æ”¶é›†çš„å…·ä½“æ•°æ®å’Œè§¦å‘æ”¶é›†çš„äº‹ä»¶:\né¼ æ ‡åŠ¨ä½œ(MouseEvent) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  getMetaKeysBitstring: function(e) { var t = \u0026#34;\u0026#34;; return t += !0 === e.ctrlKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;, t += !0 === e.shiftKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;, t += !0 === e.altKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34;, t += !0 === e.metaKey ? \u0026#34;1\u0026#34; : \u0026#34;0\u0026#34; } getMouseFrame: function(e, t) { return [t, e.clientX, e.clientY, e.screenX, e.screenY, e.button, this.getMetaKeysBitstring(e)] }, mousemoveListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;m\u0026#34;) }, mousedownListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;md\u0026#34;) }, mouseupListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;mu\u0026#34;) }, dblclickListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;dc\u0026#34;) }, contextmenuListener: function(e, t) { return e.getMouseFrame(t, \u0026#34;cm\u0026#34;) },   æ•°æ®ï¼ˆåˆ—è¡¨å½¢å¼ï¼Œéƒ½æ˜¯ä»¥äº‹ä»¶åç®€å†™æ‰“å¤´ï¼Œåé¢æ˜¯æ”¶é›†çš„å…·ä½“æ•°æ®ï¼Œä¸‹åŒï¼‰ï¼š\n  clientXï¼šdoubleï¼ˆåŸä¸ºlongï¼‰ï¼›é¼ æ ‡åœ¨äº‹ä»¶è§¦å‘æ—¶çš„åº”ç”¨æµè§ˆå™¨å†…çš„æ°´å¹³åæ ‡\n  clientYï¼šdoubleï¼ˆåŸä¸ºlongï¼‰ï¼›é¼ æ ‡åœ¨äº‹ä»¶è§¦å‘æ—¶çš„åº”ç”¨æµè§ˆå™¨å†…çš„å‚ç›´åæ ‡\n  screenXï¼šdoubleï¼ˆåŸä¸ºlongï¼‰ï¼›é¼ æ ‡åœ¨äº‹ä»¶è§¦å‘æ—¶å…¨å±€ï¼ˆå±å¹•ï¼‰ä¸­çš„æ°´å¹³åæ ‡\n  screenYï¼šdoubleï¼ˆåŸä¸ºlongï¼‰ï¼›é¼ æ ‡åœ¨äº‹ä»¶è§¦å‘æ—¶å…¨å±€ï¼ˆå±å¹•ï¼‰ä¸­çš„å‚ç›´åæ ‡\n  button: numberï¼›ä»£è¡¨äº‹ä»¶è§¦å‘æ—¶æŒ‰ä¸‹çš„é¼ æ ‡æŒ‰é”®ï¼š\n 0ï¼šä¸»æŒ‰é”®ï¼Œé€šå¸¸æŒ‡é¼ æ ‡å·¦é”®æˆ–é»˜è®¤å€¼ï¼ˆè¯‘è€…æ³¨ï¼šå¦‚document.getElementById(\u0026lsquo;a\u0026rsquo;).click()è¿™æ ·è§¦å‘å°±ä¼šæ˜¯é»˜è®¤å€¼ï¼‰    1ï¼šè¾…åŠ©æŒ‰é”®ï¼Œé€šå¸¸æŒ‡é¼ æ ‡æ»šè½®ä¸­é”®\n  2ï¼šæ¬¡æŒ‰é”®ï¼Œé€šå¸¸æŒ‡é¼ æ ‡å³é”®\n  3ï¼šç¬¬å››ä¸ªæŒ‰é’®ï¼Œé€šå¸¸æŒ‡æµè§ˆå™¨åé€€æŒ‰é’®\n  4ï¼šç¬¬äº”ä¸ªæŒ‰é’®ï¼Œé€šå¸¸æŒ‡æµè§ˆå™¨çš„å‰è¿›æŒ‰é’®\n  MetaKeyï¼šStringï¼›æ”¶é›†è§¦å‘äº‹ä»¶æ—¶å¯¹åº”æŒ‰é”®æ˜¯å¦è¢«æŒ‰ä¸‹ï¼›\u0026lsquo;0\u0026rsquo;ä¸'1\u0026rsquo;ç»„æˆçš„å­—ç¬¦ä¸²\n  äº‹ä»¶ï¼š\n mousemoveï¼šé¼ æ ‡ç§»åŠ¨ mousedownï¼šé¼ æ ‡æŒ‰é’®æŒ‰ä¸‹æ—¶è§¦å‘ mouseupï¼šé¼ æ ‡æŒ‰é’®æ¾å¼€æ—¶è§¦å‘ dblclickï¼šé¼ æ ‡åŒå‡»æ—¶è§¦å‘ contextmenuï¼šæ‰“å¼€ä¸Šä¸‹æ–‡èœå•æ—¶è§¦å‘ï¼Œä¾‹å¦‚åœ¨é¡µé¢å³é”®æ‰“å¼€èœå•  é”®ç›˜åŠ¨ä½œ(KeyboardEvent) 1 2 3 4 5 6 7 8 9  getKeyFrame: function(e, t) { return [t, e.code, e.key, e.location, e.repeat, this.getMetaKeysBitstring(e)] }, keydownListener: function(e, t) { return e.getKeyFrame(t, \u0026#34;kd\u0026#34;) }, keyupListener: function(e, t) { return e.getKeyFrame(t, \u0026#34;ku\u0026#34;) },   æ•°æ®ï¼š\n codeï¼šStringï¼›é”®ç›˜ä¸Šçš„ç‰©ç†é”®ï¼ˆä¸æŒ‰é”®ç”Ÿæˆçš„å­—ç¬¦ç›¸å¯¹ï¼‰ã€‚æ¢å¥è¯è¯´ï¼Œæ­¤å±æ€§è¿”å›ä¸€ä¸ªå€¼ï¼Œè¯¥å€¼ä¸ä¼šè¢«é”®ç›˜å¸ƒå±€æˆ–ä¿®é¥°é”®çš„çŠ¶æ€æ”¹å˜ã€‚å¦‚QWERTYå¸ƒå±€é”®ç›˜ä¸Šçš„â€œqâ€é”®è¿”å›çš„codeæ˜¯â€œKeyQâ€ key: Stringï¼›è¿”å›ç”¨æˆ·æŒ‰ä¸‹çš„çœŸå®é€»è¾‘è¾“å…¥ã€‚å®ƒè¿˜ä¸ shiftKey ç­‰è°ƒèŠ‚æ€§æŒ‰é”®çš„çŠ¶æ€å’Œé”®ç›˜çš„åŒºåŸŸ / å’Œå¸ƒå±€æœ‰å…³ã€‚ location: unsigned longï¼Œè¡¨ç¤ºæŒ‰é”®åœ¨é”®ç›˜æˆ–å…¶ä»–è®¾å¤‡ä¸Šçš„ä½ç½®, ä¸»è¦é’ˆå¯¹ctrl/shiftç­‰é”®ç›˜ä¸Šæœ‰å¤šä¸ªçš„æŒ‰é”®ï¼Œä»¥åŠæ•°å­—/enterç­‰æŒ‰é”®ï¼š  0: è¡¨ç¤ºä¸åŒºåˆ†æˆ–è€…æ— æ³•åŒºåˆ† 1: æ¥è‡ªå·¦è¾¹çš„ctrl/shift/alt\u0026hellip; 2: æ¥è‡ªå³è¾¹çš„æŒ‰é”® 3: æ¥è‡ªæ•°å­—å°é”®ç›˜çš„æŒ‰é”® å…¶ä»–å€¼å·²åºŸå¼ƒ   repeat: Boolï¼›å¦‚æœæŒ‰é”®è¢«ä¸€ç›´æŒ‰ä½ï¼Œè¿”å›å€¼ä¸ºtrue Metakey: ä¸é¼ æ ‡äº‹ä»¶ä¸€æ ·  äº‹ä»¶ï¼š\n keydownï¼šé”®ç›˜æŒ‰ä¸‹è§¦å‘ keyupï¼šé”®ç›˜æ¾å¼€è§¦å‘  è§¦æ‘¸åŠ¨ä½œ(TouchEvent) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  getTouchFrame: function(e, t) { for (var n = [], i = 0; i \u0026lt; e.touches.length; i++) { var a = e.touches[i] , o = [this.round2(a.clientX), this.round2(a.clientY), this.round2(a.screenX), this.round2(a.screenY), a.identifier]; this.mobileExperimental \u0026amp;\u0026amp; (o = o.concat([this.round2(a.radiusX), this.round2(a.radiusY), a.rotationAngle, a.force])), n.push(o) } return [t, n, this.getMetaKeysBitstring(e)] }, touchstartListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;ts\u0026#34;) }, touchmoveListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;tm\u0026#34;) }, touchcancelListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;tc\u0026#34;) }, touchendListener: function(e, t) { return e.getTouchFrame(t, \u0026#34;te\u0026#34;) },   æ•°æ®ï¼š\n touches: Listï¼›æ˜¯ä¸€ä¸ªtouchListï¼Œä¸€ä¸ªè§¦æ‘¸å¹³é¢ä¸Šæ‰€æœ‰è§¦ç‚¹çš„åˆ—è¡¨ã€‚ä¾‹å¦‚ï¼Œå¦‚æœä¸€ä¸ªç”¨æˆ·ç”¨ä¸‰æ ¹æ‰‹æŒ‡æ¥è§¦å±å¹•ï¼ˆæˆ–è€…è§¦æ§æ¿ï¼‰ï¼Œä¸ä¹‹å¯¹åº”çš„ TouchList ä¼šåŒ…å«æ¯æ ¹æ‰‹æŒ‡çš„ [Touch](https://developer.mozilla.org/zh-CN/docs/Web/API/Touch) å¯¹è±¡ï¼Œæ€»å…±ä¸‰ä¸ª  touch.clientX/Touch.clientY/Touch.screenX/Touch.screenYï¼šdouble (ä¹‹å‰ä¸ºlong)ï¼›åŒé¼ æ ‡äº‹ä»¶åŒåå±æ€§ touch.identifierï¼šlongï¼›è¿”å›ä¸€ä¸ªå¯ä»¥å”¯ä¸€åœ°è¯†åˆ«å’Œè§¦æ‘¸å¹³é¢æ¥è§¦çš„ç‚¹çš„å€¼. è¿™ä¸ªå€¼åœ¨è¿™æ ¹æ‰‹æŒ‡ï¼ˆæˆ–è§¦æ‘¸ç¬”ç­‰ï¼‰æ‰€å¼•å‘çš„æ‰€æœ‰äº‹ä»¶ä¸­ä¿æŒä¸€è‡´, ç›´åˆ°å®ƒç¦»å¼€è§¦æ‘¸å¹³é¢ï¼›ä¸»è¦æ˜¯touchmoveä¸­    åº•ä¸‹çš„äº‹ä»¶å°†æ˜¯ExperimentalåŠŸèƒ½ï¼š\n touch.radiusXï¼šfloatï¼›æ‰‹æŒ‡ä¸å±å¹•æ¥è§¦é¢çš„æ¤­åœ†æ°´å¹³è½´åŠå¾„ touch.radiusYï¼šfloatï¼›æ‰‹æŒ‡ä¸å±å¹•æ¥è§¦é¢çš„æ¤­åœ†å‚ç›´è½´åŠå¾„ touch.rotationAngle: floatï¼›è¿”å›ä»¥åº¦ä¸ºå•ä½çš„æ—‹è½¬è§’. ç”±radiusX å’Œ radiusY æè¿°çš„æ­£æ–¹å‘çš„æ¤­åœ†ï¼Œé€šè¿‡é¡ºæ—¶é’ˆæ—‹è½¬è¿™ä¸ªè§’åº¦åï¼Œèƒ½æœ€ç²¾ç¡®åœ°è¦†ç›–ä½ç”¨æˆ·å’Œè§¦æ‘¸å¹³é¢çš„æ¥è§¦é¢çš„è§’åº¦. è¿™ä¸ªå€¼å¯èƒ½ä»0åˆ°90 touch.forceï¼šfloatï¼›æ‰‹æŒ‡æŒ¤å‹è§¦æ‘¸å¹³é¢çš„å‹åŠ›å¤§å°, ä»0.0(æ²¡æœ‰å‹åŠ›)åˆ°1.0(æœ€å¤§å‹åŠ›)  äº‹ä»¶ï¼š\n  touchstart: å½“ç”¨æˆ·åœ¨è§¦æ‘¸å¹³é¢ä¸Šæ”¾ç½®äº†ä¸€ä¸ªè§¦ç‚¹æ—¶è§¦å‘\n  touchmove: å½“ç”¨æˆ·åœ¨è§¦æ‘¸å¹³é¢ä¸Šç§»åŠ¨è§¦ç‚¹æ—¶è§¦å‘; å½“è§¦ç‚¹çš„åŠå¾„ã€æ—‹è½¬è§’åº¦ä»¥åŠå‹åŠ›å¤§å°å‘ç”Ÿå˜åŒ–æ—¶ï¼Œä¹Ÿå°†è§¦å‘æ­¤äº‹ä»¶\n  touchcancel: å½“è§¦ç‚¹ç”±äºæŸäº›åŸå› è¢«ä¸­æ–­æ—¶è§¦å‘ã€‚æœ‰å‡ ç§å¯èƒ½çš„åŸå› å¦‚ä¸‹ï¼ˆå…·ä½“çš„åŸå› æ ¹æ®ä¸åŒçš„è®¾å¤‡å’Œæµè§ˆå™¨æœ‰æ‰€ä¸åŒï¼‰ï¼š\n ç”±äºæŸä¸ªäº‹ä»¶å‡ºç°è€Œå–æ¶ˆäº†è§¦æ‘¸ï¼šä¾‹å¦‚è§¦æ‘¸è¿‡ç¨‹è¢«å¼¹çª—æ‰“æ–­ã€‚    è§¦ç‚¹ç¦»å¼€äº†æ–‡æ¡£çª—å£ï¼Œè€Œè¿›å…¥äº†æµè§ˆå™¨çš„ç•Œé¢å…ƒç´ ã€æ’ä»¶æˆ–è€…å…¶ä»–å¤–éƒ¨å†…å®¹åŒºåŸŸã€‚\n  å½“ç”¨æˆ·äº§ç”Ÿçš„è§¦ç‚¹ä¸ªæ•°è¶…è¿‡äº†è®¾å¤‡æ”¯æŒçš„ä¸ªæ•°ï¼Œä»è€Œå¯¼è‡´ [TouchList](https://developer.mozilla.org/zh-CN/docs/Web/API/TouchList) ä¸­æœ€æ—©çš„ [Touch] å¯¹è±¡è¢«å–æ¶ˆã€‚\n  touchend: å½“ä¸€ä¸ªè§¦ç‚¹è¢«ç”¨æˆ·ä»è§¦æ‘¸å¹³é¢ä¸Šç§»é™¤ï¼ˆå³ç”¨æˆ·çš„ä¸€ä¸ªæ‰‹æŒ‡æˆ–æ‰‹å†™ç¬”ç¦»å¼€è§¦æ‘¸å¹³é¢ï¼‰æ—¶è§¦å‘ã€‚å½“è§¦ç‚¹ç§»å‡ºè§¦æ‘¸å¹³é¢çš„è¾¹ç•Œæ—¶ä¹Ÿå°†è§¦å‘ã€‚ä¾‹å¦‚ç”¨æˆ·å°†æ‰‹æŒ‡åˆ’å‡ºå±å¹•è¾¹ç¼˜\n  å…ƒç´ ç§»åŠ¨ç›¸å…³ 1 2 3 4 5 6  scrollListener: function(e, t) { return [\u0026#34;s\u0026#34;, e.round2(document.scrollingElement.scrollLeft), e.round2(document.scrollingElement.scrollTop)] } resizeListener: function(e, t) { return [\u0026#34;r\u0026#34;, window.innerWidth, window.innerHeight] },    ScrollEventï¼šæ–‡æ¡£è§†å›¾æˆ–è€…ä¸€ä¸ªå…ƒç´ åœ¨æ»šåŠ¨æ—¶ï¼Œä¼šè§¦å‘; ä¸»è¦æ˜¯æ”¶é›†æ»šåŠ¨æ¡æ•°æ®  scrollingElement.scrollLeftï¼šinteger(æœ‰æ¯”ä¾‹ç¼©æ”¾çš„ç³»ç»Ÿå¯èƒ½ä¸ºfloat)ï¼›æ»šåŠ¨æ¡åˆ°æœ€å·¦è¾¹çš„è·ç¦» scrollingElement.scrollTopï¼šinteger(æœ‰æ¯”ä¾‹ç¼©æ”¾çš„ç³»ç»Ÿå¯èƒ½ä¸ºfloat)ï¼›æ»šåŠ¨æ¡åˆ°æœ€é¡¶ç«¯çš„è·ç¦»   resizeEventï¼šè°ƒæ•´è§†çª—å¤§å°æ—¶è§¦å‘è¯¥äº‹ä»¶  window.innerWidthï¼šintegerï¼›è¿”å›ä»¥åƒç´ ä¸ºå•ä½çš„çª—å£çš„å†…éƒ¨å®½åº¦ã€‚å¦‚æœå‚ç›´æ»šåŠ¨æ¡å­˜åœ¨ï¼Œåˆ™è¿™ä¸ªå±æ€§å°†åŒ…æ‹¬å®ƒçš„å®½åº¦ã€‚ window.innerHeightï¼šintegerï¼›è¿”å›ä»¥åƒç´ ä¸ºå•ä½çš„çª—å£çš„å†…éƒ¨é«˜åº¦åº¦ã€‚å¦‚æœæœ‰æ°´å¹³æ»šåŠ¨æ¡ï¼Œä¹ŸåŒ…æ‹¬æ»šåŠ¨æ¡é«˜åº¦ã€‚    é¡µé¢ç›¸å…³äº‹ä»¶ ä¸»è¦æ˜¯é¡µé¢åŠ è½½ï¼Œtabåˆ‡æ¢ç­‰ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  loadListener: function(e, t) { return [\u0026#34;lo\u0026#34;] }, DOMContentLoadedListener: function(e, t) { return [\u0026#34;dcl\u0026#34;] }, visibilitychangeListener: function(e, t) { return [\u0026#34;vc\u0026#34;, document.visibilityState] }, pagehideListener: function(e, t) { return [\u0026#34;ph\u0026#34;, t.persisted] }, beforeunloadListener: function(e, t) { return [\u0026#34;bu\u0026#34;] }, unloadListener: function(e, t) { return [\u0026#34;ul\u0026#34;] },     loadï¼šå½“æ•´ä¸ªé¡µé¢åŠæ‰€æœ‰ä¾èµ–èµ„æºå¦‚æ ·å¼è¡¨å’Œå›¾ç‰‡éƒ½å·²å®ŒæˆåŠ è½½æ—¶ï¼Œå°†è§¦å‘\n  DOMContentLoadedï¼šå½“çº¯HTMLè¢«å®Œå…¨åŠ è½½ä»¥åŠè§£ææ—¶ï¼Œäº‹ä»¶ä¼šè¢«è§¦å‘ï¼Œè€Œä¸å¿…ç­‰å¾…æ ·å¼è¡¨ï¼Œå›¾ç‰‡æˆ–è€…å­æ¡†æ¶å®ŒæˆåŠ è½½\n  visibilitychangeï¼šå½“å…¶é€‰é¡¹å¡çš„å†…å®¹å˜å¾—å¯è§æˆ–è¢«éšè—æ—¶ï¼Œä¼šåœ¨æ–‡æ¡£ä¸Šè§¦å‘\n document.visibilityStateï¼šStringï¼›è¿”å›documentçš„å¯è§æ€§, å³å½“å‰å¯è§å…ƒç´ çš„ä¸Šä¸‹æ–‡ç¯å¢ƒ. ç”±æ­¤å¯ä»¥çŸ¥é“å½“å‰æ–‡æ¡£(å³ä¸ºé¡µé¢)æ˜¯åœ¨èƒŒå, æˆ–æ˜¯ä¸å¯è§çš„éšè—çš„æ ‡ç­¾é¡µï¼Œæˆ–è€…(æ­£åœ¨)é¢„æ¸²æŸ“.å¯ç”¨çš„å€¼å¦‚ä¸‹ï¼š  'visible' : æ­¤æ—¶é¡µé¢å†…å®¹è‡³å°‘æ˜¯éƒ¨åˆ†å¯è§. å³æ­¤é¡µé¢åœ¨å‰æ™¯æ ‡ç­¾é¡µä¸­ï¼Œå¹¶ä¸”çª—å£æ²¡æœ‰æœ€å°åŒ–.      'hidden\u0026rsquo; : æ­¤æ—¶é¡µé¢å¯¹ç”¨æˆ·ä¸å¯è§. å³æ–‡æ¡£å¤„äºèƒŒæ™¯æ ‡ç­¾é¡µæˆ–è€…çª—å£å¤„äºæœ€å°åŒ–çŠ¶æ€ï¼Œæˆ–è€…æ“ä½œç³»ç»Ÿæ­£å¤„äº \u0026lsquo;é”å±çŠ¶æ€\u0026rsquo; .\n  'prerender' : é¡µé¢æ­¤æ—¶æ­£åœ¨æ¸²æŸ“ä¸­, å› æ­¤æ˜¯ä¸å¯è§çš„ (considered hidden for purposes of document.hidden). æ–‡æ¡£åªèƒ½ä»æ­¤çŠ¶æ€å¼€å§‹ï¼Œæ°¸è¿œä¸èƒ½ä»å…¶ä»–å€¼å˜ä¸ºæ­¤çŠ¶æ€.æ³¨æ„: æµè§ˆå™¨æ”¯æŒæ˜¯å¯é€‰çš„.\n  pagehideï¼šå½“æµè§ˆå™¨åœ¨éšè—å½“å‰é¡µé¢æ—¶, é¡µé¢éšè—äº‹ä»¶ä¼šè¢«å‘é€åˆ°ä¸€ä¸ªwindow ã€‚ä¾‹å¦‚ï¼Œå½“ç”¨æˆ·å•å‡»æµè§ˆå™¨çš„â€œåé€€â€æŒ‰é’®æ—¶ï¼Œå½“å‰é¡µé¢åœ¨æ˜¾ç¤ºä¸Šä¸€é¡µä¹‹å‰ä¼šæ”¶åˆ°ä¸€ä¸ªé¡µé¢éšè—äº‹ä»¶ã€‚\n persistedï¼šä»£è¡¨ä¸€ä¸ªé¡µé¢æ˜¯å¦ä»ç¼“å­˜ä¸­åŠ è½½çš„ï¼Œå¯ä»¥åˆ¤æ–­éšè—é¡µé¢æ˜¯å¦å·²ç¼“å­˜ä»¥è¿›è¡Œå¯èƒ½çš„é‡ç”¨æ—¶æ‰§è¡Œç‰¹æ®Šå¤„ç†    beforeunloadï¼šwindowã€document å’Œå®ƒä»¬çš„èµ„æºå³å°†å¸è½½æ—¶è§¦å‘ï¼Œä¾‹å¦‚å¯ä»¥å¼¹çª—ç¡®å®šæ˜¯å¦å…³é—­é€‰é¡¹å¡\n  unloadï¼šwindowã€document å’Œå®ƒä»¬çš„èµ„æºæ­£åœ¨å¸è½½æ—¶è§¦å‘\n  ç”¨æˆ·æ“ä½œç›¸å…³  Copy \u0026amp; paste  1 2 3 4 5 6 7 8 9 10  copyListener: function(e, t) { var n = document.getSelection() , i = [\u0026#34;co\u0026#34;]; return n \u0026amp;\u0026amp; i.push(Math.abs(n.anchorOffset, n.focusOffset)), i }, pasteListener: function(e, t) { return [\u0026#34;pa\u0026#34;, (t.clipboardData || window.clipboardData).getData(\u0026#34;text\u0026#34;).length] },    getSelectionï¼šè¿”å›ä¸€ä¸ªé€‰ä¸­å¯¹è±¡  selection.anchorOffset: integerï¼›è¿”å›é€‰ä¸­å…ƒç´ åœ¨DOMèŠ‚ç‚¹ä¸­èµ·å§‹ä½ç½®ï¼ˆæŒ‰ä¸‹é¼ æ ‡ï¼‰åç§» selection.focusOffsetï¼šintegerï¼›è¿”å›é€‰ä¸­å…ƒç´ åœ¨DOMèŠ‚ç‚¹ä¸­ç»ˆæ­¢ä½ç½®ï¼ˆæ¾å¼€é¼ æ ‡ï¼‰åç§»    ä¾‹å­:\n1  \u0026lt;text\u0026gt;abcdefg\u0026lt;text\u0026gt;   è‹¥é€‰ä¸­è¯¥textå…ƒç´ å†…çš„\u0026quot;bcd\u0026quot;ï¼Œåˆ™anchorOffset = 1ï¼ŒfocusOffset = 3\n  clipboardData. getData(\u0026ldquo;text\u0026rdquo;).length: integerï¼›ç²˜è´´æ¿ä¸Šå­—ç¬¦ä¸²é•¿åº¦\n  Deviceorientation: è®¾å¤‡ï¼ˆæŒ‡æ‰‹æœºï¼Œå¹³æ¿ç­‰ç§»åŠ¨è®¾å¤‡ï¼‰åœ¨æµè§ˆé¡µé¢æ—¶ç‰©ç†æ—‹è½¬çš„ä¿¡æ¯ï¼›æ³¨æ„safariæœªå®ç°\n  1 2 3 4 5 6 7 8 9  deviceorientationListener: function(e, t) { if (!(Math.abs(e.rotateDegrees - t.alpha) \u0026lt; 2 || Math.abs(e.leftToRight - t.gamma) \u0026lt; 1 || Math.abs(e.frontToBack - t.beta) \u0026lt; 1)) { e.rotateDegrees = t.alpha, e.frontToBack = t.beta, e.leftToRight = t.gamma; t = t.absolute; return null !== e.rotateDegrees \u0026amp;\u0026amp; null !== e.frontToBack \u0026amp;\u0026amp; null !== e.leftToRight ? [\u0026#34;do\u0026#34;, e.round2(e.rotateDegrees), e.round2(e.frontToBack), e.round2(e.leftToRight), t] : void 0 } },   æ”¶é›†é€»è¾‘ä»¥1åº¦ä¸ºç²¾åº¦ï¼Œè‹¥è¯¯å·®å°äºä¸€åº¦åˆ™ä¸è®°å½•\n  alphaï¼šdoubleï¼›ä¸€ä¸ªè¡¨ç¤ºè®¾å¤‡ç»•zè½´æ—‹è½¬çš„è§’åº¦ï¼ˆèŒƒå›´åœ¨0-360ä¹‹é—´ï¼‰çš„æ•°å­—\n  betaï¼šdoubleï¼šä¸€ä¸ªè¡¨ç¤ºè®¾å¤‡ç»•xè½´æ—‹è½¬ï¼ˆèŒƒå›´åœ¨ï¼180åˆ°180ä¹‹é—´ï¼‰çš„æ•°å­—ï¼Œä»å‰åˆ°åçš„æ–¹å‘ä¸ºæ­£æ–¹å‘\n  gammaï¼šdoubleï¼›ä¸€ä¸ªè¡¨ç¤ºè®¾å¤‡ç»•yè½´æ—‹è½¬ï¼ˆèŒƒå›´åœ¨ï¼90åˆ°90ä¹‹é—´ï¼‰çš„æ•°å­—ï¼Œä»å·¦å‘å³ä¸ºæ­£æ–¹å‘ã€‚\n  absoluteï¼šbooleanï¼›è¡¨ç¤ºè¯¥è®¾å¤‡æ˜¯å¦æä¾›ç»å¯¹å®šä½æ•°æ® (è¿™ä¸ªæ•°æ®æ˜¯å…³äºåœ°çƒçš„åæ ‡ç³») æˆ–è€…ä½¿ç”¨äº†ç”±è®¾å¤‡å†³å®šçš„ä¸“é—¨çš„åæ ‡ç³».\n  devicemotionï¼šå…³äºè®¾å¤‡åœ¨æµè§ˆé¡µé¢æ—¶çš„ä½ç½®å’Œæ–¹å‘çš„æ”¹å˜é€Ÿåº¦çš„ä¿¡æ¯ï¼›åŒæ ·Safariä¸æ”¯æŒ\n  1 2 3 4 5 6 7 8 9  devicemotionListener: function(e, t) { var n = e.round2(t.acceleration.x) , i = e.round2(t.acceleration.y) , e = e.round2(t.acceleration.z) , t = (t.rotationRate, t.interval); if (null !== n \u0026amp;\u0026amp; null !== i \u0026amp;\u0026amp; null !== e \u0026amp;\u0026amp; (1 \u0026lt; Math.abs(n) || 1 \u0026lt; Math.abs(i) || 1 \u0026lt; Math.abs(e))) return [\u0026#34;dm\u0026#34;, n, i, e, t] }    acceleration.x/acceleration.y/acceleration.z: doubleï¼›x, y, zæ–¹å‘ä¸Šçš„åŠ é€Ÿåº¦ä¿¡æ¯ rotationRate.alpha/rotationRate.beta/rotationRate.gamma: doubleï¼›ä¸‰ä¸ªæ–¹å‘ä¸Šæ—‹è½¬çš„åŠ é€Ÿåº¦ä¿¡æ¯ Interval: integerï¼›è¿”å›ä»åº•å±‚ç¡¬ä»¶è·å–æ•°æ®çš„æ—¶é—´é—´éš”ï¼ˆå•ä½ï¼šæ¯«ç§’ï¼‰ã€‚å¯ä»¥ä½¿ç”¨å®ƒæ¥ç¡®å®šè¿åŠ¨äº‹ä»¶çš„ç²’åº¦  å…¶ä»–å…¬å…±ä¿¡æ¯ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  getTimestamp: function() { return \u0026#34;performance\u0026#34;in window \u0026amp;\u0026amp; \u0026#34;now\u0026#34;in window.performance ? this.round(performance.now(), 3) : (new Date).getTime() - 1e3 * this.startedAt }, getPassiveSupported: function() { let t = !1; try { var e = { get passive() { return !(t = !0) } }; window.addEventListener(\u0026#34;test\u0026#34;, null, e), window.removeEventListener(\u0026#34;test\u0026#34;, null, e) } catch (e) { t = !1 } return t },    Timestampï¼šè§¦å‘æ—¶é—´æˆ³ï¼Œå¯ä»¥çœ‹åˆ°æ­¤å¤„ä¼˜å…ˆä½¿ç”¨window.performance.now()å‡½æ•° PassiveSupportedï¼šç”¨äºæ£€æŸ¥addEventlisteneræ—¶æ˜¯å¦æ”¯æŒä½¿ç”¨passiveæ¨¡å¼ï¼šè®¾ç½®ä¸ºtrueæ—¶ï¼Œå¯ä»¥ä¼˜åŒ–æ”¶é›†æ»šå±äº‹ä»¶çš„æ€§èƒ½ï¼Œå¯æŸ¥çœ‹https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#%E4%BD%BF%E7%94%A8_passive_%E6%94%B9%E5%96%84%E7%9A%84%E6%BB%9A%E5%B1%8F%E6%80%A7%E8%83%BD event.isTrustedï¼šbooleanï¼›å½“äº‹ä»¶æ˜¯ç”±ç”¨æˆ·è¡Œä¸ºç”Ÿæˆçš„æ—¶å€™ï¼Œè¿™ä¸ªå±æ€§çš„å€¼ä¸º true ï¼Œè€Œå½“äº‹ä»¶æ˜¯ç”±è„šæœ¬åˆ›å»ºã€ä¿®æ”¹ã€é€šè¿‡ [EventTarget.dispatchEvent()](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent) æ´¾å‘çš„æ—¶å€™ï¼Œè¿™ä¸ªå±æ€§çš„å€¼ä¸º false ã€‚  æ”¶é›† å¼€å§‹recordingï¼š Recordæ¥å£æä¾›å¼€å§‹è¡Œä¸ºè®°å½•æ”¶é›†\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  getFrameHandler: function(n, i) { return function(e) { var t = i(n, e) , e = 1 == e.isTrusted ? 1 : 0 , t = t.concat([e, n.getTimestamp()]); n.frames.push(t), n.pdFlag \u0026amp;\u0026amp; n.frames.length \u0026gt;= n.push_after \u0026amp;\u0026amp; (e = new Event(\u0026#34;musPushData\u0026#34;), window.dispatchEvent(e), n.pdFlag = !1), n.onFrame \u0026amp;\u0026amp; n.onFrame instanceof Function \u0026amp;\u0026amp; n.onFrame(t) } }, record: function() { if (!this.recording) { 0 == this.startedAt \u0026amp;\u0026amp; (this.startedAt = (new Date).getTime() / 1e3), document.scrollingElement \u0026amp;\u0026amp; this.frames.push([\u0026#34;s\u0026#34;, this.round2(document.scrollingElement.scrollLeft), this.round2(document.scrollingElement.scrollTop), this.getTimestamp()]); for (var e = 0; e \u0026lt; this.recordedEvents.length; e++) { var t = this.recordedEvents[e] , n = \u0026#34;scroll\u0026#34; === t , i = null , i = this.onlyWindowEvent.includes(t) \u0026amp;\u0026amp; this.listenNode !== window ? window : this.listenNode; \u0026#34;visibilitychange\u0026#34; === t \u0026amp;\u0026amp; (i = document); var a = this.passiveSupported ? { passive: !0, capture: n } : n , n = this.getFrameHandler(this, this[t + \u0026#34;Listener\u0026#34;]); this.eventListenerParams[t] = [i, t, n, a], i.addEventListener(t, n, a) } this.recording = !0 } },   æœ¬æ®µä»£ç ä¸»è¦ç”¨æ¥é€ä¸€æ³¨å†Œäº‹ä»¶çš„listener(Line27-29):\n è®°å½•å¼€å§‹æ—¶é—´ (Line 15) å½“å¼€å§‹è®°å½•æ—¶ä¼šé¦–å…ˆè®°å½•ä¸€æ¬¡å½“å‰æ»šåŠ¨æ¡çš„ä½ç½®(Line 16) addEventListenerçš„captureè®¾ç½®ä¸ºtrueæ˜¯ç”¨æ¥é˜»æ­¢äº‹ä»¶å‘ä¸Šå†’æ³¡çš„ï¼Œåªæœ‰å¯¹scrollé˜»æ­¢å†’æ³¡ï¼šä¾‹å¦‚é’ˆå¯¹ä¸€ä¸ªiframeå¼€å¯äº†scroll listenerï¼Œè¯¥äº‹ä»¶ä¸ä¼šè§¦å‘windowä¾§scroll listener(Line19) onlyWindowEventä¸»è¦è®°å½•åªæœ‰windowæ‹¥æœ‰çš„äº‹ä»¶ï¼Œç”±äºè¯¥è„šæœ¬æ”¯æŒè®¾ç½®ç›‘å¬DOMä¸­æŸä¸ªnodeçš„eventï¼Œæ‰€ä»¥æ­¤æ—¶è‹¥ç›‘å¬nodeéwindowåˆ™åº”è¯¥å»å¯¹åº”ç›‘å¬windowä¸‹çš„äº‹ä»¶ï¼Œå³è¿è¡Œåˆ°29è¡Œæ—¶ï¼Œi == window(Line 21) ä¼˜å…ˆä½¿ç”¨passiveæ¨¡å¼è¿›è¡Œç›‘å¬(Line 23) ä½¿ç”¨äº†**eventListenerParams**åˆ—è¡¨æ¥ä¿å­˜äº†æ‰€æœ‰ç›‘å¬çš„äº‹ä»¶ï¼Œç”¨äºåç»­stopï¼Œè¯¥æ¡å€¼å¾—å­¦ä¹  Line 4 - 5ï¼Œæ¯æ¬¡æ”¶é›†éƒ½åŒ…å«çš„å…¬å…±ä¿¡æ¯ å¯ä»¥è®¾ç½®push_afteræ¥æ§åˆ¶æ”¶é›†å¤šå°‘æ¡ä¿¡æ¯åè§¦å‘ä¸ŠæŠ¥ï¼Œæ‰€æœ‰æ”¶é›†çš„ä¿¡æ¯æ²¡æœ‰åˆ†ç±»ï¼Œå…¨éƒ¨æ”¾åœ¨frameåˆ—è¡¨ä¸­ï¼›è§¦å‘ä¸ŠæŠ¥çš„æœ¬è´¨æ˜¯é€šè¿‡dispatchEventè§¦å‘ä¸€ä¸ªäº‹ä»¶ï¼Œè¯¥äº‹ä»¶çš„å¤„ç†å‡½æ•°å°†å‘èµ·ä¸ŠæŠ¥ï¼Œåé¢å°†è®²è¿°å…·ä½“è§¦å‘ä¸ŠæŠ¥çš„æ—¶æœº (Line 7) recordingè®¾ç½®ä¸º1ï¼Œè¡¨ç¤ºå¼€å§‹æ•°æ®æ”¶é›†  Stop 1 2 3 4 5 6 7 8  stop: function() { for (var e in this.finishedAt = (new Date).getTime() / 1e3, this.eventListenerParams) { var t = this.eventListenerParams[e]; t[0].removeEventListener(t[1], t[2], t[3]) } this.recording = !1 },   è®°å½•ä¸‹åœæ­¢çš„æ—¶é—´åï¼Œå°†recordæ—¶è®°å½•çš„äº‹ä»¶å…¨éƒ¨removeæ‰ï¼Œrecordingç½®ä¸º0è¡¨ç¤ºå½“å‰æœªæ”¶é›†æ•°æ®\nä¸ŠæŠ¥è§¦å‘æ—¶æœº ä»¥ä¸‹äº‹ä»¶è§¦å‘æ—¶ï¼Œå°†å‘èµ·æ•°æ®ä¸ŠæŠ¥ï¼›å…¶ä¸­\u0026quot;musPushData\u0026quot;äº‹ä»¶å³ä¸ºä¸Šæ–‡æè¿°çš„ä¸»åŠ¨æ§åˆ¶æ”¶é›†å¤šå°‘æ¡æ•°æ®åè¿›è¡Œä¸ŠæŠ¥\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  document.addEventListener(\u0026#34;visibilitychange\u0026#34;, function(e) { \u0026#34;hidden\u0026#34; === document.visibilityState \u0026amp;\u0026amp; (t = !0, i(\u0026#34;vc\u0026#34;)) }), window.addEventListener(\u0026#34;pagehide\u0026#34;, function(e) { !1 === t \u0026amp;\u0026amp; (t = !0, i(\u0026#34;ph\u0026#34;)) }), window.addEventListener(\u0026#34;beforeunload\u0026#34;, function(e) { !1 === t \u0026amp;\u0026amp; (t = !0, i(\u0026#34;bu\u0026#34;)) }), window.addEventListener(\u0026#34;unload\u0026#34;, function(e) { !1 === t \u0026amp;\u0026amp; (t = !0, i(\u0026#34;un\u0026#34;)) }), window.addEventListener(\u0026#34;musPushData\u0026#34;, function(e) { i(\u0026#34;pd\u0026#34;), mus.pdFlag = !0 })   DeviceDataæ”¶é›† è¯¥è„šæœ¬åŒæ ·ä¼šæ”¶é›†å½“å‰æµè§ˆå™¨çš„ä¿¡æ¯ï¼Œæ­¤å¤„åªåˆ—å‡ºéƒ¨åˆ†å€¼å¾—å­¦ä¹ çš„éƒ¨åˆ†\nSayswho ç”¨äºè¯†åˆ«å½“å‰æµè§ˆå™¨åŠå…¶ç‰ˆæœ¬ï¼›é€šå¸¸ä¼šæ³¨å†Œåœ¨navigatorä¸­ï¼Œéæ ‡å‡†æ¥å£ï¼›å‚è€ƒä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  navigator.sayswho= (function(){ var ua= navigator.userAgent, tem, M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\\/))\\/?\\s*(\\d+)/i) || []; if(/trident/i.test(M[1])){ tem= /\\brv[ :]+(\\d+)/g.exec(ua) || []; return \u0026#39;IE \u0026#39;+(tem[1] || \u0026#39;\u0026#39;); } if(M[1]=== \u0026#39;Chrome\u0026#39;){ tem= ua.match(/\\b(OPR|Edge)\\/(\\d+)/); if(tem!= null) return tem.slice(1).join(\u0026#39; \u0026#39;).replace(\u0026#39;OPR\u0026#39;, \u0026#39;Opera\u0026#39;); } M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, \u0026#39;-?\u0026#39;]; if((tem= ua.match(/version\\/(\\d+)/i))!= null) M.splice(1, 1, tem[1]); return M.join(\u0026#39; \u0026#39;); })(); console.log(navigator.sayswho);   æˆ‘ä»¬å¯ä»¥ç”¨æ­¤æ¡å¿«é€Ÿè§£å†³UAè§£æç‰ˆæœ¬çš„é—®é¢˜\nString.prototype.toSourceå¼‚å¸¸æ£€æµ‹ ä¸»æµæµè§ˆå™¨éƒ½ä¼šå‘ç”Ÿå¼‚å¸¸ï¼Œé™¤éæ˜¯ç‰¹åˆ«ä½ç‰ˆæœ¬çš„æµè§ˆå™¨ï¼Œå¯ä»¥å¿«é€Ÿå®šä½ä½ç‰ˆæœ¬æµè§ˆå™¨ï¼Œå‚è€ƒä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  getErrorFF: function() { try { throw \u0026#34;a\u0026#34; } catch (e) { try { return e.toSource(), !0 } catch (e) { return !1 } } },   Audio/Videoè§£ç èƒ½åŠ›æµ‹è¯• åˆ©ç”¨canPlayTypeæ¥å£ï¼Œè‹¥å¤§æ¦‚ç‡å¯ä»¥æ’­æ”¾ï¼Œåˆ™è¿”å›\u0026quot;probably\u0026quot;ï¼Œè‹¥ç¡®å®šæ— èƒ½åŠ›åˆ™è¿”å›ç©ºå­—ç¬¦ä¸²; ä¸åŒçš„ä¸»æµæµè§ˆå™¨åŠç‰ˆæœ¬ä¼šæœ‰æ¯”è¾ƒæ˜¾è‘—çš„ç‰¹æ€§ï¼Œä½ç‰ˆæœ¬æµè§ˆå™¨å°†å…¨éƒ¨ä¸ºç©º\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  audioCodecs: function() { var e = document.createElement(\u0026#34;audio\u0026#34;) , t = {} , n = { ogg: \u0026#39;audio/ogg; codecs=\u0026#34;vorbis\u0026#34;\u0026#39;, mp3: \u0026#34;audio/mpeg;\u0026#34;, wav: \u0026#39;audio/wav; codecs=\u0026#34;1\u0026#34;\u0026#39;, m4a: \u0026#34;audio/x-m4a;\u0026#34;, aac: \u0026#34;audio/aac;\u0026#34; }; if (e.canPlayType) for (var i in n) t[i] = e.canPlayType(n[i]); return t }, videoCodecs: function() { var e = document.createElement(\u0026#34;video\u0026#34;) , t = {} , n = { ogg: \u0026#39;video/ogg; codecs=\u0026#34;theora\u0026#34;\u0026#39;, h264: \u0026#39;video/mp4; codecs=\u0026#34;avc1.42E01E\u0026#34;\u0026#39;, webm: \u0026#39;video/webm; codecs=\u0026#34;vp8, vorbis\u0026#34;\u0026#39;, mpeg4v: \u0026#39;video/mp4; codecs=\u0026#34;mp4v.20.8, mp4a.40.2\u0026#34;\u0026#39;, mpeg4a: \u0026#39;video/mp4; codecs=\u0026#34;mp4v.20.240, mp4a.40.2\u0026#34;\u0026#39;, theora: \u0026#39;video/x-matroska; codecs=\u0026#34;theora, vorbis\u0026#34;\u0026#39; }; if (e.canPlayType) for (var i in n) t[i] = e.canPlayType(n[i]); return t },   window.eval hookæ£€æµ‹ ä¸åŒæµè§ˆå™¨é•¿åº¦ä¼šæœ‰æ‰€ä¸åŒï¼Œfirefoxä¸º37ï¼Œchromeç±»çš„ä¸º33ï¼ŒåŒæ—¶evalä¸­ä¼šåŒ…å«\u0026rsquo;native code\u0026rsquo;å…³é”®å­—\n1  u.deviceData.emptyEvalLength = eval.toString().length   ç½‘ç»œç›¸å…³æ£€æµ‹ ä»…chromeæ”¯æŒï¼Œè·å–ç½‘ç»œç¯å¢ƒä¿¡æ¯\n1 2 3 4 5 6  navigator \u0026amp;\u0026amp; navigator.connection \u0026amp;\u0026amp; (r = navigator.connection, u.deviceData.connection = { effectiveType: r.effectiveType, rtt: r.rtt, downlink: r.downlink })   webAssemblyèƒ½åŠ›æ£€æµ‹ æœ¬æ¡æ˜¯åœ¨æŸ¥é˜…èµ„æ–™è¿‡ç¨‹ä¸­å‘ç°äº†è¿˜æœ‰ç±»ä¼¼åŠŸèƒ½çš„ä¸€ä¸ªå¼€æºé¡¹ç›®friendly challengeï¼šGitHub - FriendlyCaptcha/friendly-challenge: The widget and docs for the proof of work challenge useï¼Œå…¶ä¸­å‘ç°çš„ä¸€ä¸ªæ£€æµ‹ç‚¹ï¼›å…³äºè¯¥é¡¹ç›®ä¸€äº›ç›¸å…³ç‚¹åç»­å¯ä»¥å†æ€»ç»“\næ£€æµ‹æ–¹æ³•å…¶å®æ¯”è¾ƒç®€å•ï¼Œä½¿ç”¨ä¸€ä¸²å¯ä»¥è¢«ç¼–è¯‘çš„å­—ä¸²ï¼Œä½¿ç”¨webAssembly.compileè¿›è¡Œç¼–è¯‘ï¼Œå°è¯•æ•è·å¼‚å¸¸ï¼Œè‹¥æ•è·åˆ™æ£€æµ‹å¤±è´¥ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  const A = WebAssembly.compile(function(A) { const C = A.length; let t = 3 * C \u0026gt;\u0026gt;\u0026gt; 2; A.charCodeAt(C - 1) === I \u0026amp;\u0026amp; t--, A.charCodeAt(C - 2) === I \u0026amp;\u0026amp; t--; const B = new Uint8Array(t); for (let I = 0, t = 0; I \u0026lt; C; I += 4) { const C = g[A.charCodeAt(I + 0)], Q = g[A.charCodeAt(I + 1)], e = g[A.charCodeAt(I + 2)], r = g[A.charCodeAt(I + 3)]; B[t++] = C \u0026lt;\u0026lt; 2 | Q \u0026gt;\u0026gt; 4, B[t++] = (15 \u0026amp; Q) \u0026lt;\u0026lt; 4 | e \u0026gt;\u0026gt; 2, B[t++] = (3 \u0026amp; e) \u0026lt;\u0026lt; 6 | 63 \u0026amp; r } return B }(\u0026#34;ä¸€ä¸ªbase64ç¼–ç çš„å¯ç¼–è¯‘webAssemblyæºç \u0026#34;))   ","description":"Bot Challengeä¸­çš„behavior collectionåˆ†æ","id":4,"section":"posts","tags":["æ£€æµ‹å·¥å…·"],"title":"Bot Challengeä¸­çš„behavior collectionåˆ†æ","uri":"https://summersummer3.github.io/posts/botchallenge/"},{"content":"ARM-V8ä¸Trustzone ARM v8 AArch64æ¶æ„ ç”±ä¸Šå›¾å¯çŸ¥ï¼šARMå¤„ç†å™¨æœ‰ä¸¤ç§çŠ¶æ€ï¼šNormal worldä¸ Secure world; ARMå¤„ç†å™¨æœ‰å››ä¸ªå¼‚å¸¸ç­‰çº§(Exception Level)ï¼šElx (x = 0, 1, 2, 3). ç”±äºel3æ‹¥æœ‰æœ€é«˜æƒé™ï¼Œä¸åŒºåˆ†å®‰å…¨ä¸éå®‰å…¨ï¼Œæ‰€ä»¥ARMå¤„ç†å™¨æ€»å…±æœ‰2 * 4 - 1 = 7ä¸ªçŠ¶æ€\né‡è¦çš„å¯„å­˜å™¨ é€šç”¨å¯„å­˜å™¨ï¼š\nARMv8-Aæä¾›äº†31ä¸ª64ä½çš„é€šç”¨å¯„å­˜å™¨ï¼Œå§‹ç»ˆå¯ä»¥è®¿é—®ï¼Œå¹¶ä¸”å¯ä»¥åœ¨æ‰€æœ‰å¼‚å¸¸çº§åˆ«è®¿é—®ã€‚ åœ¨AArch64æ‰§è¡ŒçŠ¶æ€ä¸‹ï¼Œæ¯ä¸ªå¯„å­˜å™¨ï¼ˆX0-X30ï¼‰éƒ½æ˜¯64ä½å®½åº¦ã€‚ å®½åº¦å¢åŠ æœ‰åŠ©äºå‡å°‘å¤§éƒ¨åˆ†åº”ç”¨ç¨‹åºä¸­çš„å¯„å­˜å™¨å‹åŠ›ã€‚\næ¯ä¸ª64ä½é€šç”¨å¯„å­˜å™¨ï¼ˆX0 - X30ï¼‰ä¹Ÿæœ‰ä¸€ä¸ª32ä½çš„æ ¼å¼ï¼ˆW0 - W30ï¼‰ã€‚\n   Register x åŠŸèƒ½     CPSR - è®°å½•å½“å‰å¤„ç†å™¨çŠ¶æ€:NZCV IFTMâ€¦   SP_ELx 0,1,2,3 æŒ‡å‘å †æ ˆé¡¶éƒ¨çš„æŒ‡é’ˆå¯„å­˜å™¨   ELR_ELx 1,2,3 å¼‚å¸¸é“¾æ¥å¯„å­˜å™¨, ä¿å­˜è¦åœ¨å¼‚å¸¸åè¿”å›çš„åœ°å€   SPSR_ELx 1,2,3 ä¿å­˜çš„å¤„ç†å™¨çŠ¶æ€å¯„å­˜å™¨   VBAR_ELx 1,2,3 åŸºäºå‘é‡çš„åœ°å€å¯„å­˜å™¨, ä¿å­˜å¼‚å¸¸åŸºåœ°å€ä»¥ä¾¿å‘é€åˆ°ELnçš„ä»»ä½•å¼‚å¸¸ã€‚   TTBR0_ELx/TTBR1_ELx 0,1,2,3 ä¿å­˜é¡µè¡¨åŸºåœ°å€   SCR_EL3 - ç”¨äºé…ç½®armæ ¸ä¸Šçš„å®‰å…¨å±æ€§ï¼šå¦‚æŒ‡ç¤ºå½“å‰æ ¸çš„å®‰å…¨çŠ¶æ€NSä½ï¼ŒæŒ‡ç¤ºå½“å‰ä¸­æ–­æˆ–å¼‚å¸¸æ˜¯å¦è·¯ç”±è‡³el3ï¼Œä¸åŒçš„ä¸­æ–­å°†ä½¿ç”¨ä¸åŒä½æ®µè¡¨ç¤ºï¼šhttps://developer.arm.com/documentation/ddi0595/2021-06/AArch64-Registers/SCR-EL3\u0026ndash;Secure-Configuration-Register    å¼‚å¸¸ç­‰çº§åˆ‡æ¢ ç³»ç»Ÿè°ƒç”¨å¼‚å¸¸ï¼šSVC, HVC, or SMC (vbar_elx, spsr_elx)\nSVCé€šå¸¸è¢«EL0ï¼ˆuser modeï¼‰çš„è½¯ä»¶ç”¨æ¥ç”³è¯· æ“ä½œç³»ç»Ÿä¸ŠEL1ï¼ˆOS serviceï¼‰è¯·æ±‚ç‰¹æƒæ“ä½œæˆ–è®¿é—®ç³»ç»Ÿèµ„æºã€‚\nHVCä¸»è¦è¢«guest OSç”¨æ¥è¯·æ±‚hypervisorçš„æœåŠ¡;\nSMCè¡¨ç¤º: Secure monitor Call, ç”¨äºsecureä¸non-secureåˆ‡æ¢, æœ¬è´¨æ˜¯é€šè¿‡ä¿å­˜ä¸¤ä¸ªä¸–ç•Œçš„å¯„å­˜å™¨ä¸Šä¸‹æ–‡ä¿¡æ¯åï¼Œè®¾ç½®scr_el3.NSä½æ¥å®Œæˆä¸–ç•Œçš„åˆ‡æ¢ï¼šï¼š\né«˜å¼‚å¸¸ç­‰çº§-\u0026gt;ä½å¼‚å¸¸ç­‰çº§ï¼šERET (elr_elx, cpsr)\nTrustzoneä¸TEE GP(Glabol Platform)æ ‡å‡†ä¸‹çš„TEE GPè§„èŒƒåŒ–å®šä¹‰äº†ä¸€ä¸ªTrustzoneä¸‹TEEè½¯ä»¶ä¸ç¡¬ä»¶æ¶æ„ã€‚ç”¨ç™½è¯è¯´å°±æ˜¯ä¸€æ•´å¥—TEEæ ‡å‡†åŒ–çš„ä¼—å¤šè§„åˆ™ï¼Œæœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸ºäº†ä¿è¯å®‰å…¨åº”ç”¨è°ƒç”¨çš„æ¥å£å‘½åä¸€è‡´ï¼Œä¿æŒå¯ç§»æ¤æ€§ã€‚\n å¯¹äºCA/TAå¼€å‘è€…æ¥è¯´ï¼Œæˆ‘ä»¬ä¸»è¦éœ€è¦åœ¨CAä¾§è°ƒç”¨å¯¹åº”æ¥å£ï¼Œåœ¨TAä¾§å®ç°å¯¹åº”æ¥å£ï¼Œä»¥æ‰“é€šCAä¸TAçš„äº¤äº’session.\nCAä¾§è°ƒç”¨ï¼š  TEEC_InitializeContext TEEC_FinalizeContext TEEC_RegisterSharedMemory TEEC_AllocateSharedMemory TEEC_ReleaseSharedMemory TEEC_OpenSession TEEC_CloseSession TEEC_InvokeCommand TEEC_RequestCancellation TAä¾§å®ç°ï¼š\nTA_CreateEntryPoint TA_DestroyEntryPoint TA_InvokeCommandEntryPoint TA_OpenSessionEntryPoint  å¯¹äºTEE_OSå¼€å‘è€…æ¥è¯´ï¼Œåˆ™éœ€è¦çš„å®ç°GPè§„å®šä¸‹çš„å„ç§componentï¼Œä¹Ÿå¿…é¡»å®ç°å¯¹åº”å’ŒTAäº¤äº’çš„APIï¼Œæ–¹ä¾¿TAçš„ç§»æ¤ã€‚è¿™ä¸ªæ¯”è¾ƒå¤šå°±ä¸åœ¨è¿™é‡Œåˆ—ä¸¾ï¼Œå¯ä»¥å‚è€ƒå®˜æ–¹ç½‘ç«™ ï¼šhttps://globalplatform.org/specs-library/?filter-committee=tee  ç¡¬ä»¶åŸºç¡€ï¼š   åœ¨æ”¯æŒtrustzoneæŠ€æœ¯çš„å¾®å¤„ç†å™¨ä¸­ï¼ŒAMRå®ç°äº†å¯¹cortexçš„è™šæ‹ŸåŒ–ï¼Œå°†æ¯ä¸ªç‰©ç†çš„å¤„ç†å™¨è™šæ‹ŸåŒ–æˆä¸¤ä¸ªè™šæ‹Ÿæ ¸ï¼Œä¸€ä¸ªä¸ºå®‰å…¨æ ¸ï¼Œä¸€ä¸ªæ™®é€šå®‰å…¨æ ¸ï¼Œä¹Ÿå°±æ˜¯ä¸€ä¸ªç‰©ç†æ ¸å­˜åœ¨secure wroldæ€å’Œnormal worldæ€ã€‚\n  AXIæ€»çº¿ä¸ŠNSä½çš„æ‰©å±•ï¼šåœ¨åŸæœ‰çš„AXIåŸºç¡€ä¸Šå¯¹æ¯ä¸€ä¸ªè¯»å†™ä¿¡é“å¢åŠ äº†ä¸€ä¸ªé¢å¤–çš„æ§åˆ¶ä¿¡å·ï¼Œç”¨æ¥è¡¨ç¤ºå½“å‰çš„è¯»å†™æ“ä½œæ˜¯å®‰å…¨æ“ä½œè¿˜æ˜¯éå®‰å…¨æ“ä½œï¼Œè¢«ç§°ä¸ºNSä½æˆ–è€…Non-Secureä½ã€‚å½“NSä½ä¿¡å·ä¸º1æ—¶ï¼Œæ‹’ç»è®¿é—®å®‰å…¨èµ„æº\n  å…¶ä»–æ”¯æŒ\n   Secure bootromï¼šå¯åŠ¨çš„romï¼Œå­˜å‚¨å®‰å…¨å¯åŠ¨ä»£ç  TZASCç»„ä»¶(Trustzone Address Space Controller)ï¼šé…ç½®æ‰€æœ‰è®¾å¤‡åœ°å€çš„å®‰å…¨å±æ€§ TZMAç»„ä»¶(Trustzone Memory Adapter)ï¼šé…ç½®ç‰‡ä¸Šé™æ€ramåœ°å€çš„å®‰å…¨å±æ€§ TZPCç»„ä»¶(Trustzone Protection Controller)ï¼šç¡®å®šå¤–éƒ¨è®¾å¤‡çš„å‘é€çš„ä¿¡å·å®‰å…¨å±æ€§ TZICç»„ä»¶ï¼ˆTrustzone Interrupt Controllerï¼‰ï¼šé…ç½®ä¸­æ–­çš„å®‰å…¨å±æ€§(CPUå¤„äºå®‰å…¨æ€æ—¶ï¼Œä¸­æ–­ä¸ºå®‰å…¨ä¸­æ–­) MMUçš„æ‰©å±•ï¼šä¹Ÿå°±æ˜¯æ¯ä¸ªä¸–ç•Œéƒ½å…·æœ‰å•ç‹¬çš„MMUé¡µè¡¨ã€‚å­˜æ”¾åœ¨MMUä¸­çš„æ¯ä¸€æ¡é¡µè¡¨æè¿°ç¬¦éƒ½ä¼šåŒ…å«ä¸€ä¸ªNSä½æ¥è¡¨ç¤ºè¢«æ˜ å°„çš„å†…å­˜å®‰å…¨å±æ€§ã€‚ Cacheçš„æ‰©å±•**ï¼š**åœ¨cacheä¸­çš„æ¯ä¸€é¡¹éƒ½ä¼šæŒ‰ç…§normal worldå’Œsecure worldçš„çŠ¶æ€æ‰“ä¸Šå¯¹åº”çš„tagï¼Œè¿™å°±èƒ½å®ç°åœ¨ä¸åŒçš„worldä¸‹é¢ï¼Œå¤„ç†å™¨åªè¦å±æ€§è‡ªå·±worldçš„cacheå°±å¯ä»¥äº†ã€‚  ARM TEEè½¯ä»¶æ¶æ„ï¼š ä¸‹é¢æ˜¯GPæ ‡å‡†ä¸‹ï¼ŒTEEè½¯ä»¶æ¶æ„å›¾ï¼Œå¯¹åº”opteeä¸­çš„ç»„ä»¶å\n TEE Cilent API: æä¾›ç»™éå®‰å…¨ç”¨æˆ·æ€åº”ç”¨è°ƒç”¨TAçš„æ¥å£ï¼Œå°†å‚æ•°ä¸‹æ²‰è‡³teeå†…æ ¸é©±åŠ¨ï¼›åœ¨opteeä¸­ä½libteec.so TEE protocol Specs: æ¥å—æ¥è‡ªtee-driverçš„å‘½ä»¤å®Œæˆéœ€è¦åœ¨el0æ‰èƒ½è¿›è¡Œçš„å·¥ä½œï¼šå¦‚æ–‡ä»¶åŠ è½½çš„ï¼›åœ¨opteeä¸­ä¸ºtee-supplicantï¼Œæ˜¯ä¸€ä¸ªåå°è¿›ç¨‹ Driver \u0026amp; REE Communication Agent 1.ç®¡ç†éå®‰å…¨ç›¸å…³è®¾å¤‡ä»¥åŠä¸å®‰å…¨ä¸–ç•Œé€šä¿¡çš„å…±äº«å†…å­˜; 2.éå®‰å…¨ä¸–ç•Œrpcé€šä¿¡çš„ç«¯ç‚¹; 3.è§¦å‘smcå¼‚å¸¸ï¼Œä½¿armæ ¸è¿›å…¥å®‰å…¨æ€. åœ¨opteeä¸­ä¸ºtee-driver.koï¼ˆç›®å‰å·²é»˜è®¤é›†æˆåœ¨linux kernelä¸­ï¼‰ ATF runtime: ä¿å­˜éå®‰å…¨ä¸–ç•Œcpuä¸Šä¸‹æ–‡ï¼Œæ¢å¤å®‰å…¨ä¸–ç•Œä¸Šä¸‹æ–‡ï¼Œè°ƒç”¨eret å°†cpué€€å›sel1. Trusted OS Componentï¼šå³è¿è¡Œåœ¨å®‰å…¨ä¸–ç•Œçš„OSç»„ä»¶ï¼ŒåŠŸèƒ½åœ¨ä¸æ–­æ‰©å±•ï¼Œåœ¨opteeåˆ™ä¸ºopteeç¼–è¯‘å¥½çš„é•œåƒï¼Œé€šå¸¸ä¸ºtee.bin TEE Internal Core APIï¼šé€šå¸¸ä¸ºä¸€ä¸ªç”¨äºå®‰å…¨åº”ç”¨ç¼–è¯‘æ—¶çš„SDKï¼Œopteeä¸­æœ‰ä¸€ä¸ªsdkæ–‡ä»¶å¤¹ï¼Œå¯ä»¥å‚è€ƒå…¶å®‰å…¨åº”ç”¨ç¼–è¯‘æ–‡æ¡£ TA (Trusted App)ï¼šè¿è¡Œåœ¨éš”ç¦»ç¯å¢ƒä¸‹çš„å®‰å…¨åº”ç”¨  æ‰€ä»¥TEEæ˜¯å•¥ TEE (Trusted Execution Environment):\nåœ¨ARMä¸‹ï¼Œç”±ä¸Šè¿°Trustzoneç¡¬ä»¶åŸºç¡€ä¸è½¯ä»¶ç»„ä»¶å…±åŒæ„å»ºçš„ä¸€ä¸ªä¸éå®‰å…¨ä¸–ç•Œéš”ç¦»çš„å¯ä¿¡ç¨‹åºè¿è¡Œç¯å¢ƒã€‚\né™¤äº†Trustzoneä¹‹å¤–ï¼Œå…¶ä»–çš„ç¡¬ä»¶å¹³å°ä¸Šçš„TEEæœ‰ä»¥ä¸‹çŸ¥åç¯å¢ƒï¼š\nIntel SGX/AMD Secure Execution Environment/RISC-V MultiZoneâ€¦\noptee ä¸ºä»€ä¹ˆé€‰æ‹©optee å…ˆçœ‹opteeå®˜æ–¹æ˜¯æ€ä¹ˆç»™è‡ªå·±å®šä¹‰çš„ï¼š\n OP-TEE is a Trusted Execution Environment (TEE) designed as companion to a non-secure Linux kernel running on Arm; Cortex-A cores using the TrustZone technology. OP-TEE implements TEE Internal Core API v1.1.x which is the API exposed to Trusted Applications and the TEE Client API v1.0, which is the API describing how to communicate with a TEE. Those APIs are defined in the GlobalPlatform API specifications.\nThe main design goals for OP-TEE are:\n  Isolation - the TEE provides isolation from the non-secure OS and protects the loaded Trusted Applications (TAs) from each other using underlying hardware support, Small footprint - the TEE should remain small enough to reside in a reasonable amount of on-chip memory as found on Arm based systems, Portability - the TEE aims at being easily pluggable to different architectures and available HW and has to support various setups such as multiple client OSes or multiple TEEs    åœ¨æˆ‘çœ‹æ¥é€‰æ‹©è¿™ä¸ªé¡¹ç›®ä½œä¸ºTEEå­¦ä¹ æ›´ä¸»è¦çš„åŸå› æ˜¯ï¼šå¼€æºã€‚å¤§éƒ¨åˆ†TEEè¿‡äºå°é—­ï¼Œå¾ˆéš¾å»çª¥æ¢trustzoneé‡Œå¥¥ç§˜ï¼Œopteeæ˜¯ä¸€ä¸ªæ‰€æœ‰ç»„ä»¶éƒ½å®Œå…¨å¼€æºçš„é¡¹ç›®ï¼Œç”±linaroä¸»å¯¼å¹¶ç»´æŠ¤ï¼Œç¤¾åŒºæ´»è·ƒåº¦ä¹Ÿå¾ˆé«˜ï¼Œä»…ä¸€å¹´å·¦å³æ—¶é—´æ›´æ–°5ä¸ªå¤§ç‰ˆæœ¬\nå‚è€ƒèµ„æ–™ æºç  optee_os: https://github.com/OP-TEE/optee_os\noptee_client: https://github.com/OP-TEE/optee_client\nteeé©±åŠ¨é»˜è®¤åœ¨linuxå†…æ ¸ä¸­, æ›´æ–°åœ¨è¿™: https://github.com/linaro-swg/linux/tree/optee\nä¸­æ–‡èµ„æ–™ä¹¦ç± ã€Šæ‰‹æœºå®‰å…¨å’Œå¯ä¿¡åº”ç”¨å¼€å‘æŒ‡å—:TrustZoneä¸OP-TEEæŠ€æœ¯è¯¦è§£ã€‹\nä½œè€…åšå®¢ï¼šhttps://blog.csdn.net/shuaifengyun  OPTEE Core æ¶æ„å‚è€ƒ Architecture â€’ OP-TEE documentation documentation\næœ¬æ–‡ä¸ä»‹ç»optee osçš„å…·ä½“æ¶æ„ï¼Œè€Œæ˜¯é€šè¿‡ä¸€ä¸ªç»å…¸çš„ä¾‹å­æ¥åˆ†æopteeä¸­ä¸€ä¸ªå®Œæ•´çš„è¯·æ±‚æ˜¯å¦‚ä½•ä»éå®‰å…¨ä¸–ç•Œçš„appå‘é€åˆ°å®‰å…¨åº”ç”¨taï¼Œå¹¶å®ŒæˆåŠŸèƒ½è°ƒç”¨çš„ï¼Œlinaroå®˜æ–¹çš„exampleä»“ï¼Œæœ‰è®¸å¤šåŠŸèƒ½è°ƒç”¨çš„ä¾‹å­ï¼šhttps://github.com/linaro-swg/optee_examples\næœ¬æ–‡å°±ä»¥æœ€ç®€å•çš„hello_worldä¸ºä¾‹å­\nCA-\u0026gt;TA CAæ˜¯è°ƒç”¨TEEå®‰å…¨æœåŠ¡çš„å…¥å£ç¨‹åºï¼Œè¿è¡Œåœ¨éå®‰å…¨ç”¨æˆ·æ€el0ã€‚\nTAæ˜¯TEEæœåŠ¡çš„é‡ç‚¹ï¼Œå¤§éƒ¨åˆ†è‡ªå®šä¹‰çš„å®‰å…¨æœåŠ¡åœ¨TAä¸­å®ç°ï¼Œè¿è¡Œåœ¨å®‰å…¨ç”¨æˆ·æ€SEL0.\nä»CAåˆ°TAçš„invoke commandï¼Œå®Œæˆä¸€æ¬¡æœåŠ¡è°ƒç”¨ï¼Œå°†ä¼šç»å†ä¸€ä¸ªæ¼«é•¿çš„å±‚çº§åŠCPUå®‰å…¨æ€åˆ‡æ¢ï¼Œé€šå¸¸çš„é€šè·¯å¦‚ä¸‹ï¼š\n(é“¾æ¥)\t(ioctl) (smcæŒ‡ä»¤)\t(el3 eret sel1) (sel1 eret)  CA========\u0026gt;libteec.so=======\u0026gt;tee_driver=========\u0026gt;ATF==========\u0026gt;TEE_kernel==========\u0026gt;TA\nè‹¥TEE/TAæœåŠ¡æœ‰éƒ¨åˆ†å·¥ä½œéœ€è¦è¿”å›éå®‰å…¨æ€æ‰§è¡Œï¼Œåˆ™éœ€è¦è¿”å›tee_driverå‘¼å«éå®‰å…¨ä¾§å®ˆæŠ¤è¿›ç¨‹tee_supplicantå»å®Œæˆå·¥ä½œï¼š\nTA/TEE_kernel====\u0026gt;ATF====\u0026gt;tee_driver====\u0026gt;tee_supplicant\nç”±äºATFä¸»è¦å·¥ä½œæ˜¯åœ¨å¯åŠ¨é˜¶æ®µå®Œæˆï¼Œè¿è¡Œæ€æ—¶ä¸»è¦ç”¨äºåˆ‡æ¢CPUå®‰å…¨/éå®‰å…¨çŠ¶æ€ï¼Œä¿å­˜/æ¢å¤å½¼æ­¤çš„å¯„å­˜å™¨çŠ¶æ€ä¸Šä¸‹æ–‡ï¼Œä¸åœ¨æ­¤å¤„ç»†èŠã€‚ä¸‹é¢æˆ‘ä»¬å°†é€šè¿‡ä¸€æ¬¡TAåŠ è½½è¿‡ç¨‹çš„æ•°æ®æµæ¥ç»†è®²æ¯ä¸€ä¸ªç»„ä»¶çš„ä¸»è¦åŠŸèƒ½ã€‚\nCA éå®‰å…¨ç”¨æˆ·æ€ç¨‹åºï¼ŒåŠ¨æ€é“¾æ¥libteec.soï¼Œè°ƒç”¨å…¶æ¥å£ã€‚CAæ˜¯è°ƒç”¨å®‰å…¨ä¸–ç•ŒTAæœåŠ¡çš„èµ·ç‚¹ã€‚\nlinaroå®˜æ–¹çš„exampleä»“ï¼Œæœ‰è®¸å¤šåŠŸèƒ½è°ƒç”¨çš„ä¾‹å­ï¼š\nhttps://github.com/linaro-swg/optee_examples\nç®€å•çœ‹ä¸€ä¸‹hello_world:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  #define TA_HELLO_WORLD_UUID \\ { 0x8aaaf200, 0x2450, 0x11e4, \\ { 0xab, 0xe2, 0x00, 0x02, 0xa5, 0xd5, 0xc5, 0x1b} }  int main(void) { TEEC_Result res; TEEC_Context ctx; TEEC_Session sess; TEEC_Operation op; TEEC_UUID uuid = TA_HELLO_WORLD_UUID; uint32_t err_origin; /* Initialize a context connecting us to the TEE */ res = TEEC_InitializeContext(NULL, \u0026amp;ctx); if (res != TEEC_SUCCESS) errx(1, \u0026#34;TEEC_InitializeContext failed with code 0x%x\u0026#34;, res); /* * Open a session to the \u0026#34;hello world\u0026#34; TA, the TA will print \u0026#34;hello * world!\u0026#34; in the log when the session is created. */ res = TEEC_OpenSession(\u0026amp;ctx, \u0026amp;sess, \u0026amp;uuid, TEEC_LOGIN_PUBLIC, NULL, NULL, \u0026amp;err_origin); if (res != TEEC_SUCCESS) errx(1, \u0026#34;TEEC_Opensession failed with code 0x%x origin 0x%x\u0026#34;, res, err_origin); /* * Execute a function in the TA by invoking it, in this case * we\u0026#39;re incrementing a number. * * The value of command ID part and how the parameters are * interpreted is part of the interface provided by the TA. */ /* Clear the TEEC_Operation struct */ memset(\u0026amp;op, 0, sizeof(op)); /* * Prepare the argument. Pass a value in the first parameter, * the remaining three parameters are unused. */ op.paramTypes = TEEC_PARAM_TYPES(TEEC_VALUE_INOUT, TEEC_NONE, TEEC_NONE, TEEC_NONE); op.params[0].value.a = 42; /* * TA_HELLO_WORLD_CMD_INC_VALUE is the actual function in the TA to be * called. */ printf(\u0026#34;Invoking TA to increment %d\\n\u0026#34;, op.params[0].value.a); res = TEEC_InvokeCommand(\u0026amp;sess, TA_HELLO_WORLD_CMD_INC_VALUE, \u0026amp;op, \u0026amp;err_origin); if (res != TEEC_SUCCESS) errx(1, \u0026#34;TEEC_InvokeCommand failed with code 0x%x origin 0x%x\u0026#34;, res, err_origin); printf(\u0026#34;TA incremented value to %d\\n\u0026#34;, op.params[0].value.a); /* * We\u0026#39;re done with the TA, close the session and * destroy the context. * * The TA will print \u0026#34;Goodbye!\u0026#34; in the log when the * session is closed. */ TEEC_CloseSession(\u0026amp;sess); TEEC_FinalizeContext(\u0026amp;ctx); return 0; }   libteec.so(el0) libteec.soä¸­åŒ…å«äº†GPæ ‡å‡†ä¸‹æä¾›çš„äº”ä¸ªä¾›CAè°ƒç”¨ä¸TAé€šè®¯çš„æ¥å£ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  TEEC_Result TEEC_InitializeContext( const char* name, TEEC_Context* context) void TEEC_FinalizeContext( TEEC_Context* context) TEEC_Result TEEC_OpenSession ( TEEC_Context* context, TEEC_Session* session, const TEEC_UUID* destination, uint32_t connectionMethod, const void* connectionData, TEEC_Operation* operation, uint32_t* returnOrigin) void TEEC_CloseSession ( TEEC_Session* session) TEEC_Result TEEC_InvokeCommand( TEEC_Session* session, uint32_t commandID, TEEC_Operation* operation, uint32_t* returnOrigin)   å¯ä»¥çœ‹åˆ°æˆå¯¹å‡ºç°çš„ctxå’Œsessionæ“ä½œä»¥åŠæœåŠ¡è°ƒç”¨çš„TEEC_InvokeCommandã€‚\nè°ƒç”¨TEEä¸­TAçš„æœåŠ¡ç¬¬ä¸€æ­¥æ˜¯æ‰“å¼€TEEé©±åŠ¨ï¼šå¯ä»¥çœ‹åˆ°TEEC_InitializeContextæ“ä½œæ˜¯å¾ˆç®€å•çš„ï¼Œå°è¯•å»æ‰“å¼€tee_driverçš„å­—ç¬¦è®¾å¤‡ï¼Œteecçš„ä¸Šä¸‹æ–‡ä¸­å°†é©±åŠ¨çš„æè¿°ç¬¦å­˜ä¸‹æ¥ï¼Œä¾›åç»­ä½¿ç”¨; å¹¶æŸ¥è¯¢äº†ä¸€äº›é©±åŠ¨ä¸­ä¿å­˜çš„TEE_OSçš„ä¸€äº›ç‰ˆæœ¬ä¿¡æ¯.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  TEEC_Result TEEC_InitializeContext(const char *name, TEEC_Context *ctx) { char devname[PATH_MAX] = { 0 }; int fd = 0; size_t n = 0; if (!ctx) return TEEC_ERROR_BAD_PARAMETERS; for (n = 0; n \u0026lt; TEEC_MAX_DEV_SEQ; n++) { uint32_t gen_caps = 0; snprintf(devname, sizeof(devname), \u0026#34;/dev/tee%zu\u0026#34;, n); //é€šå¸¸teeé©±åŠ¨åªä¼šåˆ›å»ºä¸€ä¸ªè®¾å¤‡ï¼Œè‡ªå®šä¹‰æ¡ä»¶ä¸‹å¯èƒ½æœ‰å¤šä¸ªè®¾å¤‡ã€‚ \tfd = teec_open_dev(devname, name, \u0026amp;gen_caps);//å°è¯•å»æ‰“å¼€tee_driverçš„é©±åŠ¨ \tif (fd \u0026gt;= 0) { ctx-\u0026gt;fd = fd; //å°†è®¾å¤‡çš„æ–‡ä»¶æè¿°ç¬¦å­˜å‚¨åœ¨ä¸Šä¸‹æ–‡ä¸­ \tctx-\u0026gt;reg_mem = gen_caps \u0026amp; TEE_GEN_CAP_REG_MEM; //reg_mem TEEçŠ¶æ€ åŠ¨æ€æ³¨å†Œå…±äº«å†…å­˜ \tctx-\u0026gt;memref_null = gen_caps \u0026amp; TEE_GEN_CAP_MEMREF_NULL; return TEEC_SUCCESS; } } return TEEC_ERROR_ITEM_NOT_FOUND; } static int teec_open_dev(const char *devname, const char *capabilities, uint32_t *gen_caps) { int fd = 0; struct tee_ioctl_version_data vers; memset(\u0026amp;vers, 0, sizeof(vers)); fd = open(devname, O_RDWR); if (fd \u0026lt; 0) return -1; if (ioctl(fd, TEE_IOC_VERSION, \u0026amp;vers)) { EMSG(\u0026#34;TEE_IOC_VERSION failed\u0026#34;); goto err; } /* We can only handle GP TEEs */ if (!(vers.gen_caps \u0026amp; TEE_GEN_CAP_GP)) goto err; ... }   TEEC_OpenSessionæä¾›äº†ä»æ–‡ä»¶ç³»ç»ŸåŠ è½½TAåˆ°TEEä¸­ï¼Œå¹¶æ‰“å¼€TA-CAçš„å®‰å…¨é€šé“sessionçš„åŠŸèƒ½ã€‚\nlibteecé€šè¿‡ç»“æ„ä½“tee_ioctl_open_session_argå’Œtee_ioctl_paramä¼ é€’sessionçš„ä¿¡æ¯\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  struct tee_ioctl_open_session_arg { __u8 uuid[TEE_IOCTL_UUID_LEN]; __u8 clnt_uuid[TEE_IOCTL_UUID_LEN]; __u32 clnt_login; __u32 cancel_id; __u32 session; __u32 ret; __u32 ret_origin; __u32 num_params; } __aligned(8); struct tee_ioctl_param_memref { __u64 shm_offs; __u64 size; __s64 shm_id; }; struct tee_ioctl_param_value { __u64 a; __u64 b; __u64 c; }; struct tee_ioctl_param { __u64 attr; union { struct tee_ioctl_param_memref memref; struct tee_ioctl_param_value value; } u; };   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71  /* optee_client/libteec/src/tee_client_api.c */ TEEC_Result TEEC_OpenSession(TEEC_Context *ctx, TEEC_Session *session, const TEEC_UUID *destination, uint32_t connection_method, const void *connection_data, TEEC_Operation *operation, uint32_t *ret_origin) { struct tee_ioctl_open_session_arg *arg = NULL; struct tee_ioctl_param *params = NULL; TEEC_Result res = TEEC_ERROR_GENERIC; uint32_t eorig = 0; int rc = 0; const size_t arg_size = sizeof(struct tee_ioctl_open_session_arg) + TEEC_CONFIG_PAYLOAD_REF_COUNT * sizeof(struct tee_ioctl_param); union { struct tee_ioctl_open_session_arg arg; uint8_t data[arg_size]; } buf; struct tee_ioctl_buf_data buf_data; TEEC_SharedMemory shm[TEEC_CONFIG_PAYLOAD_REF_COUNT]; //å½“teecè¾“å…¥çš„operationçš„paramä¸­å«æœ‰æ•°æ®æµbufferæ—¶ï¼Œéœ€è¦ç”³è¯·å°†bufferæ‹·è´åˆ°ä¸€å—æœ‰teeé©±åŠ¨ç”³è¯·çš„å®‰å…¨ä¸éå®‰å…¨äº¤äº’çš„share_memoryã€‚  memset(\u0026amp;buf, 0, sizeof(buf)); memset(\u0026amp;shm, 0, sizeof(shm)); memset(\u0026amp;buf_data, 0, sizeof(buf_data)); (void)\u0026amp;connection_data; if (!ctx || !session) { eorig = TEEC_ORIGIN_API; res = TEEC_ERROR_BAD_PARAMETERS; goto out; } buf_data.buf_ptr = (uintptr_t)\u0026amp;buf; buf_data.buf_len = sizeof(buf); arg = \u0026amp;buf.arg; arg-\u0026gt;num_params = TEEC_CONFIG_PAYLOAD_REF_COUNT; params = (struct tee_ioctl_param *)(arg + 1); uuid_to_octets(arg-\u0026gt;uuid, destination); arg-\u0026gt;clnt_login = connection_method; res = teec_pre_process_operation(ctx, operation, params, shm); //æ­¤å¤„å®Œæˆshare_memoryä»å†…æ ¸åˆ°ç”¨æˆ·æ€çš„æ˜ å°„ä»¥åŠæ•°æ®æµçš„æ‹·è´ \tif (res != TEEC_SUCCESS) { eorig = TEEC_ORIGIN_API; goto out_free_temp_refs; } rc = ioctl(ctx-\u0026gt;fd, TEE_IOC_OPEN_SESSION, \u0026amp;buf_data); //è¿›å…¥é©±åŠ¨ioctlå‡½æ•°,cmdå†³å®šäº† \tif (rc) { EMSG(\u0026#34;TEE_IOC_OPEN_SESSION failed\u0026#34;); eorig = TEEC_ORIGIN_COMMS; res = ioctl_errno_to_res(errno); goto out_free_temp_refs; } res = arg-\u0026gt;ret; //é©±åŠ¨å›å†™çš„è¿”å›å€¼ \teorig = arg-\u0026gt;ret_origin; if (res == TEEC_SUCCESS) { session-\u0026gt;ctx = ctx; session-\u0026gt;session_id = arg-\u0026gt;session; } teec_post_process_operation(operation, params, shm); out_free_temp_refs: teec_free_temp_refs(operation, shm); out: if (ret_origin) *ret_origin = eorig; return res; }   æ­¤å¤„ä¸»è¦æ˜¯å°†open_sessionç”¨æˆ·æ€å…¥å‚ç»“æ„ä½“åˆå§‹åŒ–å¹¶é€šè¿‡ioctlä¼ å…¥å†…æ ¸ä¸­, æ³¨æ„æ­¤å¤„å…³é”®å‡½æ•°teec_pre_process_operationï¼Œæ³¨é‡Šä¸­æœ‰æè¿°å¤§æ¦‚çš„åŠŸèƒ½ã€‚åæ–‡ä¸­å…±äº«å†…å­˜éƒ½æŒ‡å®‰å…¨ä¸éå®‰å…¨äº¤äº’çš„share_memoryã€‚æˆ‘ä»¬ä¸»è¦æŸ¥çœ‹å¯¹ç”¨æˆ·æ€bufferçš„å¤„ç†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100  static TEEC_Result teec_pre_process_operation(TEEC_Context *ctx, TEEC_Operation *operation, struct tee_ioctl_param *params, TEEC_SharedMemory *shms) { TEEC_Result res = TEEC_ERROR_GENERIC; size_t n = 0; memset(shms, 0, sizeof(TEEC_SharedMemory) * TEEC_CONFIG_PAYLOAD_REF_COUNT); ... for (n = 0; n \u0026lt; TEEC_CONFIG_PAYLOAD_REF_COUNT; n++) { uint32_t param_type = 0; /* éå†æ“ä½œä¸­çš„params */ param_type = TEEC_PARAM_TYPE_GET(operation-\u0026gt;paramTypes, n); switch (param_type) { ... /* in_bufferä¸­æœ‰ä¸¤ç§ç±»å‹ï¼Œtmprefæ˜¯è¿˜æ²¡å†™è¿›share_memoryçš„buffer */ case TEEC_MEMREF_TEMP_INPUT: case TEEC_MEMREF_TEMP_OUTPUT: case TEEC_MEMREF_TEMP_INOUT: res = teec_pre_process_tmpref(ctx, param_type, \u0026amp;operation-\u0026gt;params[n].tmpref, params + n, shms + n); //ä¸»è¦å…³å¿ƒçš„æ˜¯å¯¹temrefå¤„ç†ï¼Œè§ä¸‹é¢å®ç° \tif (res != TEEC_SUCCESS) return res; break; /* memreféœ€è¦å…ˆç”³è¯·ä¸€å—share_memoryï¼Œåœ¨CAä¸­å°±ç›´æ¥å†™å…¥å…±äº«å†…å­˜ */ /* åœ¨CAç”³è¯·å…±äº«å†…å­˜æœ‰ä¸¤ç§æ–¹å¼ 1. TEEC_AllocateSharedMemory è‹¥ä¸Šä¸‹æ–‡ä¸­reg_memä¸ºtrueåˆ™å°†ç”³è¯·ä¸€å—æ–°å†…å­˜ï¼Œæ³¨å†Œè¿›å†…æ ¸ä½œä¸ºæ–°å¢çš„å…±äº«å†…å­˜ã€‚ å¦åˆ™å°†ä»mmapä¸€å—å†…æ ¸ä¸­çš„å…±äº«å†…å­˜ï¼Œä¾›CAä½¿ç”¨ã€‚ 2. TEEC_RegisterSharedMemory ä¸TEEC_AllocateSharedMemoryåŸºæœ¬ä¸€æ ·ï¼ŒåŒºåˆ«åœ¨äºæ­¤æ—¶æ³¨å†Œçš„è¿›å…±äº«å†…å­˜éœ€è¦åœ¨å¤–é¢ç”³è¯·å¥½ã€‚ */ case TEEC_MEMREF_WHOLE: res = teec_pre_process_whole( \u0026amp;operation-\u0026gt;params[n].memref, params + n); if (res != TEEC_SUCCESS) return res; break; case TEEC_MEMREF_PARTIAL_INPUT: case TEEC_MEMREF_PARTIAL_OUTPUT: case TEEC_MEMREF_PARTIAL_INOUT: res = teec_pre_process_partial(param_type, \u0026amp;operation-\u0026gt;params[n].memref, params + n); if (res != TEEC_SUCCESS) return res; break; default: return TEEC_ERROR_BAD_PARAMETERS; } } return TEEC_SUCCESS; } static TEEC_Result teec_pre_process_tmpref(TEEC_Context *ctx, uint32_t param_type, TEEC_TempMemoryReference *tmpref, struct tee_ioctl_param *param, TEEC_SharedMemory *shm) { TEEC_Result res = TEEC_ERROR_GENERIC; /* è®¾ç½®ä¸€äº›paramå’Œshare_memoryçš„å±æ€§ï¼Œé€šå¸¸æ˜¯è¯»å†™å±æ€§ */ switch (param_type) { /*input teeé¢„è®¡åšè¯»æ“ä½œï¼Œ output teeé¢„è®¡åšå†™æ“ä½œï¼Œ inout teeå°†è¯»å†™æ•´å—åŒºåŸŸ*/ case TEEC_MEMREF_TEMP_INPUT: param-\u0026gt;attr = TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT; shm-\u0026gt;flags = TEEC_MEM_INPUT; break; ... } /* å…¥å‚bufferçš„é•¿åº¦ï¼Œåé¢å»ç”³è¯·shmå°†ä¼šä»¥è¿™ä¸ªé•¿åº¦å»ç”³è¯· */ shm-\u0026gt;size = tmpref-\u0026gt;size; if (!tmpref-\u0026gt;buffer \u0026amp;\u0026amp; ctx-\u0026gt;memref_null) { if (tmpref-\u0026gt;size) return TEEC_ERROR_BAD_PARAMETERS; /* Null pointer, indicate no shared memory attached */ param-\u0026gt;u.memref.shm_id = TEE_MEMREF_NULL; shm-\u0026gt;id = -1; } else { res = TEEC_AllocateSharedMemory(ctx, shm); // ç”³è¯·share_memory \tif (res != TEEC_SUCCESS) return res; //å°†å…¥å‚bufferæ‹·å…¥ç”³è¯·share_memory \tmemcpy(shm-\u0026gt;buffer, tmpref-\u0026gt;buffer, tmpref-\u0026gt;size); param-\u0026gt;u.memref.shm_id = shm-\u0026gt;id; } param-\u0026gt;u.memref.size = tmpref-\u0026gt;size; return TEEC_SUCCESS; }   å†…æ ¸tee_driver(el1): ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„ä¸­é—´å‘ç”Ÿäº†å•¥ é©±åŠ¨çš„åˆå§‹åŒ–ç›¸å…³åˆ†æè§ï¼šhttps://blog.csdn.net/shuaifengyun/article/details/72934531\né¦–å…ˆæˆ‘ä»¬è¦æœ‰ä¸€ä¸ªæ¦‚å¿µï¼Œteeçš„driveræ˜¯ä¸€ä¸ªä¸¤å±‚ç»“æ„ï¼Œç¬¬ä¸€å±‚åœ¨å¼€æºå†…æ ¸ä»£ç driver/tee/tee_core.cä¸­ï¼Œå…¶æä¾›äº†ä¸€ä¸ªè®¾å¤‡åˆ›å»ºçš„æ¡†æ¶ï¼Œæä¾›äº†åŸºç¡€çš„open/ioctlçš„æ“ä½œçš„å¤–å±‚å°è£…ã€‚ç¬¬äºŒå±‚æ‰æ˜¯çœŸæ­£çš„å…·ä½“çš„å®ç°, å…·ä½“æŒ‚è½½æ–¹å¼åœ¨ä¸‹é¢ä»£ç åˆ†æå¯ä»¥çœ‹åˆ°ã€‚opteeä¸­æ˜¯å®ç°åœ¨driver/tee/opteeä¸­ã€‚å½“ç„¶å‚å•†å¯ä»¥æ ¹æ®è‡ªå·±çš„éœ€æ±‚ï¼Œå»æŒ‚è½½è‡ªå·±çš„å®ç°ï¼Œè¿™ä¹Ÿæ˜¯äºŒå±‚ç»“æ„çš„ä¸»è¦æ„ä¹‰ï¼Œå‚å•†å¼€å‘è‡ªå·±çš„é©±åŠ¨ä¸å¿…è¿‡äºå…³å¿ƒè®¾å¤‡çš„åˆ›å»ºé—®é¢˜ï¼Œåªè¦å…³å¿ƒé©±åŠ¨çš„å…·ä½“å®ç°å°±å¥½ã€‚\næ­¤å¤„ä¸»è¦åˆ†æioctlåˆ°open_sessionçš„æµç¨‹ã€‚ åˆ†æå†…æ ¸é¦–å…ˆå¾—æ‰¾åˆ°f_opsï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* driver/tee/tee_core.c */ struct tee_device *tee_device_alloc(const struct tee_desc *teedesc, struct device *dev, struct tee_shm_pool *pool, void *driver_data) { struct tee_device *teedev; /* é©±åŠ¨çš„å…¨å±€å˜é‡ï¼ŒåŒ…å«äº†é©±åŠ¨ä¸­å„ä¸ªé©±åŠ¨çš„ç»“æ„ */ void *ret; int rc, max_id; int offs = 0; teedev = kzalloc(sizeof(*teedev), GFP_KERNEL); ... cdev_init(\u0026amp;teedev-\u0026gt;cdev, \u0026amp;tee_fops); // teeçš„é©±åŠ¨ä¸ºå­—ç¬¦è®¾å¤‡ï¼Œtee_fops here! \t... dev_set_drvdata(\u0026amp;teedev-\u0026gt;dev, driver_data); device_initialize(\u0026amp;teedev-\u0026gt;dev); ... /* æŒ‚è½½ä¸Šçš„äºŒçº§ç»“æ„ï¼Œçœ‹ä¸‹é¢çš„åˆ†æ */ teedev-\u0026gt;desc = teedesc; } EXPORT_SYMBOL_GPL(tee_device_alloc); static const struct file_operations tee_fops = { .owner = THIS_MODULE, .open = tee_open, // openå…¥å£ \t.release = tee_release, .unlocked_ioctl = tee_ioctl, // ioctlå…¥å£ \t.compat_ioctl = compat_ptr_ioctl, };   é¦–å…ˆçœ‹çœ‹tee_opençš„æ“ä½œï¼Œç”±TEEC_InitializeContextè°ƒç”¨ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103  /* driver/tee/tee_core.c */ static int tee_open(struct inode *inode, struct file *filp) { struct tee_context *ctx; /* åˆå§‹åŒ–å¥½æ‰“å¼€è®¾å¤‡çš„ä¸Šä¸‹æ–‡, é€šè¿‡inodeä¸­çš„i_cdevæ‰¾åˆ°é©±åŠ¨å…¨å±€å˜é‡teedev */ ctx = teedev_open(container_of(inode-\u0026gt;i_cdev, struct tee_device, cdev)); if (IS_ERR(ctx)) return PTR_ERR(ctx); /* * Default user-space behaviour is to wait for tee-supplicant * if not present for any requests in this context. */ ctx-\u0026gt;supp_nowait = false; filp-\u0026gt;private_data = ctx; return 0; } static struct tee_context *teedev_open(struct tee_device *teedev) { int rc; struct tee_context *ctx; if (!tee_device_get(teedev)) return ERR_PTR(-EINVAL); ctx = kzalloc(sizeof(*ctx), GFP_KERNEL); // åˆ›å»ºä¸Šä¸‹æ–‡ \tif (!ctx) { rc = -ENOMEM; goto err; } kref_init(\u0026amp;ctx-\u0026gt;refcount); ctx-\u0026gt;teedev = teedev; INIT_LIST_HEAD(\u0026amp;ctx-\u0026gt;list_shm); /* çœŸæ­£çš„openæ“ä½œï¼Œç”±opteeé©±åŠ¨çš„desc-\u0026gt;opæä¾›. å¦‚ä¸Šæ–‡æ‰€è¯´ï¼Œtee_driveræ˜¯ä¸€ä¸ªå¤–å±‚æ¡†æ¶ï¼Œå…¶é©±åŠ¨çœŸæ­£å®ç°çš„æŒ‚è½½ç‚¹æ­£æ˜¯æ­¤å¤„ */ rc = teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;open(ctx); if (rc) goto err; return ctx; err: kfree(ctx); tee_device_put(teedev); return ERR_PTR(rc); } /* desc æŒ‚è½½çš„ä½ç½®ï¼š driver/tee/optee/core.c*/ static struct optee *optee_probe(struct device_node *np) { ... invoke_fn = get_invoke_func(np); // æ­¤å¤„å°†ä¸ºè§¦å‘smcçš„å‡½æ•°æŒ‚è½½  ... optee-\u0026gt;invoke_fn = invoke_fn; ... /* è°ƒç”¨äº†ä¸Šé¢çš„tee_device_allocï¼Œæ³¨å†Œä¸Šäº†å…·ä½“çš„teeé©±åŠ¨æè¿°å’Œop*/ teedev = tee_device_alloc(\u0026amp;optee_desc, NULL, pool, optee); if (IS_ERR(teedev)) { rc = PTR_ERR(teedev); goto err; } optee-\u0026gt;teedev = teedev; teedev = tee_device_alloc(\u0026amp;optee_supp_desc, NULL, pool, optee); if (IS_ERR(teedev)) { rc = PTR_ERR(teedev); goto err; } optee-\u0026gt;supp_teedev = teedev; ... } static optee_invoke_fn *get_invoke_func(struct device_node *np) { ... else if (!strcmp(\u0026#34;smc\u0026#34;, method)) return optee_smccc_smc; //optee-\u0026gt;invoke_fn = optee_smccc_smcï¼› \t... } static const struct tee_driver_ops optee_ops = { .get_version = optee_get_version, .open = optee_open, // openå‡½æ•°ï¼Œ ä¸å…·ä½“åˆ†æäº†ï¼Œä¸»è¦è¿˜æ˜¯ç”¨äºåˆå§‹åŒ–æ‰“å¼€teeè®¾å¤‡çš„ä¸Šä¸‹æ–‡ \t.release = optee_release, //ioctlä¸‹çš„æ“ä½œï¼Œå¦‚open_session: \t.open_session = optee_open_session, .close_session = optee_close_session, .invoke_func = optee_invoke_func, .cancel_req = optee_cancel_req, .shm_register = optee_shm_register, .shm_unregister = optee_shm_unregister, }; static const struct tee_desc optee_desc = { .name = DRIVER_NAME \u0026#34;-clnt\u0026#34;, .ops = \u0026amp;optee_ops, .owner = THIS_MODULE, };   æœ‰äº†å¯¹teedev_opençš„åˆ†æï¼Œåˆ†æioctlç›¸å…³æ“ä½œä¹Ÿå°±å¹¶ä¸å¤æ‚äº†ï¼Œç›´æ¥çœ‹tee_ioctlï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  /* driver/tee/tee_core.c */ static long tee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct tee_context *ctx = filp-\u0026gt;private_data; void __user *uarg = (void __user *)arg; switch (cmd) { ... /* ä¸»è¦çœ‹open_session */ case TEE_IOC_OPEN_SESSION: return tee_ioctl_open_session(ctx, uarg); ... } } static int tee_ioctl_open_session(struct tee_context *ctx, struct tee_ioctl_buf_data __user *ubuf) { int rc; size_t n; struct tee_ioctl_buf_data buf; struct tee_ioctl_open_session_arg __user *uarg; struct tee_ioctl_open_session_arg arg; struct tee_ioctl_param __user *uparams = NULL; struct tee_param *params = NULL; bool have_session = false; if (!ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;open_session) return -EINVAL; if (copy_from_user(\u0026amp;buf, ubuf, sizeof(buf))) return -EFAULT; if (buf.buf_len \u0026gt; TEE_MAX_ARG_SIZE || buf.buf_len \u0026lt; sizeof(struct tee_ioctl_open_session_arg)) return -EINVAL; /* è¿™ä¸€æ®µæ“ä½œéƒ½æ˜¯å°†ç”¨æˆ·æ€çš„argsæ‹·è´åˆ°å†…æ ¸æ€ï¼Œæ¢å¤å¯¹åº”çš„ç»“æ„ä½“ï¼›å’Œæ™®é€šé©±åŠ¨æ“ä½œå·®ä¸å¤š */ uarg = u64_to_user_ptr(buf.buf_ptr); if (copy_from_user(\u0026amp;arg, uarg, sizeof(arg))) return -EFAULT; if (sizeof(arg) + TEE_IOCTL_PARAM_SIZE(arg.num_params) != buf.buf_len) return -EINVAL; if (arg.num_params) { params = kcalloc(arg.num_params, sizeof(struct tee_param), GFP_KERNEL); if (!params) return -ENOMEM; uparams = uarg-\u0026gt;params; rc = params_from_user(ctx, params, arg.num_params, uparams); if (rc) goto out; } // ä»ä¸Šä¸€æ®µæºç å¯çœ‹åˆ°æŒ‚è½½çš„å…·ä½“å¤„ç†å‡½æ•°ä¸ºoptee_open_session, \trc = ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;open_session(ctx, \u0026amp;arg, params); if (rc) goto out; have_session = true; /* å°†ç»“æœæ‹·è´å›ç”¨æˆ·æ€ç©ºé—´ */ if (put_user(arg.session, \u0026amp;uarg-\u0026gt;session) || put_user(arg.ret, \u0026amp;uarg-\u0026gt;ret) || put_user(arg.ret_origin, \u0026amp;uarg-\u0026gt;ret_origin)) { rc = -EFAULT; goto out; } rc = params_to_user(uparams, arg.num_params, params); out: /* * If we\u0026#39;ve succeeded to open the session but failed to communicate * it back to user space, close the session again to avoid leakage. */ if (rc \u0026amp;\u0026amp; have_session \u0026amp;\u0026amp; ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;close_session) ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;close_session(ctx, arg.session); if (params) { /* Decrease ref count for all valid shared memory pointers */ for (n = 0; n \u0026lt; arg.num_params; n++) if (tee_param_is_memref(params + n) \u0026amp;\u0026amp; params[n].u.memref.shm) tee_shm_put(params[n].u.memref.shm); kfree(params); } return rc; }   å†…æ ¸åˆ‡æ¢åˆ°å®‰å…¨ä¸–ç•Œåšäº†å•¥ ä¹‹åioctlå°†è¿›å…¥cpuåˆ‡æ¢å®‰å…¨ä¸–ç•Œçš„å‡†å¤‡å·¥ä½œï¼šoptee_msg_argæ˜¯æœ€é‡è¦çš„ç»“æ„ä½“ï¼Œä»–æ˜¯å®‰å…¨ä¸–ç•Œä¸éå®‰å…¨ä¸–ç•Œä¿¡æ¯çš„ç»“æ„ä½“ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114  struct optee_msg_arg { uint32_t cmd; uint32_t func; uint32_t session; uint32_t cancel_id; uint32_t pad; uint32_t ret; uint32_t ret_origin; uint32_t num_params; /* num_params tells the actual number of element in params */ struct optee_msg_param params[]; }; /* driver/tee/optee/call.c */ int optee_open_session(struct tee_context *ctx, struct tee_ioctl_open_session_arg *arg, struct tee_param *param) { struct optee_context_data *ctxdata = ctx-\u0026gt;data; int rc; struct tee_shm *shm; struct optee_msg_arg *msg_arg; phys_addr_t msg_parg; struct optee_session *sess = NULL; /* +2 for the meta parameters added below */ /* è¿™ä¸ªå‡½æ•°ç”¨æ¥ç”³è¯·ä¼ é€’smcçš„å…·ä½“msgçš„å…±äº«å†…å­˜ç©ºé—´ï¼Œå®‰å…¨ä¸éå®‰å…¨é€šè¿‡è¯¥ç»“æ„ä½“å®Œæˆé€šä¿¡ msg_pargæ˜¯å…·ä½“çš„ç‰©ç†åœ°å€ï¼Œé€šè¿‡è¯¥ç‰©ç†åœ°å€ä¼ é€’å…·ä½“cmdå‚æ•° ï¼ˆå®‰å…¨æ€å’Œéå®‰å…¨æ€ç»´æŠ¤ç€ä¸åŒçš„é¡µè¡¨ï¼‰ */ shm = get_msg_arg(ctx, arg-\u0026gt;num_params + 2, \u0026amp;msg_arg, \u0026amp;msg_parg); if (IS_ERR(shm)) return PTR_ERR(shm); /* æŒ‡å®šä¸Šå…·ä½“çš„smc msgä¸­çš„cmdï¼Œæ­¤å¤„å°†å»å®Œæˆopen_sessionæ“ä½œ */ msg_arg-\u0026gt;cmd = OPTEE_MSG_CMD_OPEN_SESSION; msg_arg-\u0026gt;cancel_id = arg-\u0026gt;cancel_id; /* * Initialize and add the meta parameters needed when opening a * session. * ä¸»è¦åŒ…å«ä¸Šuuidå’Œclient_uuidï¼š * uuidæ˜¯ä¸€ä¸ªTAæœåŠ¡çš„å”¯ä¸€æ ‡è¯†ç¬¦ */ msg_arg-\u0026gt;params[0].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT | OPTEE_MSG_ATTR_META; msg_arg-\u0026gt;params[1].attr = OPTEE_MSG_ATTR_TYPE_VALUE_INPUT | OPTEE_MSG_ATTR_META; memcpy(\u0026amp;msg_arg-\u0026gt;params[0].u.value, arg-\u0026gt;uuid, sizeof(arg-\u0026gt;uuid)); memcpy(\u0026amp;msg_arg-\u0026gt;params[1].u.value, arg-\u0026gt;uuid, sizeof(arg-\u0026gt;clnt_uuid)); msg_arg-\u0026gt;params[1].u.value.c = arg-\u0026gt;clnt_login; /* æˆ‘ä»¬ä¸»è¦å…³å¿ƒçš„å‡½æ•°ï¼šå°†ç”¨æˆ·æ€ä¼ ä¸‹æ¥çš„æ•°æ®æ‹·å…¥ä¸Šé¢ç”³è¯·çš„smcé€šè®¯å…±äº«å†…å­˜ä¸­paramsçš„å­—æ®µ */ rc = optee_to_msg_param(msg_arg-\u0026gt;params + 2, arg-\u0026gt;num_params, param); if (rc) goto out; sess = kzalloc(sizeof(*sess), GFP_KERNEL); if (!sess) { rc = -ENOMEM; goto out; } /* æ­¤å¤„å°†è§¦å‘smcæŒ‡ä»¤ï¼Œcpuè¿›å…¥el3çš„atfä¸­*/ if (optee_do_call_with_arg(ctx, msg_parg)) { msg_arg-\u0026gt;ret = TEEC_ERROR_COMMUNICATION; msg_arg-\u0026gt;ret_origin = TEEC_ORIGIN_COMMS; } if (msg_arg-\u0026gt;ret == TEEC_SUCCESS) { /* A new session has been created, add it to the list. */ sess-\u0026gt;session_id = msg_arg-\u0026gt;session; mutex_lock(\u0026amp;ctxdata-\u0026gt;mutex); list_add(\u0026amp;sess-\u0026gt;list_node, \u0026amp;ctxdata-\u0026gt;sess_list); mutex_unlock(\u0026amp;ctxdata-\u0026gt;mutex); } else { kfree(sess); } /* å°†æ‹·è´æ•°æ®ä»msgå…±äº«å†…å­˜æ‹·è´å›éå®‰å…¨å…¥å‚çš„å…±äº«å†…å­˜ä¸­ */ ... } int optee_to_msg_param(struct optee_msg_param *msg_params, size_t num_params, const struct tee_param *params) { int rc; size_t n; for (n = 0; n \u0026lt; num_params; n++) { /*valueç±»å‹çš„ä¼ å‚ï¼Œèµ‹å€¼å³å¯ï¼Œmemrefçš„bufferå…¥å‚å¦‚ä¸‹å¤„ç†ï¼š*/ ... case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT: /* å°†shmæ³¨å†Œè¿›msg_paramç»“æ„ä½“ä¸­ * tmpéœ€è¦å†™å…¥å…·ä½“ç‰©ç†åœ°å€ï¼Œrefç›´æ¥å†™å…¥shmç»“æ„ä½“å³å¯ */ if (tee_shm_is_registered(p-\u0026gt;u.memref.shm)) rc = to_msg_param_reg_mem(mp, p); else rc = to_msg_param_tmp_mem(mp, p); if (rc) return rc; break; default: return -EINVAL; } } return 0; }   å‚æ•°å‡†å¤‡å¥½ä¹‹åï¼Œå¼€å§‹é…ç½®å¯„å­˜å™¨ï¼Œè§¦å‘smcæŒ‡ä»¤ï¼Œå®Œæˆåˆ‡æ¢åˆ°el3ï¼Œå‡†å¤‡è¿›è¡ŒCPUå®‰å…¨æ€ä¸éå®‰å…¨æ€åˆ‡æ¢ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  /* driver/tee/optee/call.c */ u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg) { struct optee *optee = tee_get_drvdata(ctx-\u0026gt;teedev); struct optee_call_waiter w; struct optee_rpc_param param = { }; struct optee_call_ctx call_ctx = { }; u32 ret; /* å‡†å¤‡å¥½å¯„å­˜å™¨çš„å€¼ */ /* r0: smc_callçš„å‘½ä»¤ */ param.a0 = OPTEE_SMC_CALL_WITH_ARG; /* r1, r2: ä¸Šé¢å‡†å¤‡å¥½çš„msgç»“æ„ä½“çš„ç‰©ç†åœ°å€, r1ä½32ä½ï¼Œr2é«˜32ä½ï¼Œé€šè¿‡å¯„å­˜å™¨ä¼ é€’ç»™å®‰å…¨ä¾§ */ reg_pair_from_64(\u0026amp;param.a1, \u0026amp;param.a2, parg); /* Initialize waiter */ optee_cq_wait_init(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); while (true) { struct arm_smccc_res res; optee_bm_timestamp(); /*å¦‚ä¸Šæ–‡optee_probeæ‰€ç¤ºï¼Œ æ­¤å¤„å°†æŒ‚è½½ä¸Šoptee_smccc_smc */ optee-\u0026gt;invoke_fn(param.a0, param.a1, param.a2, param.a3, param.a4, param.a5, param.a6, param.a7, \u0026amp;res); optee_bm_timestamp(); if (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) { /* * Out of threads in secure world, wait for a thread * become available. */ optee_cq_wait_for_completion(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); } else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) { might_sleep(); param.a0 = res.a0; param.a1 = res.a1; param.a2 = res.a2; param.a3 = res.a3; optee_handle_rpc(ctx, \u0026amp;param, \u0026amp;call_ctx); } else { ret = res.a0; break; } } optee_rpc_finalize_call(\u0026amp;call_ctx); /* * We\u0026#39;re done with our thread in secure world, if there\u0026#39;s any * thread waiters wake up one. */ optee_cq_wait_final(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); return ret; } /* driver/tee/optee/core /* Simple wrapper functions to be able to use a function pointer */ static void optee_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4, unsigned long a5, unsigned long a6, unsigned long a7, struct arm_smccc_res *res) { arm_smccc_smc(a0, a1, a2, a3, a4, a5, a6, a7, res); }   è§¦å‘smcå¤„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  /* include/linux/arm-smccc.h */ #define arm_smccc_smc(...) __arm_smccc_smc(__VA_ARGS__, NULL) ... asmlinkage void __arm_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long a4, unsigned long a5, unsigned long a6, unsigned long a7, struct arm_smccc_res *res, struct arm_smccc_quirk *quirk); /* arch/arm64/kernel/smccc-call.S */ .macro SMCCC instr .cfi_startproc \\instr\t#0 /* smc 0, æ­¤å¤„è§¦å‘smcæŒ‡ä»¤è¿›å…¥el3 atf */ ldr\tx4, [sp] stp\tx0, x1, [x4, #ARM_SMCCC_RES_X0_OFFS] /* smcæŒ‡ä»¤å›æ¥ä¹‹åï¼Œä¿å­˜ç»“æœå¯„å­˜å™¨çŠ¶æ€ */ stp\tx2, x3, [x4, #ARM_SMCCC_RES_X2_OFFS] ldr\tx4, [sp, #8] cbz\tx4, 1f /* no quirk structure */ ldr\tx9, [x4, #ARM_SMCCC_QUIRK_ID_OFFS] cmp\tx9, #ARM_SMCCC_QUIRK_QCOM_A6 b.ne\t1f str\tx6, [x4, ARM_SMCCC_QUIRK_STATE_OFFS] 1:\tret .cfi_endproc .endm /* * void arm_smccc_smc(unsigned long a0, unsigned long a1, unsigned long a2, *\tunsigned long a3, unsigned long a4, unsigned long a5, *\tunsigned long a6, unsigned long a7, struct arm_smccc_res *res, *\tstruct arm_smccc_quirk *quirk) */ ENTRY(__arm_smccc_smc) SMCCC\tsmc ENDPROC(__arm_smccc_smc) EXPORT_SYMBOL(__arm_smccc_smc)   å…·ä½“æµç¨‹å‚è€ƒä¸‹å›¾ï¼š\nArm Trusted firmware(ATF, el3) ä¹‹åCPUé™·å…¥EL3æ€ï¼Œè¿›å…¥ATFï¼ŒATFä¸»è¦ç¡®è®¤TEE kernelå…¥å£(std_smcæˆ–è€…fast_smcæ¨¡å¼ï¼Œæœ‰ä¸åŒçš„å…¥å£)ï¼Œéå®‰å…¨ä¸–ç•Œå¯„å­˜å™¨ä¸Šä¸‹æ–‡çš„ä¿å­˜å·¥ä½œï¼Œä¿®æ”¹CPUç³»ç»Ÿå¯„å­˜å™¨SCRçš„NSçŠ¶æ€ä¸ºå®‰å…¨ä½ç­‰ï¼Œæ­¤å¤„ä¸ç»†è®²ï¼Œå…·ä½“å¯ä»¥çœ‹ï¼š\nhttps://blog.csdn.net/shuaifengyun/article/details/73118852\nTEE_kernel kernelä¸ºsmc_callåˆ›å»ºçº¿ç¨‹å¹¶å¯åŠ¨çº¿ç¨‹ ATFå®Œæˆå¥½å·¥ä½œå, CPUè¿›å…¥sel1çŠ¶æ€, ä»£ç è¿è¡Œçš„å…¥å£ç”±ATFå¤åŸå¹¶é€‰æ‹©ï¼Œä»¥arm64ä¸ºä¾‹ï¼š\n/* optee-src/core/arch/arm/kernel/thread_optee_smc_a64.S */ /* * Vector table supplied to ARM Trusted Firmware (ARM-TF) at * initialization. * * Note that ARM-TF depends on the layout of this vector table, any change * in layout has to be synced with ARM-TF. */ FUNC thread_vector_table , : , .identity_map b\tvector_std_smc_entry b\tvector_fast_smc_entry b\tvector_cpu_on_entry b\tvector_cpu_off_entry b\tvector_cpu_resume_entry b\tvector_cpu_suspend_entry b\tvector_fiq_entry b\tvector_system_off_entry b\tvector_system_reset_entry END_FUNC thread_vector_table KEEP_PAGER thread_vector_table LOCAL_FUNC vector_std_smc_entry , : , .identity_map readjust_pc bl\tthread_handle_std_smc /* * Normally thread_handle_std_smc() should return via * thread_exit(), thread_rpc(), but if thread_handle_std_smc() * hasn\u0026#39;t switched stack (error detected) it will do a normal \u0026#34;C\u0026#34; * return. */ mov\tw1, w0 ldr\tx0, =TEESMC_OPTEED_RETURN_CALL_DONE smc\t#0 b\t.\t/* SMC should not return */ END_FUNC vector_std_smc_entry open_sessionå°†è¿›å…¥vector_std_smc_entry-\u0026gt;thread_handle_std_smcï¼Œè¿›ä¸€æ­¥åˆ†æTEEçš„å†…æ ¸å¦‚ä½•å¤„ç†ä¸€æ¡smc_call:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  /* optee-src/core/arch/arm/kernel/thread.c */ uint32_t thread_handle_std_smc(uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5, uint32_t a6 __unused, uint32_t a7 __maybe_unused) { uint32_t rv = OPTEE_SMC_RETURN_OK; /* æ£€æŸ¥teeå †æ ˆçš„canaryï¼Œæ˜¯å¦æœ‰æº¢å‡ºæƒ…å†µ */ thread_check_canaries(); ... /* * thread_resume_from_rpc() and thread_alloc_and_run() only return * on error. Successful return is done via thread_exit() or * thread_rpc(). */ /* smc_callæ¥è‡ªrpc(éå®‰å…¨ä¾§å“åº”teeçš„å‘½ä»¤çš„å®ˆæŠ¤è¿›ç¨‹)åˆ†æ”¯ */ if (a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC) { thread_resume_from_rpc(a3, a1, a2, a4, a5); rv = OPTEE_SMC_RETURN_ERESUME; } else { /* smc_callæ¥è‡ªLibteecï¼Œä¸»è¦åŒ…æ‹¬open session, close session, invokeç­‰ */ /*a0-a3å¯¹åº”å¯„å­˜å™¨r0-r3*/ thread_alloc_and_run(a0, a1, a2, a3); rv = OPTEE_SMC_RETURN_ETHREAD_LIMIT; } ... }   thread_alloc_and_runå°†å¯¹äºæ¥è‡ªlibteecçš„smc_callåˆ›å»ºä¸€ä¸ªthread:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  /* optee-src/core/arch/arm/thread.c */ void thread_alloc_and_run(uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3) { size_t n; struct thread_core_local *l = thread_get_core_local(); bool found_thread = false; /* ç¡®å®šå½“å‰æ ¸ä¸Šæ²¡æœ‰çº¿ç¨‹å æ®ï¼Œ * ç‰¹åˆ«æ³¨æ„ï¼ŒOPTEEæ¯ä¸€ä¸ªæ ¸åªèƒ½æœ‰ä¸€ä¸ªçº¿ç¨‹è¿è¡Œ */ assert(l-\u0026gt;curr_thread == -1); thread_lock_global(); /* ä»å…¨å±€å˜é‡çš„threadä¸­ï¼Œæ‹¿å‡ºä¸€ä¸ªåˆ†é…ç»™å½“å‰çš„è¯·æ±‚ */ for (n = 0; n \u0026lt; CFG_NUM_THREADS; n++) { if (threads[n].state == THREAD_STATE_FREE) { threads[n].state = THREAD_STATE_ACTIVE; found_thread = true; break; } } thread_unlock_global(); if (!found_thread) return; l-\u0026gt;curr_thread = n; threads[n].flags = 0; /* åˆå§‹åŒ–threadçš„å„ç§å¯„å­˜å™¨ä¸Šä¸‹æ–‡ */ init_regs(threads + n, a0, a1, a2, a3); thread_lazy_save_ns_vfp(); /* çº¿ç¨‹å¯åŠ¨ */ thread_resume(\u0026amp;threads[n].regs); /*NOTREACHED*/ panic(); } static void init_regs(struct thread_ctx *thread, uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3) { /* æŒ‡å®šè¯¥çº¿ç¨‹ä¸Šä¸‹æ–‡ä¸­PCæŒ‡é’ˆçš„åœ°å€ï¼Œå½“è¯¥thread resumeå›æ¥ä¹‹åå°±ä¼šå¼€å§‹æ‰§è¡Œregs.pcæ‰§ * è¡Œçš„å‡½æ•° */ thread-\u0026gt;regs.pc = (uint64_t)thread_std_smc_entry; /* * Stdcalls starts in SVC mode with masked foreign interrupts, masked * Asynchronous abort and unmasked native interrupts. */ thread-\u0026gt;regs.cpsr = SPSR_64(SPSR_64_MODE_EL1, SPSR_64_MODE_SP_EL0, THREAD_EXCP_FOREIGN_INTR | DAIFBIT_ABT); /* Reinitialize stack pointer */ thread-\u0026gt;regs.sp = thread-\u0026gt;stack_va_end; /* * Copy arguments into context. This will make the * arguments appear in x0-x7 when thread is started. */ thread-\u0026gt;regs.x[0] = a0; thread-\u0026gt;regs.x[1] = a1; thread-\u0026gt;regs.x[2] = a2; thread-\u0026gt;regs.x[3] = a3; thread-\u0026gt;regs.x[4] = 0; thread-\u0026gt;regs.x[5] = 0; thread-\u0026gt;regs.x[6] = 0; thread-\u0026gt;regs.x[7] = 0; /* Set up frame pointer as per the Aarch64 AAPCS */ thread-\u0026gt;regs.x[29] = 0; }   thread_resumeå°†å¯åŠ¨çº¿ç¨‹ï¼Œ è¯¥å‡½æ•°ä¸ºæ±‡ç¼–ä»£ç ï¼Œä¸»è¦æ˜¯ä¿å­˜ä¸€äº›å¯„å­˜å™¨çŠ¶æ€ï¼Œå¹¶ä¸”æŒ‡å®šthreadè¿è¡Œåœ¨ä»€ä¹ˆæ¨¡å¼ã€‚\n/* optee-src/core/arch/arm/kernel/arm64_macros.S*/ /* void thread_resume(struct thread_ctx_regs *regs) */ FUNC thread_resume , : /* æ¢å¤çº¿ç¨‹å¯„å­˜å™¨çŠ¶æ€ */ /* åŠ è½½ç»“æ„ä½“ä¸­å‰ä¸‰ä¸ªå¯„å­˜å™¨sp, pc, cpsråˆ°x1, x2, x3ï¼Œè§ä¸‹thread_ctx_regsç»“æ„ä½“ */ load_xregs x0, THREAD_CTX_REGS_SP, 1, 3 /* åŠ è½½ç»“æ„ä½“x4-x30 */ load_xregs x0, THREAD_CTX_REGS_X4, 4, 30 /* æ¢å¤sp, pc, cpsr, pcåŠ è½½è¿›elr_el1ï¼Œå³è§¦å‘è¿”å›æ—¶å°†æ‰§è¡Œåˆ°è¯¥åœ°å€ï¼š * thread_std_smc_entry */\tmov\tsp, x1 msr\telr_el1, x2 msr\tspsr_el1, x3 b_if_spsr_is_el0 w3, 1f /* å¤„ç†ç”±taè§¦å‘svcä¸‹é™·åˆ°sel1çš„æ“ä½œï¼ŒCAè¿‡æ¥çš„æ“ä½œä¸èµ°è¿™æ¡è·¯ */ /* æ¢å¤ x0 - x3 */ load_xregs x0, THREAD_CTX_REGS_X1, 1, 3 ldr\tx0, [x0, THREAD_CTX_REGS_X0] /* è§¦å‘å‡½æ•°è¿”å›ï¼Œ è¿›å…¥thread_std_smc_entry */ eret 1:\tload_xregs x0, THREAD_CTX_REGS_X1, 1, 3 ldr\tx0, [x0, THREAD_CTX_REGS_X0] msr\tspsel, #1 store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1 b\teret_to_el0 END_FUNC thread_resume /* optee-src/core/arch/arm/include/kernel/thread.h */ /* çº¿ç¨‹å¯„å­˜å™¨ä¸Šä¸‹æ–‡ */ struct thread_ctx_regs { uint64_t sp; uint64_t pc; uint64_t cpsr; uint64_t x[31]; }; åœ¨init_regsä¸­çš„regs.pcä¸­å·²ç»åˆ¶å®šäº†è¯¥threadè¢«resumeå›æ¥ä¹‹åçš„pcæŒ‡é’ˆä¸ºthread_std_smc_entryï¼Œå½“threadè¢«resumeä¹‹åå°±ä¼šå»æ‰§è¡Œè¯¥å‡½æ•°ï¼š\n/* optee-src/core/arch/arm/kernel/thread_optee_smc_a64.S */ FUNC thread_std_smc_entry , : bl\t__thread_std_smc_entry /* çº¿ç¨‹å…¥å£ï¼Œæ­¤æ—¶çº¿ç¨‹çœŸæ­£å¯åŠ¨èµ·æ¥ */ mov\tw20, w0\t/* Save return value for later */ /* Mask all maskable exceptions before switching to temporary stack */ msr\tdaifset, #DAIFBIT_ALL bl\tthread_get_tmp_sp mov\tsp, x0 bl\tthread_state_free ldr\tx0, =TEESMC_OPTEED_RETURN_CALL_DONE mov\tw1, w20 mov\tx2, #0 mov\tx3, #0 mov\tx4, #0 /* è§¦å‘smcï¼Œé€€å‡ºå®‰å…¨ä¸–ç•Œï¼Œè¿›å…¥el3 */ smc\t#0 b\t.\t/* SMC should not return */ END_FUNC thread_std_smc_entry ç”¨ä¸€å¼ å›¾è¡¨ç¤ºå¦‚ä¸‹ï¼š\nkernelå¯¹msgçš„å¤„ç† __thread_std_smc_entryå¯¹äºä¸åŒçš„ç¡¬ä»¶ç¯å¢ƒå¯èƒ½æœ‰ä¸€äº›ä¸åŒçš„å¤„ç†ï¼Œæ˜¯ä¸€ä¸ªweakå‡½æ•°ï¼Œä½†æœ€ç»ˆéƒ½å°†è¿›å…¥å‡½æ•°\ntee_entry_stdï¼Œæ³¨æ„r0å¸¦ç€smc_callçš„cmdï¼Œr1ï¼Œr2ä¸¤ä¸ªå¯„å­˜å™¨ä¿å­˜ç€optee_msgçš„ç‰©ç†åœ°å€ï¼Œè¿™äº›éƒ½æ˜¯æ¥è‡ªäºéå®‰å…¨ä¸–ç•Œçš„ä¼ å…¥ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64  static uint32_t std_smc_entry(uint32_t a0, uint32_t a1, uint32_t a2, uint32_t a3 __unused) { paddr_t parg = 0; struct optee_msg_arg *arg = NULL; uint32_t num_params = 0; struct mobj *mobj = NULL; uint32_t rv = 0; /* æ­¤å¤„å¯ä»¥çœ‹åˆ°æ¥è‡ªCAçš„è¯·æ±‚,r0åªèƒ½æ˜¯OPTEE_SMC_CALL_WITH_ARG */ if (a0 != OPTEE_SMC_CALL_WITH_ARG) { EMSG(\u0026#34;Unknown SMC 0x%\u0026#34;PRIx32, a0); DMSG(\u0026#34;Expected 0x%x\u0026#34;, OPTEE_SMC_CALL_WITH_ARG); return OPTEE_SMC_RETURN_EBADCMD; } /* é€šè¿‡r1-r2æ¢å¤msgçš„ç‰©ç†åœ°å€ */ parg = reg_pair_to_64(a1, a2); /* Check if this region is in static shared space */ if (core_pbuf_is(CORE_MEM_NSEC_SHM, parg, sizeof(struct optee_msg_arg))) { /* æ­¤å¤„å°†ç‰©ç†åœ°å€è½¬æˆå®‰å…¨ä¸–ç•Œä¸­çš„è™šæ‹Ÿåœ°å€ */ mobj = get_cmd_buffer(parg, \u0026amp;num_params); } else { if (parg \u0026amp; SMALL_PAGE_MASK) return OPTEE_SMC_RETURN_EBADADDR; mobj = map_cmd_buffer(parg, \u0026amp;num_params); } if (!mobj || !ALIGNMENT_IS_OK(parg, struct optee_msg_arg)) { EMSG(\u0026#34;Bad arg address 0x%\u0026#34; PRIxPA, parg); mobj_put(mobj); return OPTEE_SMC_RETURN_EBADADDR; } /* mobj_shm_allocå‡½æ•°å®Œæˆäº†mobjçš„ç”³è¯·ï¼Œæ‹¿åˆ°vaå³å¯ï¼Œè·å¾—msgçš„è™šæ‹Ÿåœ°å€ */ arg = mobj_get_va(mobj, 0); assert(arg \u0026amp;\u0026amp; mobj_is_nonsec(mobj)); /* è·å–msgï¼Œå¼€å§‹å¤„ç†è¯·æ±‚ */ rv = tee_entry_std(arg, num_params); mobj_put(mobj); return rv; } static struct mobj *get_cmd_buffer(paddr_t parg, uint32_t *num_params) { struct optee_msg_arg *arg; size_t args_size; /* argçš„åœ°å€åœ¨æ­¤ */ arg = phys_to_virt(parg, MEM_AREA_NSEC_SHM); if (!arg) return NULL; /* è¯»å–paramsçš„æ•°é‡ */ *num_params = READ_ONCE(arg-\u0026gt;num_params); if (*num_params \u0026gt; OPTEE_MSG_MAX_NUM_PARAMS) return NULL; args_size = OPTEE_MSG_GET_ARG_SIZE(*num_params); /* opteeä¸­çš„å¯¹äºè™šæ‹Ÿå†…å­˜åˆ†è§£æˆmobj(memory object)ç»“æ„ä½“ï¼Œå°†ä¿å­˜è™šæ‹Ÿåœ°å€ï¼Œç‰©ç†åœ°å€ç­‰ */ return mobj_shm_alloc(parg, args_size, 0); }   Open_session å†…æ ¸çš„å¤„ç†æµç¨‹ è¿‡äº†è¿™ä¹ˆä¹…çš„æµç¨‹ï¼Œç»ˆäºæ¥åˆ°äº†TEEçœŸæ­£å¤„ç†è¯·æ±‚æ“ä½œçš„ä»£ç :\nopen_sessionä¸»è¦å®Œæˆçš„å·¥ä½œå°±æ˜¯ç¡®å®šTAå¤„ç†æœåŠ¡cmd(invoke_command)çš„ä»£ç å…¥å£ï¼Œå…¶3.5ç‰ˆæœ¬ä¹‹åæœ‰ä¸€ä¸ªå·¨å¤§çš„æ”¹ç‰ˆï¼Œ3.5ä¹‹åç‰ˆæœ¬çš„å®ç°åç»­å°†ç®€å•æåˆ°ä¸€ä¸‹ï¼Œæ­¤å¤„æˆ‘ä»¬å…ˆçœ‹3.5ç‰ˆæœ¬çš„å®ç°æ–¹å¼ï¼š\nå…¶æµç¨‹éå¸¸å¤æ‚ï¼Œå…ˆè´´ä¸€å¼ å¤§ç¥æ€»ç»“çš„æµç¨‹å›¾ï¼Œé¡ºç€è¿™ä¸ªå¾€ä¸‹çœ‹ï¼Œåé¢æˆ‘ä»¬è§£è¯»ä¸€äº›å…³é”®æ­¥éª¤çš„æºç ï¼š\nå›¾å¤ªå¤§ï¼Œçœ‹èµ·æ¥å¾ˆå¤æ‚ï¼Œæˆ‘ä»¬æ€»ç»“å‡ ä¸ªé‡ç‚¹ï¼š\n æ„é€ sessionä¸å¯»æ‰¾ç›®æ ‡TAæ˜¯å¦å·²ç»åŠ è½½ï¼šæ‰€æœ‰çš„sessionä¼šä»¥ä¸€ä¸ªé“¾è¡¨çš„å½¢å¼å­˜åœ¨ä¸€ä¸ªç»“æ„ä½“struct tee_ta_session_headä¸­ï¼Œä¸»è¦ åœ¨src/core/kernel/tee_ta_manager.cä¸­çš„tee_ta_init_sessionå‡½æ•°ä¸­ã€‚åŒæ—¶ç¡®å®šç›®æ ‡TAå·²æ‰“å¼€è¿‡ï¼Œæ‰“å¼€è¿‡åˆ™å°†ç›´æ¥å°†è¯¥taçš„ä¸Šä¸‹æ–‡è¿”å›ï¼Œè¿›å…¥TAä¸­çš„æ‰“å¼€sessionæ“ä½œä¸­ã€‚ åŠ è½½TAï¼šä»teeå‘èµ·çš„å¯¹reeä¾§çš„æœåŠ¡è¯·æ±‚RPCï¼Œå‘¼å«å®ˆæŠ¤è¿›ç¨‹tee_supplicantå°†TAåŠ è½½è¿›ä¸€æ®µå…±äº«å†…å­˜ä¸­ï¼Œå¹¶ è§¦å‘smcè¿”å›å®‰å…¨ä¾§ TEEå°†æ¢å¤çº¿ç¨‹ï¼Œå¹¶å¯¹TAè¿›è¡Œelfæ ¼å¼æ ¡éªŒä¸ç­¾åæ ¡éªŒ(éªŒç­¾çš„å…¬é’¥è¢«ç¼–å…¥äº†tee_kernelä¸­ï¼Œéœ€è¦åœ¨ç¼–è¯‘æ—¶æ”¾åœ¨æŒ‡å®šæ–‡ä»¶å¤¹) è‹¥éªŒç­¾æˆåŠŸï¼ŒTEEå°†åŠ è½½TAè¿›å…¥å®‰å…¨å†…å­˜ä¸­ï¼Œé€šè¿‡TAå¤´ä¸­å¯¹å„å‡½æ•°åœ°å€åç§»çš„æŒ‡å®šï¼Œè¿›å…¥TAçš„open_session çš„entryï¼Œå®ŒæˆTAä¸­æŒ‡å®šçš„å¤„ç†åï¼Œè¿”å›REEä¾§  TEE_kernel å¤„ç†å…¥å£ ç®€å•åˆ†æä¸€ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  /* optee-src/core/arch/arm/entry_std.c */ uint32_t __tee_entry_std(struct optee_msg_arg *arg, uint32_t num_params) { uint32_t rv = OPTEE_SMC_RETURN_OK; /* Enable foreign interrupts for STD calls */ thread_set_foreign_intr(true); switch (arg-\u0026gt;cmd) { /* å›å¿†èµ·æ¥, tee_driverå¡«çš„cmdä¸ºOPTEE_MSG_CMD_OPEN_SESSION */ case OPTEE_MSG_CMD_OPEN_SESSION: entry_open_session(arg, num_params); break; ... return rv;\t} static void entry_open_session(struct optee_msg_arg *arg, uint32_t num_params) { TEE_Result res; TEE_ErrorOrigin err_orig = TEE_ORIGIN_TEE; struct tee_ta_session *s = NULL; TEE_Identity clnt_id; TEE_UUID uuid; struct tee_ta_param param; size_t num_meta; uint64_t saved_attr[TEE_NUM_PARAMS] = { 0 }; /* è·å–ä¸€äº›åŸºæœ¬çš„å‚æ•°ï¼Œåœ¨é©±åŠ¨ä¾§æˆ‘ä»¬èƒ½çœ‹åˆ°å‰ä¸¤ä¸ªparamsæ˜¯é©±åŠ¨å¡«å……çš„ï¼Œæ˜¯ä¸€äº›metaæ•°æ®ï¼š * 1. uuidï¼Œç”¨æ¥ç¡®å®šåŠ è½½çš„TAçš„åå­— * 2. å‚æ•°ä¸ªæ•° * 3. clnt_id (è¿™ä¸ªå…·ä½“å…¶å®æ²¡æœ‰å…·ä½“ä½¿ç”¨ï¼Œå¯èƒ½åç»­å°†ç”¨äºå®¢æˆ·ç«¯é‰´æƒ) */ res = get_open_session_meta(num_params, arg-\u0026gt;params, \u0026amp;num_meta, \u0026amp;uuid, \u0026amp;clnt_id); if (res != TEE_SUCCESS) goto out; /* æ­¤å¤„æ˜¯éå¸¸å…³é”®çš„å®‰å…¨æ“ä½œï¼šå°†å…±äº«å†…å­˜ä¸­çš„paramæ‹·è´åˆ°å®‰å…¨å†…å­˜ä¸­ */ res = copy_in_params(arg-\u0026gt;params + num_meta, num_params - num_meta, \u0026amp;param, saved_attr); if (res != TEE_SUCCESS) goto cleanup_shm_refs; /* ä¹‹åæ‰€æœ‰çš„æ“ä½œéƒ½åœ¨æ­¤å‡½æ•°ä¸­å®Œæˆï¼Œä»¥ä¸‹æµç¨‹éƒ½åœ¨è¯¥å‡½æ•°ä¸­è¿›è¡Œ */ res = tee_ta_open_session(\u0026amp;err_orig, \u0026amp;s, \u0026amp;tee_open_sessions, \u0026amp;uuid, \u0026amp;clnt_id, TEE_TIMEOUT_INFINITE, \u0026amp;param); if (res != TEE_SUCCESS) s = NULL; ... }   æ„é€ sessionä¸å¯»æ‰¾ç›®æ ‡TAæ˜¯å¦å·²ç»åŠ è½½ tee_ta_open_sessionç¬¬ä¸€æ­¥å°±æ˜¯å»åˆå§‹åŒ–sessionï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  /* core/kernel/tee_ta_manager.c */ TEE_Result tee_ta_open_session(TEE_ErrorOrigin *err, struct tee_ta_session **sess, struct tee_ta_session_head *open_sessions, const TEE_UUID *uuid, const TEE_Identity *clnt_id, uint32_t cancel_req_to, struct tee_ta_param *param) { TEE_Result res; struct tee_ta_session *s = NULL; struct tee_ta_ctx *ctx; bool panicked; bool was_busy = false; res = tee_ta_init_session(err, open_sessions, uuid, \u0026amp;s); if (res != TEE_SUCCESS) { DMSG(\u0026#34;init session failed 0x%x\u0026#34;, res); return res; } ... } static TEE_Result tee_ta_init_session(TEE_ErrorOrigin *err, struct tee_ta_session_head *open_sessions, const TEE_UUID *uuid, struct tee_ta_session **sess) { TEE_Result res; struct tee_ta_ctx *ctx; /* sessionç»“æ„ä½“çš„åˆå§‹åŒ–ï¼Œta_ctxä¸Šä¸‹æ–‡ä¹Ÿå°†æ³¨å†Œè¿›æ­¤ç»“æ„ä½“ */ struct tee_ta_session *s = calloc(1, sizeof(struct tee_ta_session)); ... /* Look for already loaded TA */ ctx = tee_ta_context_find(uuid); if (ctx) { res = tee_ta_init_session_with_context(ctx, s); if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND) goto out; } /* Look for pseudo TA */ /* é™æ€ pseudo TAæ˜¯æŒ‡å·²ç»ä¸€èµ·è¿ç¼–è¿›opteeå†…æ ¸çš„ä¸€äº›TAã€‚ * è¿™ç§TAæ‰“å¼€æ¯”è¾ƒç®€å•ï¼Œæœç´¢å†…æ ¸ä¸­PTAçš„æ®µï¼ŒåŒ¹é…å¯¹åº”çš„uuidï¼Œè‹¥åŒ¹é…ä¸Šï¼Œåˆ™ç›´æ¥è¿›å…¥open_sessionå¤„ç† * ç”±äºæ˜¯ä¸opteeå†…æ ¸è¿ç¼–ï¼Œæ— éœ€éªŒç­¾ */ res = tee_ta_init_pseudo_ta_session(uuid, s); if (res == TEE_SUCCESS || res != TEE_ERROR_ITEM_NOT_FOUND) goto out; /* Look for user TA */ /* å…³é”®å‡½æ•°ï¼Œå‡å¦‚æˆ‘ä»¬è¦åŠ è½½ä»æ–‡ä»¶ç³»ç»Ÿ/å®‰å…¨å­˜å‚¨ä¸Šçš„TAï¼Œèµ°è¿™ä¸ªåˆ†æ”¯ï¼Œæˆ‘ä»¬è¿™é‡Œä¸»è¦è§‚å¯Ÿ */ res = tee_ta_init_user_ta_session(uuid, s); ... }   åŠ è½½TAä¸ç­¾åè®¤è¯ tee_ta_init_user_ta_session æ ¸å¿ƒå¤„ç†å‡½æ•°å°±æ˜¯load_elfå‡½æ•°ï¼Œä»–å°†å‘èµ·ä¸€ä¸ªä»TEEåˆ°REEçš„è¯·æ±‚ï¼Œè¯·æ±‚å»åŠ è½½æ–‡ä»¶ç³»ç»Ÿä¸ŠæŒ‡å®šUUIDçš„TAã€‚\né¦–å…ˆçœ‹ä¸€ä¸‹TAçš„ç»“æ„ï¼š\nå¯ä»¥çœ‹åˆ°ï¼ŒTAæ˜¯åˆ†æ®µçš„ï¼Œè€ŒåŠ è½½è¿‡ç¨‹ä¸­ï¼Œåªéœ€è¦åŠ è½½TA raw imageå³å¯ï¼Œä½†åŠ è½½å‰éœ€è¦å¯¹å…¶è¿›è¡Œæ ¡éªŒï¼Œå…¶æ ¡éªŒæ–¹æ³•å‚çœ‹ä¸‹æ–‡ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  /* core/arch/arm/kernel/user_ta.c */ static TEE_Result load_elf(const TEE_UUID *uuid, struct user_ta_ctx *utc) { TEE_Result res = TEE_ERROR_ITEM_NOT_FOUND; const struct user_ta_store_ops *op = NULL; /* ta_storesæ€»å…±æœ‰ä¸‰ä¸ªï¼Œæˆ‘ä»¬ä¸»ç®¡å…³å¿ƒruntimeæ—¶ä»æ–‡ä»¶ç³»ç»Ÿä¸ŠåŠ è½½TAï¼Œå…¶æ³¨å†Œçš„opåœ¨åº•ä¸‹ */ SCATTERED_ARRAY_FOREACH(op, ta_stores, struct user_ta_store_ops) { DMSG(\u0026#34;Lookup user TA ELF %pUl (%s)\u0026#34;, (void *)uuid, op-\u0026gt;description); res = load_elf_from_store(uuid, op, utc); ... } /* core/arch/arm/kernel/ree_fs_ta.c */ TEE_TA_REGISTER_TA_STORE(9) = { .description = \u0026#34;REE\u0026#34;, .open = ree_fs_ta_open, /*æ­¤å¤„æ³¨å†Œä¸Šäº†openå‡½æ•°*/ .get_size = ree_fs_ta_get_size, .read = ree_fs_ta_read, .close = ree_fs_ta_close, };   load_elf_from_storeå°†å¤„ç†å°†æ–‡ä»¶ç³»ç»Ÿä¸­çš„TAåŠ è½½è¿›å®‰å…¨å†…å­˜ä¸­ï¼Œå¹¶æŠŠentry_funcå…¥å£ç¡®å®šä¸‹æ¥ï¼Œæ•´ä¸ªæµç¨‹éå¸¸å¤æ‚ï¼Œç‰µæ‰¯åˆ°å¤šæ¬¡TEEåˆ°REEçš„äº¤äº’ï¼ˆTEEåˆ°REEçš„äº¤äº’éƒ¨åˆ†ï¼Œä¸‹ä¸ªéƒ¨åˆ†tee_supplicantç›¸å…³ç« èŠ‚å°†ç€é‡å…³æ³¨ï¼Œå½“å‰åªé˜è¿°æµç¨‹ï¼Œæºç åˆ†æå¯ä»¥åç»­è¡¥ä¸Šã€‚TAå®é™…ä¸Šè¿˜æ˜¯ä¸€ä¸ªå‰é¢æœ‰ä¸€ä¸ªç­¾åå¤´çš„elfæ–‡ä»¶ï¼Œå…¶åŠ è½½è¿‡ç¨‹å¦‚ä¸‹ï¼š\n  ta_store-\u0026gt;open(uuid, \u0026amp;handle):TEEè®©REEé¦–å…ˆåŠ è½½TAå¤´éƒ¨, éªŒè¯å¤´éƒ¨ä¸­hashå€¼çš„ç­¾åï¼Œç¡®ä¿å¤´éƒ¨hashå€¼çš„å¯é æ€§. å¹¶ä¸”æ¯”è¾ƒè¢«ç­¾åçš„UUIDæ—¶å€™ä¸æ–‡ä»¶ç³»ç»Ÿä¸Štaå‘½åçš„UUIDç›¸åŒï¼›\n  elf_load_initï¼šå‡†å¤‡å¥½åŠ è½½elfæ‰€éœ€è¦çš„çŠ¶æ€å’Œå¤„ç†å‡½æ•°ï¼›\n  elf_load_headï¼šåŠ è½½elfå¤´ï¼Œupdataå“ˆå¸Œè®¡ç®—ï¼›\n  ä¸ºTAåˆ†é…æ ˆç©ºé—´;\n  get_elf_segmentsï¼šè§£æelfæ®µè¡¨ï¼›\n  elf_load_body: åˆ†æ®µæ‹·è´æ®µå¹¶updateå“ˆå¸Œå€¼ï¼Œæœ€åä¸€æ®µè®¡ç®—æœ€åhashå€¼ä¸ç¬¬ä¸€æ­¥å“ˆå¸Œå€¼æ˜¯å¦ä¸€è‡´ï¼›ä¸€è‡´çš„è¯å®ŒæˆTAåŠ è½½ã€‚\n  ä¹‹åæˆ‘ä»¬æŸ¥çœ‹TAçš„å…¥å£ï¼Œå…¥å£ä¾ç„¶åœ¨load_elf_from_storeä¸­è¢«å®šä¹‰ï¼šæˆ‘ä»¬ç”±TA raw imageå¯ä»¥çœ‹åˆ°ï¼Œç¬¬ä¸€ä¸ªsectionä¸º.ta_head, æˆ‘ä»¬çœ‹ä¸€ä¸‹è¿™ä¸€æ®µçš„ç»“æ„ä½“ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  /* ta/arch/arm/user_ta_header.c */ const struct ta_head ta_head __section(\u0026#34;.ta_head\u0026#34;) = { /* UUID, unique to each TA */ .uuid = TA_UUID, /* * According to GP Internal API, TA_FRAMEWORK_STACK_SIZE corresponds to * the stack size used by the TA code itself and does not include stack * space possibly used by the Trusted Core Framework. * Hence, stack_size which is the size of the stack to use, * must be enlarged */ .stack_size = TA_STACK_SIZE + TA_FRAMEWORK_STACK_SIZE, .flags = TA_FLAGS, #ifdef __ILP32__ \t/* * This workaround is neded on 32-bit because it seems we can\u0026#39;t * initialize a 64-bit integer from the address of a function. */ .entry.ptr32 = { .lo = (uint32_t)__utee_entry }, #else \t.entry.ptr64 = (uint64_t)__utee_entry, #endif };   è¿™ä¸€ä¸ª.sectionå°†é€šè¿‡é“¾æ¥çš„è„šæœ¬ï¼Œåœ¨TAçš„ç¼–è¯‘é“¾æ¥è¿‡ç¨‹ä¸­ä½œä¸ºraw imageçš„ç¬¬ä¸€ä¸ªsection:\n/* ta/arch/arm/ta.ld.S */ SECTIONS { .ta_head : {*(.ta_head)} .text : { __text_start = .; *(.text .text.*) *(.stub) *(.glue_7) *(.glue_7t) *(.gnu.linkonce.t.*) /* Workaround for an erratum in ARM\u0026#39;s VFP11 coprocessor */ *(.vfp11_veneer) __text_end = .; } ... } /* core/arch/arm/kernel/user_ta.c */ static TEE_Result load_elf_from_store(const TEE_UUID *uuid, const struct user_ta_store_ops *ta_store, struct user_ta_ctx *utc) { ... res = get_elf_segments(elf, \u0026amp;segs, \u0026amp;num_segs); for (n = 0; n \u0026lt; num_segs; n++) { ... /* n == 0æ—¶è¿›å…¥è¯¥åˆ†æ”¯ */ if (!n) { elf-\u0026gt;load_addr = segs[0].va; /*elf-\u0026gt;load_addrå°†æŒ‡å‘.ta_headæ®µ*/ DMSG(\u0026#34;ELF load address %#\u0026#34; PRIxVA, elf-\u0026gt;load_addr); } } ... } TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *uuid, struct tee_ta_session *s) { ta_head = (struct ta_head *)(vaddr_t)utc-\u0026gt;load_addr; /* æ­¤å¤„æ¯”è¾ƒelfä¸­è¢«ç­¾åUUIDä¸TAæ–‡ä»¶åUUIDï¼Œä¿è¯æ–‡ä»¶åUUIDæ²¡æœ‰è¢«ç¯¡æ”¹ */ if (memcmp(\u0026amp;ta_head-\u0026gt;uuid, uuid, sizeof(TEE_UUID)) != 0) { res = TEE_ERROR_SECURITY; goto err; } ... utc-\u0026gt;ctx.flags = ta_head-\u0026gt;flags; utc-\u0026gt;ctx.uuid = ta_head-\u0026gt;uuid; utc-\u0026gt;entry_func = ta_head-\u0026gt;entry.ptr64; /* å³__utee_entry */ ... } å¯ä»¥çœ‹åˆ°TAçš„å…¥å£ä¸º__utee_entryï¼Œä¹‹åæˆ‘ä»¬å°†å…³æ³¨TEE_kernelæ€ä¹ˆè¿›è¡Œå±‚çº§åˆ‡æ¢è¿›å…¥sel0çš„TA.\nTEE_kernel -\u0026gt; TA æˆ‘ä»¬å›åˆ°tee_ta_open_sessionå‡½æ•°ï¼Œå®Œæˆsessionå»ºç«‹å’ŒTAåŠ è½½åï¼Œå¼€å§‹å‡†å¤‡è¿›å…¥sel0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  /* core/kernel/tee_ta_manager.c */ TEE_Result tee_ta_open_session(TEE_ErrorOrigin *err, struct tee_ta_session **sess, struct tee_ta_session_head *open_sessions, const TEE_UUID *uuid, const TEE_Identity *clnt_id, uint32_t cancel_req_to, struct tee_ta_param *param) { TEE_Result res; struct tee_ta_session *s = NULL; struct tee_ta_ctx *ctx; bool panicked; bool was_busy = false; res = tee_ta_init_session(err, open_sessions, uuid, \u0026amp;s); if (res != TEE_SUCCESS) { DMSG(\u0026#34;init session failed 0x%x\u0026#34;, res); return res; } ... if (tee_ta_try_set_busy(ctx)) { set_invoke_timeout(s, cancel_req_to); res = ctx-\u0026gt;ops-\u0026gt;enter_open_session(s, param, err); /* æ­¤å¤„å¼€å§‹å‡†å¤‡åˆ‡æ¢å±‚çº§ */ tee_ta_clear_busy(ctx); } else { /* Deadlock avoided */ res = TEE_ERROR_BUSY; was_busy = true; } ... }   ctx-\u0026gt;opsåœ¨tee_ta_init_user_ta_sessionä¸­å·²ç»å®ŒæˆæŒ‚è½½:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  /* core/arch/arm/kernel/user_ta.c */ TEE_Result tee_ta_init_user_ta_session(const TEE_UUID *uuid, struct tee_ta_session *s) { ... /* * Set context TA operation structure. It is required by generic * implementation to identify userland TA versus pseudo TA contexts. */ set_ta_ctx_ops(\u0026amp;utc-\u0026gt;ctx); ... } static const struct tee_ta_ops user_ta_ops __rodata_unpaged = { .enter_open_session = user_ta_enter_open_session, /* enter_open_session æŒ‚è½½ç‚¹ */ .enter_invoke_cmd = user_ta_enter_invoke_cmd, .enter_close_session = user_ta_enter_close_session, .dump_state = user_ta_dump_state, .destroy = user_ta_ctx_destroy, .get_instance_id = user_ta_get_instance_id, }; /* * Break unpaged attribute dependency propagation to user_ta_ops structure * content thanks to a runtime initialization of the ops reference. */ static struct tee_ta_ops const *_user_ta_ops; static TEE_Result init_user_ta(void) { _user_ta_ops = \u0026amp;user_ta_ops; return TEE_SUCCESS; } service_init(init_user_ta); /* opteeå¯åŠ¨æ—¶å°†åˆå§‹åŒ–user_ta_ops */ static void set_ta_ctx_ops(struct tee_ta_ctx *ctx) { ctx-\u0026gt;ops = _user_ta_ops; } /* res = ctx-\u0026gt;ops-\u0026gt;enter_open_session(s, param, err)çš„å…¥å£ */ static TEE_Result user_ta_enter_open_session(struct tee_ta_session *s, struct tee_ta_param *param, TEE_ErrorOrigin *eo) { return user_ta_enter(eo, s, UTEE_ENTRY_FUNC_OPEN_SESSION, 0, param); } static TEE_Result user_ta_enter(TEE_ErrorOrigin *err, struct tee_ta_session *session, enum utee_entry_func func, uint32_t cmd, struct tee_ta_param *param) { TEE_Result res; struct utee_params *usr_params; uaddr_t usr_stack; struct user_ta_ctx *utc = to_user_ta_ctx(session-\u0026gt;ctx); TEE_ErrorOrigin serr = TEE_ORIGIN_TEE; struct tee_ta_session *s __maybe_unused; void *param_va[TEE_NUM_PARAMS] = { NULL }; /* Map user space memory */ res = tee_mmu_map_param(utc, param, param_va); if (res != TEE_SUCCESS) goto cleanup_return; /* Switch to user ctx */ tee_ta_push_current_session(session); /* Make room for usr_params at top of stack */ usr_stack = utc-\u0026gt;stack_addr + utc-\u0026gt;mobj_stack-\u0026gt;size; usr_stack -= ROUNDUP(sizeof(struct utee_params), STACK_ALIGNMENT); usr_params = (struct utee_params *)usr_stack; init_utee_param(usr_params, param, param_va); /* å°†ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´éƒ½å‡†å¤‡å¥½åï¼Œå¼€å§‹å±‚çº§åˆ‡æ¢ */ res = thread_enter_user_mode(func, tee_svc_kaddr_to_uref(session), (vaddr_t)usr_params, cmd, usr_stack, utc-\u0026gt;entry_func, utc-\u0026gt;is_32bit, \u0026amp;utc-\u0026gt;ctx.panicked, \u0026amp;utc-\u0026gt;ctx.panic_code); ... } uint32_t thread_enter_user_mode(unsigned long a0, unsigned long a1, unsigned long a2, unsigned long a3, unsigned long user_sp, unsigned long entry_func, bool is_32bit, uint32_t *exit_status0, uint32_t *exit_status1) { uint32_t spsr; tee_ta_update_session_utime_resume(); if (!get_spsr(is_32bit, entry_func, \u0026amp;spsr)) { *exit_status0 = 1; /* panic */ *exit_status1 = 0xbadbadba; return 0; } /* a0: æŒ‡ç¤ºè¿›å…¥TAçš„æ“ä½œï¼Œå¦‚open_Sessionå°±æ˜¯UTEE_ENTRY_FUNC_OPEN_SESSION * a1: sessionç»“æ„ä½“åœ°å€ * a2: ç”¨æˆ·æ€ä¼ é€’è¿‡æ¥çš„param * a3: invoke_cmdä½¿ç”¨çš„cmdï¼Œ open_sessionæ—¶ä¸º0 * sp: kernelç»™TAåˆ†é…çš„æ ˆç©ºé—´ * entry_func: sel0 TAå…¥å£ * spsr:ä¹‹å‰ä¿å­˜ä¸‹æ¥çš„sel0çš„CPUçŠ¶æ€å¯„å­˜å™¨çš„å€¼ */ return __thread_enter_user_mode(a0, a1, a2, a3, user_sp, entry_func, spsr, exit_status0, exit_status1); }   __thread_enter_user_modeè¿›å…¥ä¸€æ®µæ±‡ç¼–ï¼Œå±‚çº§åˆ‡æ¢åŸºæœ¬æ€è·¯ç›¸åŒï¼Œä¿å­˜å½“å‰CPUçŠ¶æ€å¯„å­˜å™¨ï¼ŒåŠ è½½sel0çš„å¯„å­˜å™¨ä¸Šä¸‹æ–‡ï¼ŒåŒæ—¶æŒ‡å®šeretçš„åœ°å€ï¼Œè§¦å‘eret\n/* core/arch/arm/kernel/thread_a64.S */ FUNC __thread_enter_user_mode , : ldr\tx8, [sp] /* * Create the and fill in the struct thread_user_mode_rec */ sub\tsp, sp, #THREAD_USER_MODE_REC_SIZE store_xregs sp, THREAD_USER_MODE_REC_EXIT_STATUS0_PTR, 7, 8 store_xregs sp, THREAD_USER_MODE_REC_X19, 19, 30 /* * Switch to SP_EL1 * Disable exceptions * Save kern sp in x19 */ msr\tdaifset, #DAIFBIT_ALL mov\tx19, sp msr\tspsel, #1 /* * Save the kernel stack pointer in the thread context */ /* get pointer to current thread context */ get_thread_ctx sp, 21, 20, 22 /* * Save kernel stack pointer to ensure that el0_svc() uses * correct stack pointer */ str\tx19, [x21, #THREAD_CTX_KERN_SP] /* * Initialize SPSR, ELR_EL1, and SP_EL0 to enter user mode */ msr\tspsr_el1, x6 /* Set user sp */ mov\tx13, x4\t/* Used when running TA in Aarch32 */ msr\tsp_el0, x4\t/* Used when running TA in Aarch64 */ /* Set user function */ /* ta entry_func */ msr\telr_el1, x5 /* Set frame pointer (user stack can\u0026#39;t be unwound past this point) */ mov x29, #0 /* Jump into user mode */ store_xregs sp, THREAD_CORE_LOCAL_X0, 0, 1 /* åˆ‡æ¢é¡µè¡¨ï¼ŒTEEä¸ºæ¯ä¸ªTAæä¾›ttbr0ä¸­çš„ä¸€æ®µä½œä¸ºå†…å­˜æ˜ å°„ç©ºé—´(L1); eretå±‚çº§åˆ‡æ¢ */ b eret_to_el0 /* è¿›å…¥TAï¼Œ å³ä¸Šæ–‡æ‰€è¯´ta entry_funcï¼š __utee_entry */ END_FUNC __thread_enter_user_mode TAå…¥å£ è¿™ä¸€æ®µå°±éå¸¸ç®€å•äº†ï¼Œç›´æ¥çœ‹ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58  /* lib/libutee/arch/arm/user_ta_entry.c */ void __noreturn __utee_entry(unsigned long func, unsigned long session_id, struct utee_params *up, unsigned long cmd_id) { TEE_Result res; switch (func) { /* å³å¯„å­˜å™¨r0çš„å€¼ï¼Œ UTEE_ENTRY_FUNC_OPEN_SESSION*/ case UTEE_ENTRY_FUNC_OPEN_SESSION: res = entry_open_session(session_id, up); break; case UTEE_ENTRY_FUNC_CLOSE_SESSION: res = entry_close_session(session_id); break; case UTEE_ENTRY_FUNC_INVOKE_COMMAND: res = entry_invoke_command(session_id, up, cmd_id); break; default: res = 0xffffffff; TEE_Panic(0); break; } ta_header_save_params(0, NULL); utee_return(res); } static TEE_Result entry_open_session(unsigned long session_id, struct utee_params *up) { TEE_Result res; struct ta_session *session; uint32_t param_types; TEE_Param params[TEE_NUM_PARAMS]; /* ä¸ºTAæŒ‡å®šä¸Šsessionï¼Œ æ³¨æ„ä¸€ä¸ªTAå¯èƒ½è¢«å¤šä¸ªCAè°ƒç”¨ï¼Œæœ‰å¤šä¸ªsession */ res = ta_header_add_session(session_id); if (res != TEE_SUCCESS) return res; session = ta_header_get_session(session_id); if (!session) return TEE_ERROR_BAD_STATE; /* ç»è¿‡æ¼«é•¿è¿‡ç¨‹ç»ˆäºä¼ é€’åˆ°TAçš„ï¼Œ CAå†™ä¸‹çš„param */ __utee_to_param(params, \u0026amp;param_types, up); ta_header_save_params(param_types, params); /* æœ€ä¸Šå±‚æ‰€è¯´çš„GPæ¥å£ï¼Œ åœ¨TAçš„SDKä¸­ï¼Œ ç”±ç”¨æˆ·å®ç°æ­¤æ¥å£ */ res = TA_OpenSessionEntryPoint(param_types, params, \u0026amp;session-\u0026gt;session_ctx); __utee_from_param(up, param_types, params); if (res != TEE_SUCCESS) ta_header_remove_session(session_id); return res; }   å®Œæˆæ“ä½œåï¼Œå°†ä¸€æ­¥æ­¥è¿”å›åˆ°CAï¼ŒåŸºæœ¬åŸè·¯è¿”å›æ‰€ä»¥æ„æˆç±»ä¼¼ä¸ç»†è¯´äº†ã€‚ ç»ˆäºä¸€æ®µæ¼«é•¿çš„open_sessionçš„è¿‡ç¨‹ç»“æŸäº†ã€‚\nTAä¸­GPæ ‡å‡†å®ç°æ¥å£ å‚è€ƒå®˜æ–¹æ–‡æ¡£ï¼šhttps://optee.readthedocs.io/en/latest/architecture/globalplatform_api.html\nTEE-\u0026gt;tee-supplicant-\u0026gt;TEE(RPCè¯·æ±‚) é¦–å…ˆæˆ‘ä»¬è¦çŸ¥é“tee-supplicantæ˜¯å•¥ï¼š\n tee_supplicantçš„ä¸»è¦ä½œç”¨æ˜¯ä½¿OP-TEEèƒ½å¤Ÿé€šè¿‡tee_supplicantæ¥è®¿é—®REEç«¯æ–‡ä»¶ç³»ç»Ÿä¸­çš„èµ„æºï¼Œä¾‹å¦‚åŠ è½½å­˜æ”¾åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„TAé•œåƒåˆ°TEEä¸­ï¼Œå¯¹REEç«¯æ•°æ®åº“çš„æ“ä½œï¼Œå¯¹EMMCä¸­RPMBåˆ†åŒºçš„æ“ä½œï¼Œæä¾›socketé€šä¿¡ç­‰ã€‚ å…¶æºä»£ç optee_client/tee-supplicantç›®å½•ä¸­ã€‚ç¼–è¯‘ä¹‹åä¼šç”Ÿæˆä¸€ä¸ªåå­—ä¸ºtee_supplicantçš„å¯æ‰§è¡Œæ–‡ä»¶ï¼Œè¯¥å¯æ‰§è¡Œæ–‡ä»¶åœ¨REEå¯åŠ¨çš„æ—¶å€™ä¼šä½œä¸ºä¸€ä¸ªåå°ç¨‹åºè¢«è‡ªåŠ¨å¯åŠ¨ï¼Œè€Œä¸”å¸¸é©»äºç³»ç»Ÿä¸­ã€‚\nåŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/shuaifengyun/java/article/details/72912238\n å…¶å®å°±æ˜¯ä¸€ä¸ªå¸¸é©»åœ¨éå®‰å…¨ä¾§ï¼Œç”¨äºå“åº”TEEä¸€äº›éœ€è¦åœ¨éå®‰å…¨ä¾§å®Œæˆçš„è¯·æ±‚çš„ä¸€ä¸ªç”¨æˆ·æ€æœåŠ¡å®ˆæŠ¤è¿›ç¨‹ã€‚æ—¢ç„¶æ˜¯åœ¨è¿è¡Œåœ¨ç”¨æˆ·æ€ï¼Œæƒ³å¿…ä¸­é—´åˆè¦ç»è¿‡ATF-\u0026gt;tee_driver-\u0026gt;tee_supplicantçš„æµç¨‹ã€‚\nTEEçš„å®˜æ–¹æ–‡æ¡£æœ‰ä¸€ä¸ªTEEå‘é€è¯·æ±‚åŠ è½½TAçš„æµç¨‹å›¾ï¼ˆOPTEEä¸­é€šå¸¸æŠŠè¿™ç§è¯·æ±‚å«åšRPCï¼‰ï¼Œæˆ‘ä»¬é¦–å…ˆç•™ä¸‹ä¸€ä¸ªå®Œæ•´çš„å°è±¡ï¼š\næˆ‘ä»¬è¿˜æ˜¯ä»TAåŠ è½½éƒ¨åˆ†å¼€å§‹è¯´èµ·ï¼Œç¬¬ä¸€æ­¥æ¢æŸ¥TEEå‘é€rpcå‘½ä»¤åˆ°éå®‰å…¨ä¾§tee_driverçš„æ“ä½œï¼š\nTEE-\u0026gt;tee_driver ä¸€åˆ‡è¦ä»ta_store-\u0026gt;open(uuid, \u0026amp;handle)ä¸ŠæŒ‚è½½çš„ree_fs_ta_openå‡½æ•°è¯´èµ·ï¼šä»–å°†è°ƒç”¨rpc_load, è¿™æ˜¯TEEå‘é€rpcè¯·æ±‚åˆ°éå®‰å…¨ä¾§çš„èµ·ç‚¹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  /* core/arch/arm/kernel/ree_fs_ta.c */ static TEE_Result ree_fs_ta_open(const TEE_UUID *uuid, struct user_ta_store_handle **h) { ... /* Request TA from tee-supplicant */ res = rpc_load(uuid, \u0026amp;ta, \u0026amp;ta_size, \u0026amp;mobj); if (res != TEE_SUCCESS) goto error; ... } static TEE_Result rpc_load(const TEE_UUID *uuid, struct shdr **ta, size_t *ta_size, struct mobj **mobj) { TEE_Result res; struct thread_param params[2]; if (!uuid || !ta || !mobj || !ta_size) return TEE_ERROR_BAD_PARAMETERS; memset(params, 0, sizeof(params)); params[0].attr = THREAD_PARAM_ATTR_VALUE_IN; /* å°†è¯·æ±‚çš„UUIDå†™å…¥å‚æ•°ä¸­ */ tee_uuid_to_octets((void *)\u0026amp;params[0].u.value, uuid); params[1].attr = THREAD_PARAM_ATTR_MEMREF_OUT; /* å‘é€ç¬¬ä¸€ä¸ªrpcï¼Œæœ‰ä¸‹é¢å¯ä»¥çœ‹åˆ°è¯·æ±‚åˆ°çš„æ˜¯TAæ–‡ä»¶çš„size */ res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params); if (res != TEE_SUCCESS) return res; /* å‘é€ç¬¬äºŒä¸ªrpcï¼Œæ ¹æ®è¯»å–åˆ°çš„TA sizeç”³è¯·å…±äº«å†…å­˜ */ *mobj = thread_rpc_alloc_payload(params[1].u.memref.size); if (!*mobj) return TEE_ERROR_OUT_OF_MEMORY; if ((*mobj)-\u0026gt;size \u0026lt; params[1].u.memref.size) { res = TEE_ERROR_SHORT_BUFFER; goto exit; } *ta = mobj_get_va(*mobj, 0); /* We don\u0026#39;t expect NULL as thread_rpc_alloc_payload() was successful */ assert(*ta); *ta_size = params[1].u.memref.size; params[0].attr = THREAD_PARAM_ATTR_VALUE_IN; tee_uuid_to_octets((void *)\u0026amp;params[0].u.value, uuid); params[1].attr = THREAD_PARAM_ATTR_MEMREF_OUT; params[1].u.memref.offs = 0; params[1].u.memref.mobj = *mobj; /* å‘é€ç¬¬ä¸‰ä¸ªrpcï¼Œå°†TAé¦–å…ˆåŠ è½½å¦‚å…±äº«å†…å­˜å½“ä¸­ */ res = thread_rpc_cmd(OPTEE_RPC_CMD_LOAD_TA, 2, params); exit: if (res != TEE_SUCCESS) thread_rpc_free_payload(*mobj); return res; }   å¯ä»¥çœ‹åˆ°thread_rpc_cmdæ˜¯å‘é€rpcè¯·æ±‚çš„æ¥å£ï¼Œç›´æ¥åˆ†æï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  /* core/arch/arm/kernel/thread.c */ uint32_t thread_rpc_cmd(uint32_t cmd, size_t num_params, struct thread_param *params) { uint32_t rpc_args[THREAD_RPC_NUM_ARGS] = { OPTEE_SMC_RETURN_RPC_CMD }; void *arg = NULL; uint64_t carg = 0; uint32_t ret = 0; /* å¥—è·¯å’Œdriverè¿›å…¥TEEé©±åŠ¨åŸºæœ¬ä¸€è‡´ï¼Œè¿˜æ˜¯ä½¿ç”¨optee_msg_argç»“æ„ä½“ï¼Œ * å‡†å¤‡å¥½cmdå¡«åœ¨msg-\u0026gt;cmdï¼Œ paramså¤åˆ¶åˆ°msg-\u0026gt;params; * ç„¶åè·å–ç»“æ„ä½“çš„åœ°å€çš„mobjæè¿°å—çš„ç‰©ç†åœ°å€ï¼Œåç»­å°†å¡«å…¥r1, r2, r0å¡«å…¥OPTEE_SMC_RETURN_RPC_CMD */ /* The source CRYPTO_RNG_SRC_JITTER_RPC is safe to use here */ plat_prng_add_jitter_entropy(CRYPTO_RNG_SRC_JITTER_RPC, \u0026amp;thread_rpc_pnum); /* äº‹å®ä¸Šï¼Œå½“ç¬¬ä¸€æ¬¡è°ƒç”¨å¸¦æœ‰paramsçš„thread_rpc_cmdéœ€è¦å®Œæˆä¸¤æ¬¡å®‰å…¨ä¸éå®‰å…¨çš„åˆ‡æ¢ * é¦–å…ˆéœ€è¦è·å–ä¸€å—å…±äº«å†…å­˜æè¿°å—çš„ç‰©ç†åœ°å€ï¼Œç”¨äºparamsçš„é€šè®¯ã€‚ */ ret = get_rpc_arg(cmd, num_params, params, \u0026amp;arg, \u0026amp;carg); if (ret) return ret; reg_pair_from_64(carg, rpc_args + 1, rpc_args + 2); /* å¾ˆæ˜æ˜¾thread_rpcæ˜¯ä¸€æ®µæ±‡ç¼–ï¼Œå°†è§¦å‘smcï¼Œè¿›å…¥ATFååˆ‡æ¢å›tee_driver */ thread_rpc(rpc_args); return get_rpc_arg_res(arg, num_params, params); }   /* core/arch/arm/kernel/thread_a64.S */ /* æ“ä½œä¹Ÿæ˜¯ç±»ä¼¼ï¼Œ ä¿å­˜å¥½å¯„å­˜å™¨ä¸Šä¸‹æ–‡ï¼Œè§¦å‘smc, è¿›å…¥ATFï¼Œ ATFå°†å¼•å¯¼è¿›å…¥tee_driverå…¥å£ */ /* void thread_rpc(uint32_t rv[THREAD_RPC_NUM_ARGS]) */ FUNC thread_rpc , : /* Read daif and create an SPSR */ mrs\tx1, daif orr\tx1, x1, #(SPSR_64_MODE_EL1 \u0026lt;\u0026lt; SPSR_64_MODE_EL_SHIFT) /* Mask all maskable exceptions before switching to temporary stack */ msr\tdaifset, #DAIFBIT_ALL push\tx0, xzr push\tx1, x30 bl\tthread_get_ctx_regs ldr\tx30, [sp, #8] /* æ¢å¤rpcè¿”å›çš„åœ°å€ */ store_xregs x0, THREAD_CTX_REGS_X19, 19, 30 /* è¿”å›åœ°å€åœ¨thread.reg[30] */ mov\tx19, x0 bl\tthread_get_tmp_sp pop\tx1, xzr\t/* Match \u0026#34;push x1, x30\u0026#34; above */ mov\tx2, sp str\tx2, [x19, #THREAD_CTX_REGS_SP] ldr\tx20, [sp]\t/* Get pointer to rv[] */ mov\tsp, x0\t/* Switch to tmp stack */ /* * We need to read rv[] early, because thread_state_suspend * can invoke virt_unset_guest() which will unmap pages, * where rv[] resides */ load_wregs x20, 0, 21, 23\t/* Load rv[] into w20-w22 */ adr\tx2, .thread_rpc_return /* æ³¨æ„ï¼Œæ­¤å¤„æœ‰ä¸€å¤„é‡è¦çš„ç‚¹ï¼Œè¿™é‡ŒæŒ‡å®šä¸Šçš„rpcè¿”å›teeåthreadçš„å…¥å£ */ mov\tw0, #THREAD_FLAGS_COPY_ARGS_ON_RETURN bl\tthread_state_suspend mov\tx4, x0\t/* Supply thread index */ ldr\tw0, =TEESMC_OPTEED_RETURN_CALL_DONE mov\tx1, x21 mov\tx2, x22 mov\tx3, x23 smc\t#0 /* CPUè¿›å…¥el3ï¼Œä¹‹ååˆ‡å›éå®‰å…¨ä¾§el1ï¼Œè¿›å…¥tee_driver */ b\t.\t/* SMC should not return */ 1 2 3 4 5 6 7 8 9 10 11 12 13 14  /* core/arch/arm/kernel/thread.c */ int thread_state_suspend(uint32_t flags, uint32_t cpsr, vaddr_t pc) { struct thread_core_local *l = thread_get_core_local(); int ct = l-\u0026gt;curr_thread; ... assert(threads[ct].state == THREAD_STATE_ACTIVE); /* æ¢å¤threadåçš„pcæ­¤å¤„æŒ‡å®šï¼šthread_rpc_return*/ threads[ct].flags |= flags; threads[ct].regs.cpsr = cpsr; threads[ct].regs.pc = pc; threads[ct].state = THREAD_STATE_SUSPENDED; ... }   tee-supplicantä¸tee_driverçš„ååŒ  å½“libteecè°ƒç”¨é©±åŠ¨æ¥ä¸OP-TEEè¿›è¡Œæ•°æ®çš„äº¤äº’çš„æ—¶å€™ï¼Œæœ€ç»ˆä¼šè°ƒç”¨optee_do_call_with_argå‡½æ•°å®Œæˆå®Œæˆsmcçš„æ“ä½œï¼Œè€Œè¯¥å‡½æ•°ä¸­æœ‰ä¸€ä¸ªloopå¾ªç¯ï¼Œæ¯æ¬¡è§¦å‘smcæ“ä½œä¹‹åä¼šå¯¹ä»secure worldä¸­è¿”å›çš„å‚æ•°res.a0è¿›è¡Œåˆ¤æ–­ï¼Œåˆ¤å®šå½“å‰ä»secure worldè¿”å›çš„æ•°æ®æ˜¯è¦æ‰§è¡ŒRPCæ“ä½œè¿˜æ˜¯ç›´æ¥è¿”å›åˆ°CAã€‚å¦‚æœæ˜¯æ¥è‡ªTEEçš„RPCè¯·æ±‚ï¼Œåˆ™ä¼šå°†è¯·æ±‚å­˜æ”¾åˆ°è¯·æ±‚é˜Ÿåˆ—reqä¸­ã€‚ç„¶åblockä½ï¼Œç›´åˆ°tee_supplicantå¤„ç†å®Œè¯·æ±‚å¹¶å°†req-\u0026gt;cæ ‡è®°ä¸ºå®Œæˆä¹‹åæ‰ä¼šè¿›å…¥ä¸‹ä¸€ä¸ªloopï¼Œé‡æ–°å‡ºå‘smcæ“ä½œï¼Œå°†å¤„ç†ç»“æœè¿”å›ç»™TEEã€‚\nåŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/shuaifengyun/java/article/details/73061002\n æ‰€ä»¥ç¬¬ä¸€æ­¥æˆ‘ä»¬æ‰¾åˆ°ç¬¬ä¸€æ¬¡å‘é€smc_callçš„åœ°æ–¹ï¼Œçœ‹ä»–ä¹‹ååšäº†å•¥ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  /* driver/tee/optee/call.c */ u32 optee_do_call_with_arg(struct tee_context *ctx, phys_addr_t parg) { ... while (true) { struct arm_smccc_res res; optee_bm_timestamp(); /* smcè°ƒç”¨ç‚¹ */ optee-\u0026gt;invoke_fn(param.a0, param.a1, param.a2, param.a3, param.a4, param.a5, param.a6, param.a7, \u0026amp;res); optee_bm_timestamp(); if (res.a0 == OPTEE_SMC_RETURN_ETHREAD_LIMIT) { /* * Out of threads in secure world, wait for a thread * become available. */ optee_cq_wait_for_completion(\u0026amp;optee-\u0026gt;call_queue, \u0026amp;w); } else if (OPTEE_SMC_RETURN_IS_RPC(res.a0)) { /* æ­¤å¤„çš„r0ç”±teeå¡«å†™ï¼Œå¤„ç†rpcè¿›å…¥*/ might_sleep(); param.a0 = res.a0; param.a1 = res.a1; param.a2 = res.a2; param.a3 = res.a3; /* å¤„ç†rpcå‡½æ•° */ optee_handle_rpc(ctx, \u0026amp;param, \u0026amp;call_ctx); } else { ret = res.a0; break; } } }   åç»­æµç¨‹å°±ä¸ä¸Šæºç äº†ï¼Œé€šè¿‡å‡ ä¸ªå¾ˆç®€å•çš„å‡ ä¸ªswitchæ‰¾åˆ°å¯¹åº”çš„å¤„ç†å‡½æ•°, å¹¶ä¸”é€šè¿‡ç‰©ç†r1å’Œr2ä¼ é€’è¿‡æ¥çš„ç‰©ç†åœ°å€è·å–çš„å…±äº«å†…å­˜å—ï¼Œç»“æ„ä½“ä¸­å¯ä»¥å–åˆ°paramså†™å…¥çš„åœ¨éå®‰å…¨ä¾§æ˜ å°„çš„è™šæ‹Ÿåœ°å€ï¼š\noptee_handle_rpc-\u0026gt;handle_rpc_func_cmd(åœ¨å†…æ ¸èƒ½è§£å†³æ‰çš„è¯·æ±‚éƒ½åœ¨è¿™é‡Œå¤„ç†å®Œæˆäº†)-\u0026gt;handle_rpc_supp_cmdï¼ˆéœ€è¦åŠ¨ç”¨åˆ°tee-supplicantçš„è¯·æ±‚åˆ°è¿™é‡Œï¼‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104  /* driver/tee/optee/rpc.c */ static void handle_rpc_supp_cmd(struct tee_context *ctx, struct optee_msg_arg *arg) { struct tee_param *params; arg-\u0026gt;ret_origin = TEEC_ORIGIN_COMMS; params = kmalloc_array(arg-\u0026gt;num_params, sizeof(struct tee_param), GFP_KERNEL); if (!params) { arg-\u0026gt;ret = TEEC_ERROR_OUT_OF_MEMORY; return; } /* å°†paramsä»å…±äº«å†…å­˜ä¸­æ‹·è´åˆ°éå®‰å…¨ä¾§driverçš„å†…å­˜ä¸­ */ if (optee_from_msg_param(params, arg-\u0026gt;num_params, arg-\u0026gt;params)) { arg-\u0026gt;ret = TEEC_ERROR_BAD_PARAMETERS; goto out; } /* å°†cmdé€å…¥tee-supplicantçš„å¤„ç†é˜Ÿåˆ—ä¸­ */ arg-\u0026gt;ret = optee_supp_thrd_req(ctx, arg-\u0026gt;cmd, arg-\u0026gt;num_params, params); if (optee_to_msg_param(arg-\u0026gt;params, arg-\u0026gt;num_params, params)) arg-\u0026gt;ret = TEEC_ERROR_BAD_PARAMETERS; out: kfree(params); } /* driver/tee/optee/supp.c */ u32 optee_supp_thrd_req(struct tee_context *ctx, u32 func, size_t num_params, struct tee_param *param) { struct optee *optee = tee_get_drvdata(ctx-\u0026gt;teedev); struct optee_supp *supp = \u0026amp;optee-\u0026gt;supp; struct optee_supp_req *req = kzalloc(sizeof(*req), GFP_KERNEL); bool interruptable; u32 ret; if (!req) return TEEC_ERROR_OUT_OF_MEMORY; /* åˆå§‹åŒ–è¯¥è¯·æ±‚æ¶ˆæ¯çš„cæˆå‘˜å¹¶é…ç½®è¯·æ±‚æ•°æ® */ init_completion(\u0026amp;req-\u0026gt;c); req-\u0026gt;func = func; req-\u0026gt;num_params = num_params; req-\u0026gt;param = param; /* Insert the request in the request list */ /* å°†æ¥å—åˆ°çš„è¯·æ±‚æ·»åŠ åˆ°é©±åŠ¨çš„TEEè¯·æ±‚æ¶ˆæ¯é˜Ÿåˆ—ä¸­ */ mutex_lock(\u0026amp;supp-\u0026gt;mutex); list_add_tail(\u0026amp;req-\u0026gt;link, \u0026amp;supp-\u0026gt;reqs); mutex_unlock(\u0026amp;supp-\u0026gt;mutex); /* Tell an eventual waiter there\u0026#39;s a new request */ /* å°†supp-\u0026gt;reqs_cç½®ä½ï¼Œé€šçŸ¥tee_supplicantçš„receiveæ“ä½œï¼Œå½“å‰é©±åŠ¨ä¸­ æœ‰ä¸€ä¸ªæ¥è‡ªTEEçš„è¯·æ±‚ */ complete(\u0026amp;supp-\u0026gt;reqs_c); /* * Wait for supplicant to process and return result, once we\u0026#39;ve * returned from wait_for_completion(\u0026amp;req-\u0026gt;c) successfully we have * exclusive access again. */ /* blockåœ¨è¿™é‡Œï¼Œé€šè¿‡åˆ¤å®šreq-\u0026gt;cæ˜¯å¦è¢«ç½®ä½æ¥åˆ¤å®šå½“å‰è¯·æ±‚æ˜¯å¦è¢«å¤„ç†å®Œæ¯•ï¼Œ è€Œreq-\u0026gt;cçš„ç½®ä½æ˜¯æœ‰tee_supplicantçš„sendè°ƒç”¨æ¥å®Œæˆçš„ï¼Œå¦‚æœè¢«ç½®ä½ï¼Œåˆ™è¿›å…¥åˆ° whileå¾ªç¯ä¸­è¿›è¡Œè¿”å›å€¼çš„è®¾å®šå¹¶è·³å‡ºwhile*/ while (wait_for_completion_interruptible(\u0026amp;req-\u0026gt;c)) { mutex_lock(\u0026amp;supp-\u0026gt;mutex); interruptable = !supp-\u0026gt;ctx; if (interruptable) { /* * There\u0026#39;s no supplicant available and since the * supp-\u0026gt;mutex currently is held none can * become available until the mutex released * again. * * Interrupting an RPC to supplicant is only * allowed as a way of slightly improving the user * experience in case the supplicant hasn\u0026#39;t been * started yet. During normal operation the supplicant * will serve all requests in a timely manner and * interrupting then wouldn\u0026#39;t make sense. */ interruptable = !req-\u0026gt;busy; if (!req-\u0026gt;busy) list_del(\u0026amp;req-\u0026gt;link); } mutex_unlock(\u0026amp;supp-\u0026gt;mutex); if (interruptable) { req-\u0026gt;ret = TEEC_ERROR_COMMUNICATION; break; } } ret = req-\u0026gt;ret; kfree(req); return ret; }   æ¥çœ‹çœ‹tee-supplicantæ˜¯å¦‚ä½•æ¥æ”¶åˆ°è¿™ä¸ªrequestçš„ï¼Œå…ˆæ¥ä¸€ä¸ªtee-supplicantçš„æ€»ä½“æµç¨‹ï¼š\ntee-supplicantåœ¨ç³»ç»Ÿå¯åŠ¨æ—¶å°±å°†å¯åŠ¨èµ·æ¥ï¼Œå¸¸é©»åœ¨ç”¨æˆ·æ€ï¼Œé™·å…¥ä¸€ä¸ªæ— é™å¾ªç¯ç­‰å¾…æ¥æ”¶requestï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  /* optee_client/tee-supplicant/src/tee_supplicant.c */ int main(int argc, char *argv[]) { struct thread_arg arg = { .fd = -1 }; int e; /* åˆå§‹åŒ–äº’æ–¥ä½“ */ e = pthread_mutex_init(\u0026amp;arg.mutex, NULL); if (e) { EMSG(\u0026#34;pthread_mutex_init: %s\u0026#34;, strerror(e)); EMSG(\u0026#34;terminating...\u0026#34;); exit(EXIT_FAILURE); } /* åˆ¤å®šæ˜¯å¦å¸¦æœ‰å¯åŠ¨å‚æ•°ï¼Œå¦‚æœå¸¦æœ‰å¯åŠ¨å‚æ•°ï¼Œåˆ™æ‰“å¼€å¯¹åº”çš„é©±åŠ¨æ–‡ä»¶ å¦‚æœæ²¡æœ‰å¸¦å‚æ•°ï¼Œåˆ™æ‰“å¼€é»˜è®¤çš„é©±åŠ¨æ–‡ä»¶ */ if (argc \u0026gt; 2) return usage(); if (argc == 2) { arg.fd = open_dev(argv[1]); if (arg.fd \u0026lt; 0) { EMSG(\u0026#34;failed to open \\\u0026#34;%s\\\u0026#34;\u0026#34;, argv[1]); exit(EXIT_FAILURE); } } else { /*æ‰“å¼€/dev/teepriv0è®¾å¤‡ï¼Œè¯¥è®¾å¤‡ä¸ºteeé©±åŠ¨è®¾å¤‡æ–‡ä»¶ï¼Œè¿”å›æ“ä½œå¥æŸ„*/ arg.fd = get_dev_fd(); if (arg.fd \u0026lt; 0) { EMSG(\u0026#34;failed to find an OP-TEE supplicant device\u0026#34;); exit(EXIT_FAILURE); } } if (tee_supp_fs_init() != 0) { EMSG(\u0026#34;error tee_supp_fs_init\u0026#34;); exit(EXIT_FAILURE); } if (sql_fs_init() != 0) { EMSG(\u0026#34;sql_fs_init() failed \u0026#34;); exit(EXIT_FAILURE); } /* è°ƒç”¨process_one_requestå‡½æ•°æ¥æ”¶æ¥è‡ªTEEçš„è¯·æ±‚ï¼Œå¹¶åŠ ä»¥å¤„ç† */ while (!arg.abort) { if (!process_one_request(\u0026amp;arg)) arg.abort = true; } close(arg.fd); return EXIT_FAILURE; }   ä¹‹åçš„å¤„ç†ï¼Œå¤§ä½¬çš„åšå®¢æ€»ç»“çš„å·²ç»å¾ˆå®Œæ•´äº†ï¼Œç›´æ¥è‡ªå–å§ï¼š\nhttps://blog.csdn.net/shuaifengyun/article/details/72912238\næˆ‘ä»¬ä¸»è¦çœ‹write_responseä¹‹åï¼Œtee_driveræ˜¯æ€ä¹ˆåšçš„:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110  /* optee_client/tee-supplicant/src/tee_supplicant.c */ static bool write_response(int fd, union tee_rpc_invoke *request) { struct tee_ioctl_buf_data data; /* å°†éœ€è¦è¿”å›ç»™TAçš„æ•°æ®å­˜æ”¾åœ¨bufferä¸­ */ data.buf_ptr = (uintptr_t)\u0026amp;request-\u0026gt;send; data.buf_len = sizeof(struct tee_iocl_supp_send_arg) + sizeof(struct tee_ioctl_param) * request-\u0026gt;send.num_params; /* è°ƒç”¨é©±åŠ¨ä¸­ioctlå‡½æ•°çš„TEE_IOC_SUPPL_SENDåŠŸèƒ½ï¼Œè¿›æ•°æ®å‘é€ç»™TA */ if (ioctl(fd, TEE_IOC_SUPPL_SEND, \u0026amp;data)) { EMSG(\u0026#34;TEE_IOC_SUPPL_SEND: %s\u0026#34;, strerror(errno)); return false; } return true; /* driver/tee/tee_core.c */ static long tee_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { struct tee_context *ctx = filp-\u0026gt;private_data; void __user *uarg = (void __user *)arg; switch (cmd) { ... case TEE_IOC_SUPPL_SEND: return tee_ioctl_supp_send(ctx, uarg); ... } } static int tee_ioctl_supp_send(struct tee_context *ctx, struct tee_ioctl_buf_data __user *ubuf) { long rc; struct tee_ioctl_buf_data buf; struct tee_iocl_supp_send_arg __user *uarg; struct tee_param *params; u32 num_params; u32 ret; /* Not valid for this driver */ ... rc = ctx-\u0026gt;teedev-\u0026gt;desc-\u0026gt;ops-\u0026gt;supp_send(ctx, ret, num_params, params); out: kfree(params); return rc; } /* driver/tee/optee/core.c */ static const struct tee_driver_ops optee_supp_ops = { .get_version = optee_get_version, .open = optee_open, .release = optee_release, .supp_recv = optee_supp_recv, .supp_send = optee_supp_send, /* æŒ‚è½½çš„å‡½æ•° */ .shm_register = optee_shm_register_supp, .shm_unregister = optee_shm_unregister_supp, }; /* driver/tee/optee/supp.c */ int optee_supp_send(struct tee_context *ctx, u32 ret, u32 num_params, struct tee_param *param) { struct tee_device *teedev = ctx-\u0026gt;teedev; struct optee *optee = tee_get_drvdata(teedev); struct optee_supp *supp = \u0026amp;optee-\u0026gt;supp; struct optee_supp_req *req; size_t n; size_t num_meta; mutex_lock(\u0026amp;supp-\u0026gt;mutex); /* é©±åŠ¨ä¸­è¯·æ±‚é˜Ÿåˆ—çš„popæ“ä½œ */ req = supp_pop_req(supp, num_params, param, \u0026amp;num_meta); mutex_unlock(\u0026amp;supp-\u0026gt;mutex); if (IS_ERR(req)) { /* Something is wrong, let supplicant restart. */ return PTR_ERR(req); } /* Update out and in/out parameters */ /* ä½¿ç”¨ä¼ å…¥çš„å‚æ•°ï¼Œæ›´æ–°è¯·æ±‚çš„å‚æ•°åŒºåŸŸï¼Œå°†éœ€è¦è¿”å›ç»™TEEä¾§çš„æ•°æ®å¡«å…¥åˆ°å¯¹åº”çš„ä½ç½® */ for (n = 0; n \u0026lt; req-\u0026gt;num_params; n++) { struct tee_param *p = req-\u0026gt;param + n; switch (p-\u0026gt;attr \u0026amp; TEE_IOCTL_PARAM_ATTR_TYPE_MASK) { case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_OUTPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_VALUE_INOUT: p-\u0026gt;u.value.a = param[n + num_meta].u.value.a; p-\u0026gt;u.value.b = param[n + num_meta].u.value.b; p-\u0026gt;u.value.c = param[n + num_meta].u.value.c; break; case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_OUTPUT: case TEE_IOCTL_PARAM_ATTR_TYPE_MEMREF_INOUT: p-\u0026gt;u.memref.size = param[n + num_meta].u.memref.size; break; default: break; } } req-\u0026gt;ret = ret; /* Let the requesting thread continue */ /* é€šçŸ¥optee_supp_thrd_reqå‡½æ•°ï¼Œä¸€ä¸ªæ¥è‡ªTEEä¾§çš„è¯·æ±‚å·²ç»è¢«å¤„ç†å®Œæ¯•ï¼Œ å¯ä»¥ç»§ç»­å¾€ä¸‹æ‰§è¡Œ */ complete(\u0026amp;req-\u0026gt;c); return 0; }   optee_supp_thrd_reqblockå°†ç»“æŸï¼Œç»§ç»­å¾€ä¸‹æ‰§è¡Œï¼Œè¿”å›TEE\ntee-supplicant æˆ‘ä»¬è¿˜æ˜¯ä»¥TA_loadè¿™ä¸ªå‘½ä»¤ä¸ºä¾‹ï¼š\nprocess_one_requestä¸­çš„read_requestä»é˜Ÿåˆ—ä¸­è¯»å–åˆ°è¯·æ±‚å’ŒTEEè¿‡æ¥çš„paramåï¼Œè·å–è¯·æ±‚cmd\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  /* optee_client/tee-supplicant/src/tee_supplicant.c */ static bool process_one_request(struct thread_arg *arg) { size_t num_params = 0; size_t num_meta = 0; struct tee_ioctl_param *params = NULL; uint32_t func = 0; uint32_t ret = 0; union tee_rpc_invoke request; memset(\u0026amp;request, 0, sizeof(request)); DMSG(\u0026#34;looping\u0026#34;); request.recv.num_params = RPC_NUM_PARAMS; /* Let it be known that we can deal with meta parameters */ params = (struct tee_ioctl_param *)(\u0026amp;request.send + 1); params-\u0026gt;attr = TEE_IOCTL_PARAM_ATTR_META; num_waiters_inc(arg); /* é˜»å¡ç‚¹ï¼Œé™·å…¥å†…æ ¸ä¸­ç­‰å¾…äº‹ä»¶ */ if (!read_request(arg-\u0026gt;fd, \u0026amp;request)) return false; if (!find_params(\u0026amp;request, \u0026amp;func, \u0026amp;num_params, \u0026amp;params, \u0026amp;num_meta)) return false; if (num_meta \u0026amp;\u0026amp; !num_waiters_dec(arg) \u0026amp;\u0026amp; !spawn_thread(arg)) return false; switch (func) { case OPTEE_MSG_RPC_CMD_LOAD_TA: /* load_taä½¿æˆ‘ä»¬çš„ç›®æ ‡å‡½æ•° */ ret = load_ta(num_params, params); break; ... } static uint32_t load_ta(size_t num_params, struct tee_ioctl_param *params) { int ta_found = 0; size_t size = 0; TEEC_UUID uuid; struct tee_ioctl_param_value *val_cmd; TEEC_SharedMemory shm_ta; memset(\u0026amp;shm_ta, 0, sizeof(shm_ta)); /* è§£æå‡ºéœ€è¦åŠ è½½çš„TAé•œåƒçš„UUIDä»¥åŠé…ç½®å°†è¯»å–åˆ°çš„TAé•œåƒçš„å†…å®¹å­˜æ”¾ä½ç½® */ if (num_params != 2 || get_value(num_params, params, 0, \u0026amp;val_cmd) || get_param(num_params, params, 1, \u0026amp;shm_ta)) return TEEC_ERROR_BAD_PARAMETERS; /* å°†UUIDçš„å€¼è½¬æ¢æˆTEEC_UUIDæ ¼å¼ */ uuid_from_octets(\u0026amp;uuid, (void *)val_cmd); /* ä»ta_dirå˜é‡æŒ‡å®šçš„ç›®å½•ä¸­æŸ¥æ‰¾ä¸UUIDç›¸ç¬¦çš„TAé•œåƒï¼Œå¹¶å°†å…¶å†…å®¹è¯»å–åˆ°å…±äº«å†…å­˜ä¸­ */ size = shm_ta.size; /* æ­¤å‡½æ•°åœ¨ä¸€æ¬¡åŠ è½½TAæµç¨‹ä¸­å°†ç»è¿‡ä¸¤æ¬¡è°ƒç”¨ï¼Œ * ç¬¬ä¸€æ¬¡åœ¨shm_ta.bufferä¸ºç©ºæ—¶ï¼Œå°†åªè·å–taæ–‡ä»¶çš„å¤§å°ï¼Œå›ç»™TEEä¾§ * ç¬¬äºŒæ¬¡æ‰ä¼šå»å°†TAåŠ è½½è¿›å…±äº«å†…å­˜ä¸­ */ ta_found = TEECI_LoadSecureModule(ta_dir, \u0026amp;uuid, shm_ta.buffer, \u0026amp;size); if (ta_found != TA_BINARY_FOUND) { EMSG(\u0026#34; TA not found\u0026#34;); return TEEC_ERROR_ITEM_NOT_FOUND; } /* è®¾å®šè¯»å–åˆ°çš„TAé•œåƒçš„å¤§å°åˆ°è¿”å›å‚æ•°çš„sizeæˆå‘˜ä¸­ */ params[1].u.memref.size = size; return TEEC_SUCCESS; }   tee_driver-\u0026gt;TEE è°ƒç”¨ç‚¹æ²¡æœ‰å˜åŒ–ï¼Œè¿˜æ˜¯optee-\u0026gt;invoke, è¿›å…¥ATFï¼Œç¡®å®šå…¥å£ï¼Œè¿›å…¥thread_resumeæ¢å¤çº¿ç¨‹ï¼Œä»¥å‰çš„æµç¨‹åŒºåˆ«ä¸å¤§ï¼Œåªæ˜¯æ¢å¤çº¿ç¨‹ä¹‹åçš„pcæŒ‡é’ˆæ˜¯ä¸Šæ–‡æåˆ°çš„thread_rpc_return\nvoid thread_handle_std_smc(struct thread_smc_args *args) { thread_check_canaries(); #ifdef CFG_VIRTUALIZATION if (!virt_set_guest(args-\u0026gt;a7)) { args-\u0026gt;a0 = OPTEE_SMC_RETURN_ENOTAVAIL; return; } #endif if (args-\u0026gt;a0 == OPTEE_SMC_CALL_RETURN_FROM_RPC) /* èµ°è¿™ä¸ªåˆ†æ”¯ */ thread_resume_from_rpc(args); else thread_alloc_and_run(args); #ifdef CFG_VIRTUALIZATION virt_unset_guest(); #endif ... } static void thread_resume_from_rpc(struct thread_smc_args *args) { size_t n = args-\u0026gt;a3; /* thread id */ struct thread_core_local *l = thread_get_core_local(); uint32_t rv = 0; assert(l-\u0026gt;curr_thread == -1); lock_global(); /* æŒ‚èµ·çŠ¶æ€çš„çº¿ç¨‹æ¢å¤active */ if (n \u0026lt; CFG_NUM_THREADS \u0026amp;\u0026amp; threads[n].state == THREAD_STATE_SUSPENDED \u0026amp;\u0026amp; args-\u0026gt;a7 == threads[n].hyp_clnt_id) threads[n].state = THREAD_STATE_ACTIVE; else rv = OPTEE_SMC_RETURN_ERESUME; unlock_global(); if (rv) { args-\u0026gt;a0 = rv; return; } l-\u0026gt;curr_thread = n; if (is_user_mode(\u0026amp;threads[n].regs)) tee_ta_update_session_utime_resume(); if (threads[n].have_user_map) core_mmu_set_user_map(\u0026amp;threads[n].user_map); /* * Return from RPC to request service of a foreign interrupt must not * get parameters from non-secure world. */ if (threads[n].flags \u0026amp; THREAD_FLAGS_COPY_ARGS_ON_RETURN) { copy_a0_to_a5(\u0026amp;threads[n].regs, args); threads[n].flags \u0026amp;= ~THREAD_FLAGS_COPY_ARGS_ON_RETURN; } thread_lazy_save_ns_vfp(); /* çº¿ç¨‹æ¢å¤ï¼Œè¿”å›thread_rpc_return */ thread_resume(\u0026amp;threads[n].regs); } thread_resumeå…ˆeretå›åˆ°åŠ è½½å›çš„el1_elrä¸­ï¼Œå¯¹åº”thread.regs.pc, å³thread_rpc_returnï¼ŒåŒæ—¶æ­¤æ—¶retæŒ‡ä»¤å¯¹åº”çš„è·³è½¬åœ°å€å¯„å­˜å™¨ä¸ºr30, ä¹Ÿä»thread.regs.x[30]ä¸­å›å¤(å…·ä½“å¯ä»¥å‚çœ‹ä¸Šæ–‡thread_resumeï¼Œæœ‰æ³¨é‡Š)\n.thread_rpc_return: /* * At this point has the stack pointer been restored to the value * stored in THREAD_CTX above. * * Jumps here from thread_resume above when RPC has returned. The * IRQ and FIQ bits are restored to what they where when this * function was originally entered. */ pop\tx16, xzr\t/* Get pointer to rv[] */ store_wregs x16, 0, 0, 5\t/* Store w0-w5 into rv[] */ /* æ­¤å¤„è°ƒç”¨retï¼Œ è¿”å›x30åœ°å€ï¼Œ å³thread_rpcå‡½æ•°çš„ä¸‹ä¸€å¥åœ°å€ï¼Œæ•´ä¸ªrpcæµç¨‹èµ°å®Œ */ ret END_FUNC thread_rpc è‡³æ­¤rpcæµç¨‹å†ç»ä¸€å¤§å †çŠ¶æ€åˆ‡æ¢ç»ˆäºå®Œæˆï¼Œé‡æ–°å›åˆ°ä¸šåŠ¡æµç¨‹thread_rpc_cmdå‡½æ•°ä¸­ã€‚\nå…¶ä»–è¡¥å…… ä»¥ä¸Šæµç¨‹çœ‹èµ·æ¥å·²ç»ç›¸å½“å¤æ‚ï¼Œç„¶è€Œè¿™æ‰åªæ˜¯å†°å±±ä¸€è§’, è¿˜æœ‰å¾ˆå¤šæœ‰å…³å†…å­˜ç®¡ç†ï¼Œå®‰å…¨å­˜å‚¨ç›¸å…³çš„èµ„æ–™ï¼Œåœ¨æ­¤å¤„æ€»ç»“ä¸€ä¸‹\nQEMUç¯å¢ƒæ­å»º å®˜æ–¹v7: https://optee.readthedocs.io/en/latest/building/devices/qemu.html\nåšå®¢å…³äºv8ï¼šhttps://blog.csdn.net/shuaifengyun/article/details/99855105\nopteeçš„å¯†ç åº“ ä¸»è¦ä½¿ç”¨çš„æ˜¯libtomcryptä¸libmbedï¼Œéƒ½è¿è¡Œåœ¨TEE_kernelä¸­\nlibtomcrypt\nlibmbedtls\nå®‰å…¨å­˜å‚¨ç›¸å…³ https://blog.csdn.net/shuaifengyun/article/list/1 36-42\nopteeå†…éƒ¨system call https://blog.csdn.net/shuaifengyun/article/details/73326870\nå†…å­˜ç®¡ç† æš‚æ— æ¯”è¾ƒå®Œæ•´çš„èµ„æ–™ï¼Œåç»­è‡ªå·±è¡¥å……ã€‚\næœ€å æœ¬æ–‡å›¾ç‰‡ä¸»è¦æ¥è‡ªGPå’Œopteeå®˜æ–¹æ–‡æ¡£ï¼Œä»¥åŠåšå®¢ï¼šhttps://icyshuai.blog.csdn.net/\næ°´å¹³å¾ˆèœï¼Œæ¬¢è¿æŒ‡æ­£\n","description":"Trustzoneå…¥é—¨ä¸OPTEEçš„é€šè®¯åŸç†åˆ†æ","id":5,"section":"posts","tags":["OPTEE","Trustzone"],"title":"OPTEE","uri":"https://summersummer3.github.io/posts/optee/"},{"content":"X.509ç³»åˆ—ï¼ˆä¸€ï¼‰ï¼šX.509 v3æ ¼å¼ä¸‹çš„è¯ä¹¦ ç›®å‰æ‰‹å¤´ä¸Šæ¥åˆ°äº†ä¸€ä¸ªæ–°çš„ä»»åŠ¡ï¼Œåˆšå¥½åˆæ˜¯å’ŒX.509è¯ä¹¦æ‰“äº¤é“çš„å·¥ä½œï¼Œæƒ³åˆ°åˆšå…¥èŒçš„æ—¶å€™ç¬¬ä¸€ä»½æ­£æ­£ç»ç»çš„å¼€å‘ä»»åŠ¡å°±æ˜¯å†™è¯ä¹¦ç­¾å‘å·¥å…·ï¼Œæ„Ÿè§‰è¿™éƒ¨åˆ†ç¡®å®åº”è¯¥è¸è¸å®å®åšä¸€ä¸‹æ€»ç»“äº†ã€‚å¾ˆéš¾è¯´ä»¥ç¬”è€…ç°åœ¨çš„æ°´å¹³èƒ½ä¸èƒ½è¯ä¹¦è¿™ä¹ˆä¸€ä¸ªåŸºç¡€å·¥å…·è®²æ¸…æ¥šï¼Œå°½åŠ›è€Œä¸ºå§ã€‚ç›®å‰è§„åˆ’ä¸ºä¸‰éƒ¨åˆ†å†…å®¹ï¼Œæœ¬æ–‡ç¬¬ä¸€ç¯‡ï¼Œå‰©ä¸‹ä¸¤éƒ¨åˆ†åˆ†åˆ«ä¸ºï¼š\n  ASN.1è¯¦è§£\n  å¯†ç åº“æºç åˆ†æ(åŸºäºmbedtlsåº“)\n  è¯ä¹¦çš„ç›®çš„ æˆ‘ä»¬å…¬é’¥è¯ä¹¦å¯ä»¥è¯´æ˜¯PKI(Public Key Infrastructure)ä¸­éå¸¸æ ¸å¿ƒçš„ç»„ä»¶ä¹‹ä¸€ï¼Œè€ŒPKIå¯ä»¥è¯´æ˜¯å½“ä»£äº’è”ç½‘æ–‡æ˜å®‰å…¨çš„åŸºçŸ³äº†ã€‚å¦‚æœè¿™æ–¹é¢çš„åè®®å‡ºç°äº†æ¼æ´ï¼Œå¯ä»¥è¯´ä¼šå¯¹æ•´ä¸ªä¸–ç•Œäº’è”ç½‘éƒ½é€ æˆéå¸¸ä¸¥é‡çš„å†²å‡»ã€‚ç¬”è€…çŸ¥è¯†æœ‰é™ï¼Œæ‰€ä»¥æœ¬æ–‡å¯¹CA(Certificate Authority)å°†ç®€å•æŠ½è±¡ä¸ºå•å±‚çº§çš„ä¸€ä¸ªè¯ä¹¦é¢å‘è€…ã€‚\nè¯ä¹¦(Certificate) é‡Œé¢ä¸»è¦åŒ…å«ä¸‰ä¸ªéƒ¨åˆ†ï¼šè¯ä¹¦ä¿¡æ¯(TBS Certificate)(TBS = To Be Signed)ï¼Œè¯ä¹¦ç­¾åç®—æ³•(signature Algorithm)å’Œè¯ä¹¦ç­¾å (signatureValue). è¯ä¹¦ä¿¡æ¯é‡ŒåŒ…å«äº†è¯ä¹¦çš„IDï¼Œè¯ä¹¦æ‹¥æœ‰è€…çš„ä¿¡æ¯ï¼Œç­¾å‘è€…ä¿¡æ¯ä¸æœ€å…³é”®çš„ï¼Œè¯ä¹¦æ‹¥æœ‰è€…å…¬é’¥ä¿¡æ¯ã€‚è€Œè¯ä¹¦çš„æ ¸å¿ƒåŠŸèƒ½ä¹Ÿæ˜¯åŸºäºè¯¥å…¬é’¥ä¿¡æ¯å±•å¼€ã€‚\næƒ³è±¡ä¸¤ä¸ªåœºæ™¯ï¼š\n Aliceå’ŒBobè¿›è¡Œé€šä¿¡ï¼Œæƒ³è¦ä½¿ç”¨ä¸€æ¡å¾—åˆ°åŠ å¯†çš„æ•°æ®ä¼ è¾“é€šé“ï¼Œé˜²æ­¢ç¬¬ä¸‰æ–¹çªƒå¬ Aliceç»™Bobå‘äº†ä¸ªæ¶ˆæ¯ï¼Œä½†æ˜¯ä»–æƒ³è¦å‘Bobè¯æ˜è¿™æ¡æ¶ˆæ¯æ˜¯è‡ªå·±å‘å‡ºçš„ï¼Œä¸”æ²¡æœ‰è¢«åˆ«äººç¯¡æ”¹è¿‡  åœºæ™¯1ï¼šç§˜é’¥åå•† ç¬¬ä¸€ä¸ªåœºæ™¯ä¸‹ï¼Œå¯ä»¥æŠŠé—®é¢˜ç®€å•çš„è§„çº¦ä¸ºAliceå’ŒBobéœ€è¦æ‹¥æœ‰åŒæ ·çš„å¯¹ç§°ç§˜é’¥ï¼Œæ•°æ®ä¼ è¾“çš„é€šé“ä¸Šåªä¼ è¾“ç”±è¯¥ç§˜é’¥åŠ å¯†è¿‡çš„æ•°æ®ã€‚ä½†æ˜¯å¯¹ç§°çš„ç§˜é’¥å¦‚ä½•ä¼ è¾“å‘¢ï¼Ÿéå¯¹ç§°å¯†ç ä½“ç³»è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚åœ¨å®Œæˆæ™®é€šçš„æ¡æ‰‹ä¹‹åï¼š\n  Aliceå’ŒBobåˆ†åˆ«å°†è‡ªå·±çš„è¯ä¹¦å‘ç»™å¯¹æ–¹\n  AliceéªŒè¯Bobçš„è¯ä¹¦ï¼ŒéªŒè¯æˆåŠŸåæå–Bobå…¬é’¥$ PUBKEY_B $, ä¹‹åå–éšæœºæ•° $ r_A $, è®¡ç®— $ s_A := PUBKEY_B(r_A) $å‘é€ç»™Alice. $ PUBKEY_X(n) $æŒ‡ä½¿ç”¨$ X $çš„å…¬é’¥å¯¹$ n $å®ŒæˆåŠ å¯†/éªŒç­¾æ“ä½œ. å¯¹åº”ECCå¯ä»¥è§†ä¸º$ n(PUBKEY_X) $, RSAå¯ä»¥è§†ä¸º$ n^{PUBKEY_X} \\mod N$\n  BobéªŒè¯Aliceçš„è¯ä¹¦ï¼ŒéªŒè¯æˆåŠŸåæå–Aliceå…¬é’¥$ PUBKEY_A $, ä¹‹åå–éšæœºæ•° $ r_B $, è®¡ç®— $ s_B := PUBKEY_A(r_B) $ å‘é€ç»™Alice\n  Aliceå’ŒBobåˆ†åˆ«ç”¨è‡ªå·±çš„ç§é’¥ä»$ s_B/s_A $ä¸­è§£å‡ºå¯¹åº”çš„$ r_B/r_A $, $ r_B := PRIKEY_A(s_B) $, $ r_A := PRIKEY_B(s_A) $ï¼Œç”±äºç§é’¥éƒ½æ˜¯ä»…Aliceå’ŒBobå„è‡ªæ‹¥æœ‰çš„ï¼Œç½‘ç»œä¸Šå…¶ä»–äººæ— æ³•è§£å‡ºï¼Œä¸­é—´äººçš„çªƒå¬å°†å¤±æ•ˆï¼ˆä½†æ˜¯ä¸­é—´äººæ”»å‡»ä¾ç„¶æ˜¯å¯èƒ½çš„ï¼Œè®¸å¤šhttpsçš„æŠ“åŒ…è½¯ä»¶å°±æ˜¯åŸºäºä¸­é—´äººçš„æ”»å‡»ã€‚æƒ³æƒ³ä¸ºå•¥ï¼‰\n  Aliceå’ŒBobæ‹¼æ¥éšæœºæ•°ä¸² $ r = r_A | r_B $ï¼Œä½¿ç”¨åå®šå¥½çš„ç§˜é’¥æ´¾ç”Ÿç®—æ³•ï¼Œå°†$ r $ ä½œä¸ºæ´¾ç”Ÿç§˜é’¥çš„ç§å­æ´¾ç”Ÿå‡ºç›¸åŒçš„ç§˜é’¥ï¼ŒåæœŸå°†ä½¿ç”¨è¯¥æ´¾ç”Ÿçš„ç§˜é’¥ä½œä¸ºåŠ å¯†é€šä¿¡çš„ç§˜é’¥\n  å…¶å®ä¸Šé¢çš„åè®®å°±æ˜¯ä¸€ä¸ªæ¯”è¾ƒç®€åŒ–ç‰ˆçš„SSL/TLSçš„æ¡æ‰‹é˜¶æ®µï¼Œå½“ç„¶ç§˜é’¥åå•†(DH: Diffieâ€“Hellman key exchange)çš„æ–¹å¼è¿˜æœ‰å¾ˆå¤š, ä½†åŸç†ç›¸å·®ä¸å¤šï¼Œä¼šæ¯”ç›´æ¥åŠ å¯†ç®€å•ä¸€ç‚¹ã€‚åŒ…æ‹¬å½“å‰å‡ ä¹å·²ç»æ˜¯æ ‡é…çš„HTTPSåè®®ï¼Œåº•å±‚çš„å®‰å…¨åŸºç¡€å¾ˆå¤§ç¨‹åº¦ä¹Ÿæ˜¯åŸºäºSSLçš„åè®®ã€‚\nåœºæ™¯2ï¼šæ•°å­—ç­¾å ç¬¬äºŒä¸ªåœºæ™¯å°±æ¯”è¾ƒç®€å•äº†ï¼š\n Aliceä¼šè®¡ç®—è‡ªå·±ä¿¡æ¯$M$çš„æ‘˜è¦å€¼(Digest)ï¼Œé€‰æ‹©åˆé€‚çš„paddingæ–¹å¼ï¼Œä½¿ç”¨è‡ªå·±çš„ç§é’¥å¯¹ä¿¡æ¯çš„æ‘˜è¦å€¼è®¡ç®—ç­¾åå€¼$ Sig := PRIKEY_A(Pad(DIGEST(M))) $. ä¼ è¾“é˜¶æ®µå°†è‡ªå·±çš„è¯ä¹¦ï¼Œç­¾åå€¼ä¸æ¶ˆæ¯(Cert+Sig+M)ä¸€èµ·æ‰“åŒ…å‘ç»™Bob Bobæ‹¿åˆ°è¿™ä¸ªåŒ…åé¦–å…ˆéœ€è¦éªŒè¯Aliceçš„è¯ä¹¦ï¼ŒéªŒè¯æˆåŠŸåæå–Aliceçš„å…¬é’¥ï¼›ä¹‹åè®¡ç®—Mçš„æ‘˜è¦å€¼$D$ï¼Œä¹‹åä½¿ç”¨å…¬é’¥è®¡ç®—$ D\u0026rsquo; := Depad(PUBKEY_A(Sig)) $, æœ€ååˆ¤æ–­ $ D\u0026rsquo; ?= D$ï¼Œå®ŒæˆéªŒç­¾æ“ä½œ  ç®€å•æ¥çœ‹ï¼Œæ¶ˆæ¯çš„æ‘˜è¦å€¼ä¿è¯äº†æ¶ˆæ¯çš„å®Œæ•´æ€§Integrityï¼Œè€Œç­¾åçš„éªŒè¯ä¿è¯äº†æ¶ˆæ¯æ˜¯æ¥è‡ªAliceçš„ä¸å¯æŠµèµ–æ€§Non-repudiation\nå¥½äº†ï¼Œçœ‹å®Œäº†ä¸Šé¢çš„é—®é¢˜ï¼Œæœ‰æ²¡æœ‰ä¸€ç‚¹ç–‘é—®ï¼šé‚£çœ‹èµ·æ¥è¯ä¹¦å¥½åƒåªæ˜¯ä¸ªå…¬é’¥çš„å£³å­è€Œå·²ï¼Œä¸ºå•¥ä¸ç›´æ¥å‘å…¬é’¥å°±å®Œäº‹äº†ï¼Ÿè¿˜æœ‰éªŒè¯è¯ä¹¦æ˜¯ä»€ä¹ˆæ„æ€ï¼Ÿ\næœ‰æ²¡æœ‰æƒ³è¿‡ï¼Œä¸Šè¿°çš„Bobå’ŒAliceéƒ½æ˜¯æ‰€è°“çš„\u0026quot;å¥½äºº\u0026quot;è€Œå·²ï¼Œè¿™ç½‘ç»œä¸Šå“ªæœ‰è¿™ä¹ˆå¤šå¥½äººã€‚æœ¬è´¨ä¸Šï¼Œå…¬é’¥å…¶å®åªæ˜¯ä¸€ä¸ªå¾ˆå¤§çš„æ•°ï¼Œä¼ é€’æ—¶ä¹Ÿå°±æ˜¯ä¸ªäºŒè¿›åˆ¶æµã€‚å‡å¦‚äº’è”ç½‘ä¸Šåªæœ‰è£¸ç€çš„å…¬é’¥ä¼ è¾“ï¼Œæˆ‘æ€ä¹ˆçŸ¥é“è¿™ä¸ªå…¬é’¥æ˜¯è°å‘ç»™æˆ‘çš„ï¼Œä¸­é—´æœ‰æ²¡æœ‰è¢«åˆ«äººç»™æ›¿æ¢äº†ã€‚\nç°å®ä¸­æˆ‘ä»¬è¯æ˜è‡ªå·±æ˜¯ä¸€ä¸ªå…¬æ°‘çš„åŠæ³•é€šå¸¸æ˜¯å»å…¬å®‰å±€å»è·å–è‡ªå·±çš„èº«ä»½è¯ï¼Œé€šè¿‡èº«ä»½è¯è¯æ˜æˆ‘æ˜¯æˆ‘ï¼Œå› ä¸ºèº«ä»½è¯ä¸Šæœ‰æˆ‘çš„åå­—ã€å”¯ä¸€èº«ä»½è¯å·ã€ç…§ç‰‡ç­‰ç­‰ï¼Œå‘è¯æœºå…³å°†åœ¨èº«ä»½è¯ç›–ä¸Šå›½å®¶ç¥åœ£çš„å…¬ç« ï¼Œè¯æ˜èº«ä»½è¯çš„çœŸå®æ€§ã€‚é‚£ä¹ˆåœ¨ç½‘ç»œä¸–ç•Œä¸­ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦ä¸€å¼ è¿™æ ·çš„èº«ä»½è¯ï¼Œè¯æ˜æˆ‘æ˜¯è¯¥å…¬é’¥çš„æ‹¥æœ‰äººï¼Œä¸”å…¬é’¥çš„ä¿¡æ¯å¾ˆæœ‰é™ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦æ‰“åŒ…æ›´å¤šå…¬é’¥æ‹¥æœ‰è€…çš„ä¿¡æ¯ï¼ŒåŒæ—¶æˆ‘ä»¬ä¹Ÿéœ€è¦ä¸€ä¸ªç»„ç»‡æ¥è¿›è¡Œå‘è¯æ“ä½œï¼Œèµ·åˆ°å…¬å®‰å±€çš„ä½œç”¨ï¼Œå¹¶å¯¹è¯ä¹¦\u0026quot;ç›–ä¸Šå…¬ç« \u0026quot;ã€‚åœ¨è¿™ç§åœºæ™¯ä¸‹ï¼Œç½‘ç»œä¸–ç•Œçš„è¯ä¹¦è‡ªç„¶å°±å‘¼ä¹‹æ¬²å‡ºäº†ã€‚\nè¯ä¹¦çš„é¢å‘ è¯ä¹¦çš„ç”³è¯·æ–‡ä»¶ ç°å®ä¸­æˆ‘ä»¬å»è·å–èº«ä»½è¯æ—¶å€™ï¼Œé¦–å…ˆä¹Ÿè¦å¡«ä¸€ä¸ªç”³è¯·è¡¨å§ã€‚æˆ‘ä»¬åœ¨ç”³è¯·è¯ä¹¦çš„æ—¶å€™åŒæ ·éœ€è¦ä¸€ä¸ªç”³è¯·æ–‡ä»¶æ¥å‘ç»™ç½‘ç»œä¸–ç•Œçš„å…¬å®‰å±€ï¼ŒCAã€‚å½“ç„¶ï¼Œè¿™ä¸ªç”³è¯·æ–‡ä»¶ä¹Ÿæ˜¯éœ€è¦éµå¾ªæ ¼å¼æ ‡å‡†çš„RFC 2986 - PKCS #10: Certification Request Syntax Specificationï¼Œç¼©å†™ä¸º.csr\né€šè¿‡OpenSSLå¯ä»¥è‡ªå·±é€ ä¸€ä¸ªåˆæ³•æ ¼å¼çš„csræ–‡ä»¶ï¼š\næ­£å¦‚ç”³è¯·èº«ä»½è¯éœ€è¦å…ˆé€ ä¸ªäººï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦è‡ªå·±é€ ä¸€ä¸ªå…¬é’¥ï¼Œå³åˆ¶é€ ä¸€å¯¹å…¬ç§é’¥å¯¹ï¼Œä»¥RSA-2048ä¸ºä¾‹ï¼Œç”Ÿæˆpemæ ¼å¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  pwner@pwner:~$ openssl genrsa -out rsa_private.pem 2048 Generating RSA private key, 2048 bit long modulus (2 primes) .........................................+++++ .........................................................+++++ e is 65537 (0x010001) pwner@pwner:~$ openssl rsa -in rsa_private.pem -pubout -out rsa_public.pem pwner@pwner:~$ cat rsa_public.pem rsa_private.pem -----BEGIN PUBLIC KEY----- MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA6A5bWFoO3bU8apnV6Q4r SmosNvx28JSLz5gdwtrAHTjzqLn7yXu56kp/j8wZEKhe0jgKNCAGIwbY3begyAav ixZY4XUa647L4wtJ9lJzUTVcFdZ2g/WsmQXVY3ssa3NYL7SDnlBxffdrT8s0yRV4 Ojo4CqgJ926qEZERUxnuv5cgf7l3cfbZUoZzgcdw5XF+Mu98y+yvnrqnihfO2DGU HTWCRI93NkCpZRngPWElT1XR8kxSIuquJW54RgFE1RK6v7S8RVHvtwIqpvYV4D/u OgxktmwAblxwF65uPklLgVlNfxKMhFnQoF77vSPdWWaB0x8CQsn+5q4KhGARaT5z fQIDAQAB -----END PUBLIC KEY----- -----BEGIN RSA PRIVATE KEY----- MIIEpgIBAAKCAQEA6A5bWFoO3bU8apnV6Q4rSmosNvx28JSLz5gdwtrAHTjzqLn7 yXu56kp/j8wZEKhe0jgKNCAGIwbY3begyAavixZY4XUa647L4wtJ9lJzUTVcFdZ2 g/WsmQXVY3ssa3NYL7SDnlBxffdrT8s0yRV4Ojo4CqgJ926qEZERUxnuv5cgf7l3 cfbZUoZzgcdw5XF+Mu98y+yvnrqnihfO2DGUHTWCRI93NkCpZRngPWElT1XR8kxS IuquJW54RgFE1RK6v7S8RVHvtwIqpvYV4D/uOgxktmwAblxwF65uPklLgVlNfxKM hFnQoF77vSPdWWaB0x8CQsn+5q4KhGARaT5zfQIDAQABAoIBAQCDaxYKLD59CtWj XWnKaa7UntpZbZMCXm3rbC92maHxKr67EFDq4zn/2J7zVdfgGipRDVGiAXzYO1l3 /zV78mVZ9JbzX/mV67HF7C+/4yPRmtGCwIkv5GMR6j7V7vzSAWmw4p8jelU7zHIm p2NGefUzrKLuTgoO6cpA1pIkKOyP7TclGp9vTGh1MoE2rZjLggo+ESQuLX/GKDAH pV3NamiAgJtrfqTKoI/AnDcGhhy46np/Cwb4ENkFFJ6oHOYgyXexlBCQmjXfaQyp T45uGjuKi45r9c5mvP0Z7uejCKWPs6LjXye3SN2XtWFRJdADBMH+YMqHax8N3IPm 4cUz3l+hAoGBAP+vkZ2+qSECMjudymz9yEiSrrIAnG2G5gCTNsnannXMNzBOOgIb mpvGY8okLeA7pHsOYdyvnCvbRuA6mhtL+tFn84PjQem6Z18KyqwCvHWzsnvrcjbx yiBnSwsyfbfXQqdGhfs62Vko+6OxXSDB10uyHGiga7C26N8HY1F791UlAoGBAOhX WtNx5xubEgGumKPNNdSD/5Toq+Cz+eIuLiTfR4zZYGcjBawcESzkV3EM6HN/LL8N bZ1DFKxIMsGAECmkImKtEkWEpeqJkatjsQbDvzSX0mUPrE4fFJQF3JzzauXKUayC 51S0GS9EN0FLYk0mjXyrJcHaHcFqgVW0eQ/7RNF5AoGBANuLFFy/hpfKO/nGrjbR 3rS6BnjfX3IIX9vkjCncpy18sXKv6M1AiIvzWGIMmLuuWrgzDEKjI1ThDsWgbAy+ O9qtCIKZk1Iu9W29ZXM3Uj06lCola8fT63vRVbWCoEJH+nqJaqfiyxfswc23kMB8 0PG1OQF5pZ5yIBjJTjV8XU5lAoGBAL+M3W2712x0AXlvh5psIfguRzVuSd38o4Rs zFBL4MJnqMn/HrsRfLuFGe4zVSV7cNmmaXuhBVcwQuAzA6BBGLQ/ufOkc+GUP4uM qjNIiMgEb0owjL7vctjCqGqhaL1Aeut+FNhJjwXf+KoVS1sN8NIajAtxFt0SQMT3 AGRDpS4JAoGBAK6hrYUVDDLEDfvfCH8ItOGYozPdDDvJbiZQMdK9tXSnpfoOGOXK 9ofPPSrBoAIt7O0RR5fBR3di8fZbVGJRd2NUsnbFhlj4KBVKusYRjeTl5PcNI6G0 P8wd5+pqIdwAVN77S5MeusApw8A2+L67odt6xzHGugR3pcBzGONUsD3C -----END RSA PRIVATE KEY-----   ç”Ÿæˆcsræ–‡ä»¶ï¼Œè¾“å…¥è‡ªå·±çš„å…¬é’¥ä¸ç§é’¥ï¼Œé€šå¸¸è¿˜ä¼šè®©ä½ è¾“å…¥è‡ªå·±çš„ä¸ªäººä¿¡æ¯ã€‚ä½¿ç”¨PKCS#10çš„æ ‡å‡†å°†ä¿¡æ¯ä¸å…¬é’¥æ‰“åŒ…åï¼Œç”±è‡ªå·±ç§é’¥è¿›è¡Œè‡ªç­¾åï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  pwner@pwner:~/X509_learning$ openssl req -new -in rsa_public.pem -key rsa_private.pem -out rsa_public.csr.pem You are about to be asked to enter information that will be incorporated into your certificate request. What you are about to enter is what is called a Distinguished Name or a DN. There are quite a few fields but you can leave some blank For some fields there will be a default value, If you enter \u0026#39;.\u0026#39;, the field will be left blank. ----- Country Name (2 letter code) [AU]:CN State or Province Name (full name) [Some-State]:GD Locality Name (eg, city) []:SZ Organization Name (eg, company) [Internet Widgits Pty Ltd]:xxxx Organizational Unit Name (eg, section) []: Common Name (e.g. server FQDN or YOUR name) []:xxxx Email Address []:xxxx Please enter the following \u0026#39;extra\u0026#39; attributes to be sent with your certificate request A challenge password []: An optional company name []: pwner@pwner:~/X509_learning$ cat rsa_public.csr.pem -----BEGIN CERTIFICATE REQUEST----- MIICtTCCAZ0CAQAwcDELMAkGA1UEBhMCQ04xCzAJBgNVBAgMAkdEMQswCQYDVQQH DAJTWjEPMA0GA1UECgwGSFVBV0VJMREwDwYDVQQDDAhTSFVBSUhVQTEjMCEGCSqG SIb3DQEJARYUc2h1YWlodWEyQGh1YXdlaS5jb20wggEiMA0GCSqGSIb3DQEBAQUA A4IBDwAwggEKAoIBAQDoDltYWg7dtTxqmdXpDitKaiw2/HbwlIvPmB3C2sAdOPOo ufvJe7nqSn+PzBkQqF7SOAo0IAYjBtjdt6DIBq+LFljhdRrrjsvjC0n2UnNRNVwV 1naD9ayZBdVjeyxrc1gvtIOeUHF992tPyzTJFXg6OjgKqAn3bqoRkRFTGe6/lyB/ uXdx9tlShnOBx3DlcX4y73zL7K+euqeKF87YMZQdNYJEj3c2QKllGeA9YSVPVdHy TFIi6q4lbnhGAUTVErq/tLxFUe+3Aiqm9hXgP+46DGS2bABuXHAXrm4+SUuBWU1/ EoyEWdCgXvu9I91ZZoHTHwJCyf7mrgqEYBFpPnN9AgMBAAGgADANBgkqhkiG9w0B AQsFAAOCAQEA5FHk/AAEmiR58aHZJ9dAFMtxEAm4x9WYpxcfzFrXt1h35QFLK3D5 3SkZlTeRNfH3r4eNYit8Hm3efqsfQXfgcuO5RTS4lU7DcAdsgExddxd52NojfnxP qMfBQNZTuglVLGZ3o3O/HQ0YvJjkcLyIyFyU1YwVzWkts/QHKmU2mtyrLN4piolv nZlTSX3qeUio218nwEmXzztcZBR51Z3hriUSIP/+rBWJlZEP+0sTaOmG46gQwS7r jxif4CcoCwPDd8+GeiSSbWHZzNYRISVtQcLHVsUAq6iro3YiQygPBLF4bwa4c8kX bcqeI/q36J+2myc/alFWDGjEsE/6zh6c7w== -----END CERTIFICATE REQUEST-----   -iné€‰é¡¹è¾“å…¥å…¬é’¥ï¼Œ-keyè¾“å…¥ç§é’¥ï¼Œ-outä¸ºè¾“å‡ºcsræ–‡ä»¶åã€‚-newè¡¨ç¤ºæ–°å»ºä¸€ä¸ªcsrã€‚è¿è¡Œå‘½ä»¤è¡Œåç„¶åä¼šè®©ä½ è¾“å…¥çš„ä¸ªäººä¿¡æ¯ã€‚æ­¤å¤„æ‹†åˆ†ä¸»è¦ä¸ºäº†é˜è¿°csrçš„ç”Ÿæˆæµç¨‹ã€‚\n1  pwner@pwner:~/X509_learning$ openssl req -new -nodes -sha256 -newkey rsa:2048 -keyout rsa_private.pem -out rsa_public.csr.pem   ä½†æ˜¯ä¸Šé¢çš„æ‰“å°å•¥ä¹Ÿçœ‹ä¸å‡ºæ¥ï¼Œæˆ‘ä»¬éœ€è¦ç”¨è§£æå®Œçš„æ–¹å¼æ¥æŸ¥çœ‹è¯¥æ–‡ä»¶ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  pwner@pwner:~/X509_learning$ openssl req -in rsa_public.csr.pem -noout -text Certificate Request: Data: Version: 1 (0x0) Subject: C = CN, ST = GD, L = SZ, O = xxxx, CN = xxxx, emailAddress = xxxx Subject Public Key Info: Public Key Algorithm: rsaEncryption RSA Public-Key: (2048 bit) Modulus: 00:e8:0e:5b:58:5a:0e:dd:b5:3c:6a:99:d5:e9:0e: 2b:4a:6a:2c:36:fc:76:f0:94:8b:cf:98:1d:c2:da: c0:1d:38:f3:a8:b9:fb:c9:7b:b9:ea:4a:7f:8f:cc: 19:10:a8:5e:d2:38:0a:34:20:06:23:06:d8:dd:b7: a0:c8:06:af:8b:16:58:e1:75:1a:eb:8e:cb:e3:0b: 49:f6:52:73:51:35:5c:15:d6:76:83:f5:ac:99:05: d5:63:7b:2c:6b:73:58:2f:b4:83:9e:50:71:7d:f7: 6b:4f:cb:34:c9:15:78:3a:3a:38:0a:a8:09:f7:6e: aa:11:91:11:53:19:ee:bf:97:20:7f:b9:77:71:f6: d9:52:86:73:81:c7:70:e5:71:7e:32:ef:7c:cb:ec: af:9e:ba:a7:8a:17:ce:d8:31:94:1d:35:82:44:8f: 77:36:40:a9:65:19:e0:3d:61:25:4f:55:d1:f2:4c: 52:22:ea:ae:25:6e:78:46:01:44:d5:12:ba:bf:b4: bc:45:51:ef:b7:02:2a:a6:f6:15:e0:3f:ee:3a:0c: 64:b6:6c:00:6e:5c:70:17:ae:6e:3e:49:4b:81:59: 4d:7f:12:8c:84:59:d0:a0:5e:fb:bd:23:dd:59:66: 81:d3:1f:02:42:c9:fe:e6:ae:0a:84:60:11:69:3e: 73:7d Exponent: 65537 (0x10001) Attributes: a0:00 Signature Algorithm: sha256WithRSAEncryption e4:51:e4:fc:00:04:9a:24:79:f1:a1:d9:27:d7:40:14:cb:71: 10:09:b8:c7:d5:98:a7:17:1f:cc:5a:d7:b7:58:77:e5:01:4b: 2b:70:f9:dd:29:19:95:37:91:35:f1:f7:af:87:8d:62:2b:7c: 1e:6d:de:7e:ab:1f:41:77:e0:72:e3:b9:45:34:b8:95:4e:c3: 70:07:6c:80:4c:5d:77:17:79:d8:da:23:7e:7c:4f:a8:c7:c1: 40:d6:53:ba:09:55:2c:66:77:a3:73:bf:1d:0d:18:bc:98:e4: 70:bc:88:c8:5c:94:d5:8c:15ğŸ’¿69:2d:b3:f4:07:2a:65:36: 9a:dc:ab:2c:de:29:8a:89:6f:9d:99:53:49:7d:ea:79:48:a8: db:5f:27:c0:49:97:cf:3b:5c:64:14:79:d5:9d:e1:ae:25:12: 20:ff:fe:ac:15:89:95:91:0f:fb:4b:13:68:e9:86:e3:a8:10: c1:2e:eb:8f:18:9f:e0:27:28:0b:03:c3:77:cf:86:7a:24:92: 6d:61:d9:cc:d6:11:21:25:6d:41:c2:c7:56:c5:00ğŸ†a8ğŸ† a3:76:22:43:28:0f:04:b1:78:6f:06:b8:73:c9:17:6d:ca:9e: 23:fa:b7:e8:9f:b6:9b:27:3f:6a:51:56:0c:68:c4:b0:4f:fa: ce:1e:9c:ef   è¿™å°±æœ‰é‚£å‘³å„¿äº†ï¼Œç®€å•è§£æä¸€ä¸‹ï¼Œé¡ºä¾¿å¯¹åº”ç€RFCçš„æ ‡å‡†çœ‹ä¸€ä¸‹ã€‚å…ˆçœ‹Dataè¿™æ®µï¼Œå¯¹åº”çš„æ˜¯ CertificationRequestInfo\n1 2 3 4 5 6  CertificationRequestInfo ::= SEQUENCE { version INTEGER { v1(0) } (v1,...), subject Name, subjectPKInfo SubjectPublicKeyInfo{{ PKInfoAlgorithms }}, attributes [0] Attributes{{ CRIAttributes }} }   é¡ºä¾¿æä¸€ä¸‹ï¼ŒRFCçš„æ ‡å‡†éƒ½æ˜¯ä½¿ç”¨ASN.1æ ¼å¼æè¿°çš„ï¼Œè€Œæ—¥å¸¸ä½¿ç”¨ä¸­çš„è¯ä¹¦ç­‰æ–‡ä»¶åŒæ ·æ˜¯åŸºäºASN.1çš„BERæ ¼å¼ï¼Œè€ŒPEMæ˜¯å¯¹æ–‡ä»¶è¿›è¡Œæ ‡è¯†ï¼ˆå¦‚-----BEGIN CERTIFICATE REQUEST-----ï¼‰åï¼Œè¿›è¡Œbase64ç¼–ç çš„äº§ç‰©ã€‚ASN.1çš„å…·ä½“ç»†èŠ‚å°†åœ¨(äºŒ)éƒ¨åˆ†è¿›è¡Œåˆ†æã€‚\nå¯ä»¥å‘ç°ç”Ÿæˆçš„csrçš„dataéƒ¨åˆ†æ˜¯å¯ä»¥å’ŒCertificationRequestInfoä¸€ä¸€å¯¹åº”èµ·æ¥çš„ï¼š\nversionï¼šcsrçš„ç‰ˆæœ¬å·ï¼Œå½“å‰é€šå¸¸æ˜¯version 1ï¼Œå³0\nsubjectï¼šä»¥Nameçš„æ ¼å¼ä¿å­˜ï¼Œä¸€èˆ¬ä¼šä¿å­˜è¯ä¹¦æŒæœ‰è€…çš„å›½ç±(C:Country ä¸¤ä¸ªå­—æ¯è¡¨ç¤ºï¼Œå¦‚ç¾å›½USï¼Œä¸­å›½CN), çœçº§è¡Œæ”¿åŒº(ST: State or Province)ï¼ŒåŸå¸‚(L:Locality), å…¬å¸ç»„ç»‡å(O:Organization), ç»„ç»‡éƒ¨é—¨å(OU: Organization Unit), é€šç”¨å(CN: Common Name), emailåœ°å€ç­‰ç­‰ã€‚å…¶å®å…·ä½“çš„è§„èŒƒè¿˜æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œå…·ä½“æ ‡å‡†å‚è€ƒX.501è§„èŒƒã€‚æ­¤å¤„ä¸ç»†è¯´äº†\nsubjectPKInfo: æœ€å…³é”®çš„éƒ¨åˆ†ï¼ŒåŒ…å«äº†å…¬é’¥çš„ä¿¡æ¯ï¼Œç”±å…¬é’¥ç®—æ³•ä¸å…¬é’¥å€¼ç»„æˆï¼š\n1 2 3 4  SubjectPublicKeyInfo { ALGORITHM : IOSet} ::= SEQUENCE { algorithm AlgorithmIdentifier {{IOSet}}, subjectPublicKey BIT STRING }   é¡ºä¾¿æä¸€å¥ï¼ŒAlgorithmIdentifierçš„æ ‡è¯†æ˜¯ANS.1ç¼–ç ä¸­æœ€ä¸ä¼—ä¸åŒçš„æ–¹å¼ï¼ŒObject ID. åç»­å°†æåˆ°ã€‚æ­¤å¤„ç®—æ³•è¢«æ ‡è®°ä¸ºäº†rsaEncrypt\næœ€åæ˜¯attributesï¼Œä»–ä¸»è¦æä¾›äº†ä¸€äº›è¯ä¹¦ç”³è¯·è€…çš„é™„åŠ ä¿¡æ¯ã€‚PKCS#9ä¸­å®šä¹‰äº†ä¸€äº›åœ¨æ­¤å¯èƒ½ä½¿ç”¨çš„å±æ€§ç±»å‹ï¼Œå…¸å‹çš„ä¾‹å­æ˜¯challenge-passwordå±æ€§ï¼šå®ƒå°†æŒ‡å®šä¸€ä¸ªå¯†ç ï¼Œå®ä½“å¯ä»¥é€šè¿‡è¯¥å¯†ç è¯·æ±‚åŠé”€è¯ä¹¦ï¼›å¦ä¸€ä¸ªä¾‹å­æ˜¯X.509è¯ä¹¦æ‰©å±•ä¸­æ˜¾ç¤ºçš„ä¿¡æ¯ï¼ˆä¾‹å¦‚ã€‚ä»PKCS #9è·å–çš„extensionRequestå±æ€§ç­‰ï¼‰ã€‚æ­¤å¤„a0:00æ ‡è¯†äº†NULL\n1 2 3 4  Attribute { ATTRIBUTE:IOSet } ::= SEQUENCE { type ATTRIBUTE.\u0026amp;id({IOSet}), values SET SIZE(1..MAX) OF ATTRIBUTE.\u0026amp;Type({IOSet}{@type}) }   å†çœ‹å®Œæ•´çš„csrç»“æ„ï¼š\n1 2 3 4 5  CertificationRequest ::= SEQUENCE { certificationRequestInfo CertificationRequestInfo, signatureAlgorithm AlgorithmIdentifier{{ SignatureAlgorithms }}, signature BIT STRING }   certificationRequestInfoå¯¹åº”çš„å°±æ˜¯ä¸Šé¢çš„Dataï¼Œå·²å®Œæˆè§£é‡Š\nsignatureAlgorithmå¯¹åº”ç­¾åç®—æ³•ï¼Œæ­¤å¤„ä¸ºsha256WithRSAEncryptionï¼ŒæŒ‡çš„æ˜¯ä½¿ç”¨å¾…ç­¾åçš„å…¬é’¥å¯¹åº”çš„ç§é’¥ï¼Œæ¥å®Œæˆè‡ªç­¾åï¼Œç­¾åçš„å¯¹è±¡æ˜¯certificationRequestInfoçš„sha256æ‘˜è¦å€¼ï¼Œç­¾åç®—æ³•ä¸ºRSA\næœ€åsignatureå¯¹åº”çš„å°±æ˜¯ç­¾åå€¼äº†ï¼Œbit stringç±»å‹\næœ€åæä¸€ç‚¹ï¼Œåœ¨è¯ä¹¦ç”³è¯·çš„æ¨¡å¼ä¸‹ï¼Œç”³è¯·è€…åªéœ€è¦å°†å…¬é’¥ä¿¡æ¯å‘è‡³è¯ä¹¦ç­¾å‘æœºæ„å³å¯ï¼Œä¿è¯äº†ç§é’¥çš„æœ¬åœ°æ€§ä¸ç§å¯†æ€§ã€‚\nCA å®Œæˆäº†ç”³è¯·è¡¨çš„å¡«å†™ï¼Œå°±åº”è¯¥äº¤ç»™èº«ä»½è¯åŠç†äººå‘˜äº†ï¼Œç±»æ¯”ä¸‹æ¥csræ–‡ä»¶ç”Ÿæˆä¹‹åï¼Œæˆ‘ä»¬å°±è¦å‘CAå‘é€è¯ä¹¦ç”³è¯·æ–‡ä»¶ï¼Œä»¥è·å–è¯ä¹¦ã€‚\nCAå¯ä»¥ç¿»è¯‘ä¸ºæ•°å­—è¯ä¹¦è®¤è¯æœºæ„ï¼Œæ˜¯PKIä½“ç³»ä¸­çš„åŸºçŸ³ã€‚ç»´åŸºç™¾ç§‘äºæ˜¯è¯´ï¼š\n CAæ˜¯è¯ä¹¦çš„ç­¾å‘æœºæ„ï¼Œå®ƒæ˜¯PKIçš„æ ¸å¿ƒã€‚CAæ˜¯è´Ÿè´£ç­¾å‘è¯ä¹¦ã€è®¤è¯è¯ä¹¦ã€ç®¡ç†å·²é¢å‘è¯ä¹¦çš„æœºå…³ã€‚å®ƒè¦åˆ¶å®šæ”¿ç­–å’Œå…·ä½“æ­¥éª¤æ¥éªŒè¯ã€è¯†åˆ«ç”¨æˆ·èº«ä»½ï¼Œå¹¶å¯¹ç”¨æˆ·è¯ä¹¦è¿›è¡Œç­¾åï¼Œä»¥ç¡®ä¿è¯ä¹¦æŒæœ‰è€…çš„èº«ä»½å’Œå…¬é’¥çš„æ‹¥æœ‰æƒã€‚\n ç”±ä¸Šæ–‡å¯ä»¥æ¨æ–­ï¼ŒCAæ­£æ˜¯æ‰¿æ‹…äº†å…¬å®‰å±€å¯¹èº«ä»½è¯\u0026quot;ç›–ç« \u0026quot;è¿™ä¸€å·¥ä½œï¼Œç›–ä¸Šçš„ä¾¿æ˜¯ä½¿ç”¨CAç§é’¥å®Œæˆçš„å¯¹è¯ä¹¦çš„æ•°å­—ç­¾åã€‚ä½†æ˜¯å…¬å®‰å±€çš„ä¿¡ç”¨æ˜¯æœ‰å›½å®¶èƒŒä¹¦çš„ï¼Œæ‰€ä»¥CAä¹Ÿå¿…é¡»å¾—åˆ°ç½‘ç»œä¸Šæ‰€æœ‰äººçš„ä¿¡ä»»ã€‚å½“ç„¶æ‹¥æœ‰CAèµ„æ ¼çš„æœºæ„ä¹Ÿæ˜¯ç›¸å½“æœ‰é™çš„ã€‚\nCAè·å–è¯ä¹¦ç”³è¯·ä¹‹åï¼Œé¦–å…ˆå°±è¦æ£€æµ‹csrçš„åˆæ³•æ€§ï¼Œç”³è¯·äººä¿¡æ¯çš„åˆæ³•æ€§ï¼Œå…¬é’¥çš„åˆæ³•æ€§ç­‰ç­‰ã€‚è¿™äº›å±äºå®¡æ‰¹çš„èŒƒç•´ï¼ŒæŠ€æœ¯èŒƒç•´çš„è¯å°±æ˜¯éœ€è¦æ ¡éªŒcsrçš„ç­¾åï¼Œå³certificationRequestInfoæ˜¯å¦è¢«ç¯¡æ”¹ã€‚è¿‡ç¨‹ä¸ºå–å‡ºcertificationRequestInfoä¸­çš„å…¬é’¥ä¿¡æ¯ï¼Œè®¡ç®—certificationRequestInfoçš„å¾…éªŒè¯å“ˆå¸Œå€¼ã€‚åˆ©ç”¨æå–çš„å…¬é’¥ä¸ç­¾åè®¡ç®—å‡ºç­¾åå“ˆå¸Œå€¼ï¼Œè§£paddingåï¼Œåˆ¤æ–­æ˜¯å¦ä¸å¾…éªŒè¯å“ˆå¸Œå€¼ä¸€è‡´ï¼Œç¡®å®šè¯¥csrçš„å®Œæ•´æ€§ä¸ä¸å¯æŠµèµ–æ€§ã€‚\nCAåœ¨å®ŒæˆéªŒè¯åï¼Œå°†ä¸‹å‘è‡ªå·±çš„CAè¯ä¹¦ä»¥åŠç­¾å‘çš„X.509è¯ä¹¦ã€‚CAåŒæ ·æ˜¯ä¸€å¼ X.509æ ¼å¼çš„è¯ä¹¦ï¼Œå¾€å¾€ä¹Ÿæ˜¯ä¸€å¼ è‡ªç­¾åçš„è¯ä¹¦ï¼Œå³CAç§é’¥ç­¾å‘CAå…¬é’¥ã€‚äº‹å®ä¸Šï¼Œå½“å‰ç½‘ç»œé€šè®¯å½“ä¸­ï¼ˆç‰¹åˆ«æ˜¯æµè§ˆå™¨ï¼‰å°†ä¼šå†…ç½®ä¸Šå¾ˆå¤šæƒå¨å—ä¿¡ä»»çš„CAè¯ä¹¦ï¼Œè‹¥é€šä¿¡è¿‡ç¨‹ä¸­ä½¿ç”¨çš„CAè¯ä¹¦å¹¶ä¸åœ¨å†…ç½®åå•ä¸­ï¼Œå¾€å¾€ç¨‹åºä¼šè¿›è¡Œæé†’ï¼šå½“å‰ç«™ç‚¹CAè¯ä¹¦ä¸å—ä¿¡ä»»ã€‚è€Œä¸”ç°åœ¨CAå¾€å¾€ç”±äºéœ€è¦åŠ å¿«ç­¾å‘é€Ÿç‡ç­‰åŸå› ï¼Œä¼šä½¿ç”¨å¤šçº§CAçš„æ¨¡å¼ï¼Œå³CAè¯ä¹¦ç”±ä¸Šçº§CAç­¾å‘ï¼Œæœ€åå°†æ ¡éªŒé“¾ä¸Šçš„è¯ä¹¦ä¸€å¹¶å‘é€ç»™ç”³è¯·è€…ï¼Œåç»­æ ¡éªŒæ—¶å°†è¿›è¡Œè¯ä¹¦çš„é€çº§æ ¡éªŒã€‚\nè¿˜è®°å¾—ä¸Šé¢åœºæ™¯ä¸­æåˆ°çš„ï¼šAliceéªŒè¯Bobçš„è¯ä¹¦è¿™ä¸€æ­¥å—ï¼ŸAliceæ­£æ˜¯é€šè¿‡CAè¯ä¹¦ä¸­çš„å…¬é’¥æ¥æ ¡éªŒBobè¯ä¹¦ç­¾åçš„ã€‚åŸå› æ­£æ˜¯åŸºäºCAæ˜¯Aliceæ‰€ä¿¡ä»»çš„è¯ä¹¦è®¤è¯è€…ã€‚å½“ç„¶éªŒè¯è¯ä¹¦è¿˜éœ€è¦å¯¹certificateInfoæ ¡éªŒï¼Œç¡®å®šBobçš„èº«ä»½ï¼Œä¸‹ç« å°±ä¼šè®²åˆ°ã€‚\nX.509 ç»ˆäºåˆ°äº†é‡å¤´æˆï¼Œæˆ‘ä»¬çš„ä¸»è§’ï¼ŒX.509æ ¼å¼çš„è¯ä¹¦ã€‚å†å¼ºè°ƒä¸€æ¬¡ï¼Œè¯ä¹¦æ˜¯åŠŸèƒ½æ€§çš„æè¿°ï¼Œè€ŒX.509åªæ˜¯è¯ä¹¦ä¸€ç§å›½é™…ä¸Šé€šç”¨çš„æ ¼å¼ï¼ŒåŸºäºRFC3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile(X.509 v3), å¯¹åº”äº†PKCS#12ã€‚\nè¿™æ¬¡æˆ‘ä»¬ç›´æ¥æ‹¿ä¸Šä¸€å¼ Googleçš„è¯ä¹¦æ¥çœ‹çœ‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90  Certificate: Data: Version: 3 (0x2) Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT Subject: C = US, ST = California, L = Mountain View, O = Google LLC, CN = www.google.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:bc:1c:aa:96:6f:6f:99:48:79:56:61:4b:7f:ff: dc:39:08:3a:d4:4d:e2:d8:87:80:af:3d:18:5e:71: 2d:ce:09:70:57:39:38:5f:2a:ee:a8:35:f4:3a:86: 86:5a:1d:c7:31:32:1b:8d:ac:d0:46:ad:c3:fc:a5: d3:18:36:68:ab ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Authority Information Access: OCSP - URI:http://ocsp.pki.goog/gts1o1core CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt X509v3 Subject Alternative Name: DNS:www.google.com X509v3 Certificate Policies: Policy: 2.23.140.1.2.2 Policy: 1.3.6.1.4.1.11129.2.5.3 X509v3 CRL Distribution Points: Full Name: URI:http://crl.pki.goog/GTS1O1core.crl CT Precertificate SCTs: Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 5E:A7:73:F9:DF:56:C0:E7:B5:36:48:7D:D0:49:E0:32: 7A:91:9A:0C:84:A1:12:12:84:18:75:96:81:71:45:58 Timestamp : Aug 26 09:14:24.417 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:20:77:F3:D6:8B:51:4F:88:71:16:73:ED:36: 2F:64:F4:77:3E:92:D3:CE:97:1F:1C:53:FA:4E:FB:5B: D7:0A:4C:D6:02:21:00:9F:B9:FE:F1:F3:1C:0D:CF:20: 30:B1:1C:0A:01:65:AD:67:90:1F:B5:33:90:8D:49:4D: 2B:ED:1D:90:28:A1:6B Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 07:B7:5C:1B:E5:7D:68:FF:F1:B0:C6:1D:23:15:C7:BA: E6:57:7C:57:94:B7:6A:EE:BC:61:3A:1A:69:D3:A2:1C Timestamp : Aug 26 09:14:24.367 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:21:00:F4:67:8E:8B:ED:3F:B2:D4:EA:72:EB: 53:F1:52:57:98:D6:63:0E:C0:6B:68:46:CE:F3:AD:25: 52:AD:12:83:27:02:20:05:CA:04:76:D6:4F:2A:E5:D3: 96:85:79:A2:F3:85:29:9E:89:30:00:A7:20:99:2D:F7: C9:56:3C:4E:5D:5C:CF Signature Algorithm: sha256WithRSAEncryption 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: 32:99:29:f8:13:6b:72:af:16:79:63:d3:3f:76:56:57:19:78: 91:86:f8:7a:ee:26:67:98:dc:5e:e4:00:f5:87:a0:01:21:9d: cf:e5:9f:02:f3:2a:fd:0e:fd:78:af:2e:20:29:77:35:e2:c6: 30:ee:ef:be:f2:bb:26:02:52:a2:2d:27:78:ce:a9:8e:39:d0: a2:74:90:11:c5:92:58:3c:7a:88:1d:c7:5a:56:d4:1a:01:00: c3:9d:98:6f:41:02:1f:cb:e2:4d:99:6a:5c:d9:0f:c0:88:08: 15:c5:26:90:a2:a4:15:f6:71:e2:fe:a9:98:dc:40:2a:71:c1: 11:aa:00:73:52:24:74:aa:ae:72:55:2f:0d:31:b7:00:bb:1f: 87:4d:f5:05:ad:ff:7a:93:e0:cf:86:a5:1d:1b:7d:41:fa:10: 99:3b:00:7c:c9:dd:a9:52:5c:06:72:86:96:e7:05:97:77:12: 2f:26:bb:dc:65:c4:48:4d:9c:82:4b:7d:69:27:3f:85:00:2e: b1:5d:8d:dc   åŒæ ·å¯¹ç…§æ ‡å‡†å®šä¹‰è¿›è¡Œå­¦ä¹ å­—æ®µçš„æ„ä¹‰ï¼š\n1 2 3 4  Certificate ::= SEQUENCE { tbsCertificate TBSCertificate, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING }   å¯ä»¥çœ‹åˆ°Dataå¯¹åº”äº†tbsCertificate, ä¹Ÿæ˜¯æ•´å¼ è¯ä¹¦æœ€å…³é”®çš„éƒ¨åˆ†ï¼Œè¯¥å­—æ®µåŒ…å«è¯ä¹¦æ‹¥æœ‰è€…ä¿¡æ¯ã€é¢å‘è€…ä¿¡æ¯ã€å…¬é’¥ä¿¡æ¯ã€æœ‰æ•ˆæœŸä¿¡æ¯ç­‰ï¼Œåé¢å•ç‹¬æ‹¿å‡ºæ¥è¯¦ç»†è§£æã€‚\nå‰©ä¸‹çš„ä¸¤ä¸ªéƒ¨åˆ†ä¸csrå®Œå…¨ä¸€è‡´ï¼ŒåŒæ ·æ˜¯è¡¨æ˜äº†ç­¾åçš„ç®—æ³•ä¸tbsCertificateçš„ç­¾åã€‚è¿™é‡Œè¦æ³¨æ„ï¼Œç­¾å‘è€…issuerä¿¡æ¯è¡¨æ˜äº†è¯ä¹¦ç­¾å‘äººï¼Œä¸€èˆ¬ä¸ºå—ä¿¡ä»»çš„CAã€‚\nTBSCertificate æ ¸å¿ƒå­—æ®µï¼Œä¸€ç‚¹ç‚¹æ‰‹æ’•ï¼›å…ˆçœ‹å®šä¹‰\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  TBSCertificate ::= SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, serialNumber CertificateSerialNumber, signature AlgorithmIdentifier, issuer Name, validity Validity, subject Name, subjectPublicKeyInfo SubjectPublicKeyInfo, issuerUniqueID [1] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version shall be v2 or v3 subjectUniqueID [2] IMPLICIT UniqueIdentifier OPTIONAL, -- If present, version shall be v2 or v3 extensions [3] EXPLICIT Extensions OPTIONAL -- If present, version shall be v3 } Version ::= INTEGER { v1(0), v2(1), v3(2) } CertificateSerialNumber ::= INTEGER Validity ::= SEQUENCE { notBefore Time, notAfter Time } Time ::= CHOICE { utcTime UTCTime, generalTime GeneralizedTime } UniqueIdentifier ::= BIT STRING SubjectPublicKeyInfo ::= SEQUENCE { algorithm AlgorithmIdentifier, subjectPublicKey BIT STRING }   è¿™é‡Œé¡ºä¾¿æä¸€å¥ASN.1ä¸‹çš„å®šä¹‰ä¸­SEQUENCEå’ŒSETçš„åŒºåˆ«åœ¨äºï¼šé€šå¸¸SEQUENCEæ˜¯ä¸€ä¸ªæœ‰åºé›†åˆï¼Œå³ç¼–ç æ—¶å¿…é¡»æŒ‰ç…§é¡ºåºæ’åˆ—ï¼ŒSETåˆ™å¯ä»¥ä¸ºæ— åºçš„é›†åˆã€‚é€šå¸¸è§£æSEQUENCEæ—¶éƒ½å°†æŒ‰åºè§£æã€‚\nversionï¼šX.509æ ‡å‡†ä¸‹ç‰ˆæœ¬ï¼Œä¾‹å­ä¸­è¯ä¹¦ä¸º0x2ï¼Œå³v3ç‰ˆæœ¬ã€‚æ³¨æ„è¯ä¹¦å­˜åœ¨extensionsæ—¶ï¼Œç‰ˆæœ¬ä¸€å®šæ˜¯v3ç‰ˆæœ¬ï¼Œæ•…extensioné€šå¸¸ä¹Ÿç§°ä¸ºX.509 v3 extensionã€‚\nserialNumberï¼šè¯ä¹¦çš„åºåˆ—å·ï¼Œå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªå”¯ä¸€çš„æ•´æ•°ã€‚éœ€è¦æ³¨æ„ä¸€ç‚¹ï¼Œä»–æ˜¯ä¸€ä¸ªå¤§ç«¯æ•°å­—ï¼Œæ‰€ä»¥æœ‰æ—¶å€™ä»–å¯èƒ½é«˜ä½å¡«ä¸€äº›0ï¼Œä½†ä¸å½±å“å…¶å¯¹æ¯”ã€‚æ¯”å¦‚ä¾‹å­ä¸­çš„è¯ä¹¦ï¼Œå®é™…ç¼–ç ä¸­é«˜ä½å¡«ä¸Šäº†0ï¼š\n/* è§£æç»“æœ */ Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f /* ç¼–ç  */ Tag:[02] Length:[11] Value:[00 BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F] åºåˆ—å·çš„ä½œç”¨ä¸»è¦åœ¨CRLä¸­ä½“ç°å”¯ä¸€æ ‡è¯†çš„ä½œç”¨ã€‚å¯ä»¥å¯¹ç…§åˆ°èº«ä»½è¯ä¸Šçš„èº«ä»½è¯å·:)\nsignature: æ ‡è®°äº†è¯ä¹¦çš„ç­¾åç®—æ³•ï¼Œä¸csrä¸€æ ·ï¼Œä¸åšèµ˜è¿°ã€‚\nissuerï¼šæ ‡è®°è¯ä¹¦ç­¾å‘è€…CAçš„ä¿¡æ¯ï¼Œä¾‹å­ä¸­å¯ä»¥çœ‹åˆ°ä¸ºGoogle Trust Servicesç­¾å‘ã€‚å…·ä½“æ ¼å¼ç±»ä¼¼ä¸Šé¢çš„subjectã€‚\nvalidityï¼šæ ‡è¯†äº†è¯ä¹¦çš„ç”Ÿæ•ˆæ—¶é—´ï¼Œä»¥èµ·å§‹æ—¶é—´ä¸ç»“æŸæ—¶é—´è¡¨è¿°ã€‚å¯ä»¥çœ‹åˆ°ä¾‹å­ä¸­çš„è¯ä¹¦çš„ç”Ÿæ•ˆèµ·å§‹æ—¶é—´ä¸ºæ ¼æ—å¨æ²»æ—¶é—´çš„2020/08/26, æœ‰æ•ˆæœŸè‡³2020/11/18ã€‚æ—¶é—´çš„ASN.1é€šå¸¸ä»¥ YYMMDDHHMMSSæ¥æ ‡è¯†ï¼Œç»“å°¾ä»¥Zæˆ–è€…æ—¶åŒºå·®æ ‡è¯†æ—¶åŒºã€‚Zæ˜¯Zuluæ—¶é—´çš„æ„æ€ï¼Œå’Œæ ¼æ—å¨æ²»æ—¶é—´åŒæ­¥ã€‚\nsubjectï¼šè¯ä¹¦æ‹¥æœ‰è€…ä¿¡æ¯ï¼ŒåŒissuerã€‚ä¸Šé¢æåˆ°æ ¡éªŒBobçš„ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯å¯¹è¿™ä¸€æ®µçš„éªŒè¯ã€‚\nsubjectPublicKeyInfoï¼šè¯ä¹¦å…¬é’¥ä¿¡æ¯ï¼Œä¹Ÿå’Œcsrä¸­çš„ä¸€è‡´ã€‚\nUniqueIDï¼šå¯é€‰å­—æ®µï¼Œè¿™ä¸ªå­—æ®µå¿…é¡»è¦v2åŠä»¥ä¸Šç‰ˆæœ¬æ‰æœ‰ï¼Œä¸»è¦æ˜¯ç”¨æ¥é˜²æ­¢issuerä¸subjecté‡åçš„æƒ…å†µã€‚ä¾‹å­ä¸­çš„è¯ä¹¦æ˜¯æ²¡æœ‰çš„\nExtension extensionæ˜¯æœ€é‡å¤´æˆçš„å­—æ®µï¼š\n1 2 3 4 5 6  Extensions ::= SEQUENCE SIZE (1..MAX) OF Extension Extension ::= SEQUENCE { extnID OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING }   é€šè¿‡æè¿°å¯ä»¥çœ‹åˆ°Extensionsæ˜¯ä¸€ä¸ªå¯é€‰å­—æ®µï¼Œå…¶å†…éƒ¨å¯ä»¥æœ‰æœ€å¤šMAXä¸ªæ‹“å±•å­—æ®µï¼Œè¿™é‡Œå½“ç„¶æ— æ³•å•ç‹¬å®Œæˆé˜è¿°ï¼ŒæŒ‘ä¸€äº›ä¾‹å­ä¸­çš„æ ‡å‡†æ‹“å±•å­—æ®µæè¿°ã€‚\nAuthority Key Identifier/Subject Key Identifier: è¿™ä¸¤ä¸ªå­—æ®µä¸»è¦æ˜¯åœ¨å¤šè¯ä¹¦çš„åœºæ™¯æä¾›ä¸€ç§å¿«é€Ÿç¡®å®šæ‰€éœ€è¦å…¬é’¥çš„æ ‡è®°ã€‚Authority Key Identifierå”¯ä¸€æ ‡è®°äº†è¯¥è¯ä¹¦ç­¾å‘ç§é’¥å¯¹åº”çš„å…¬é’¥ï¼Œè€ŒSubject Key Identifieråˆ™æ˜¯å”¯ä¸€æ ‡è®°äº†å½“å‰è¯ä¹¦ä¸­çš„å…¬é’¥ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œä¸€ä¸ªè®¾å¤‡å½“ä¸­å¯èƒ½æœ‰å¥½å¤šä¸ªè¯ä¹¦ï¼Œä½†æ˜¯æ¯ä¸€ä¸ªappå¯èƒ½åªéœ€è¦å¯¹åº”è¯ä¹¦ä¸­çš„å…¬é’¥ï¼Œé‚£ä¹ˆå°±å¯ä»¥å°†è¿™ä¸€ä¸²IDå†…ç½®åœ¨appä¸­ï¼Œè¯ä¹¦ä¹Ÿä¸éœ€è¦å®Œæ•´è§£æï¼Œå…ˆå»çœ‹çœ‹å¯¹åº”Key Identifierå­—æ®µæ˜¯ä¸æ˜¯åŒ¹é…å³å¯ã€‚é€šå¸¸è®¡ç®—æ–¹å¼ä¸ºè®¡ç®—å…¬é’¥çš„SHA1å€¼ï¼Œæœ¬ä¾‹å­ä¸­çš„Subject Key Identifierå³ä¸ºè¿™ç§æ–¹å¼ï¼š\n1 2 3 4 5 6 7 8 9  X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 from hashlib import sha1 hash = sha1() hash.update(b\u0026#34;\\x04\\xbc\\x1c\\xaa\\x96\\x6f\\x6f\\x99\\x48\\x79\\x56\\x61\\x4b\\x7f\\xff\\xdc\\x39\\x08\\x3a\\xd4\\x4d\\xe2\\xd8\\x87\\x80\\xaf\\x3d\\x18\\x5e\\x71\\x2d\\xce\\x09\\x70\\x57\\x39\\x38\\x5f\\x2a\\xee\\xa8\\x35\\xf4\\x3a\\x86\\x86\\x5a\\x1d\\xc7\\x31\\x32\\x1b\\x8d\\xac\\xd0\\x46\\xad\\xc3\\xfc\\xa5\\xd3\\x18\\x36\\x68\\xab\u0026#34;) hash.hexdigest() \u0026gt;\u0026gt;\u0026gt;\u0026#39;af32a89d2098f3fd1441fef4c474477cd16c81b1\u0026#39;   Key Usage/Extended Key Usage: ç¡®å®šè¯ä¹¦ä¸­å…¬é’¥çš„ç”¨é€”ã€‚ä»¥å‰ä¸€ä¸ªä¸ºä¸»ï¼Œextendedå­—æ®µä½œä¸ºè¡¥å……ã€‚ä¾‹å­ä¸­çš„è¯ä¹¦ä¸»è¦å°±æ˜¯ç”¨æ¥åšTLSé€šè®¯ä¸­çš„æ•°å­—ç­¾ååŠŸèƒ½ã€‚Key Usageä¸»è¦ç±»å‹æœ‰ä»¥ä¸‹å‡ ç§ï¼Œè¯¦ç»†æè¿°å¯ä»¥å‚è€ƒæ ‡å‡†ä¸­çš„æè¿°ï¼Œè¿™é‡Œä¸å±•å¼€è¯´äº†ï¼š\n1 2 3 4 5 6 7 8 9 10  KeyUsage ::= BIT STRING { digitalSignature (0), nonRepudiation (1), keyEncipherment (2), dataEncipherment (3), keyAgreement (4), keyCertSign (5), cRLSign (6), encipherOnly (7), decipherOnly (8) }   Certificate Policiesï¼šä»¥OIDæ ¼å¼ä½“ç°ï¼Œä¸»è¦æ˜¯è¡¨ç°ç”³è¯·è¯ä¹¦æ—¶çš„ç¼˜ç”±å’Œé¢„æœŸçš„ç”¨é€”ã€‚ä¾‹å­ä¸­çš„2.23.140.1.2.2å’Œ1.3.6.1.4.1.11129.2.5.3æ˜¯å…¸å‹çš„OIDæ ¼å¼ï¼Œæ¯ä¸ªç‚¹éš”å¼€ä¸€ä¸ªå±æ€§å±‚çº§ï¼Œå¯ä»¥é€šè¿‡ http://www.oid-info.com/ è¿›è¡ŒObjectçš„æŸ¥è¯¢ï¼Œå¦‚2.23.140.1.2.2è¡¨ç¤ºä¸ºorganization-validatedï¼Œå³\n Certificates issued in accordance with the CA/Browser Forum\u0026rsquo;s Baseline Requirements - Organization identity asserted\n Authority Information Accessï¼šæ ‡è¯†äº†CA Issuerçš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬OCSPæœåŠ¡çš„ç½‘å€ä¸CAè¯ä¹¦çš„ä¸‹è½½åœ°å€ã€‚è¯¥éƒ¨åˆ†åœ¨TLSå¾ˆé‡è¦ã€‚OCSPæœåŠ¡ä¼šåœ¨åç»­CRLä¸­æåˆ°ã€‚\nCRL Distribution Pointsï¼šCRL(Certificate Revocation List), æ ‡è¯†äº†å½“å‰CAä¸‹åŠé”€åˆ—è¡¨æ–‡ä»¶çš„ä¸‹è½½åœ°å€ï¼Œä¹Ÿæ˜¯TLSæ¡æ‰‹é˜¶æ®µé‡è¦çš„è¿‡ç¨‹ã€‚åç»­å°†ç»§ç»­åˆ†æã€‚\nCT Precertificate SCTsï¼šè¯ä¹¦é€æ˜åº¦(Certificate Transparency); è¿™ä¸ªæ˜¯æ ‡å‡†ä¸­æ²¡æœ‰æåˆ°çš„ä¸€ä¸ªæ¯”è¾ƒæ–°çš„æ‹“å±•ã€‚CTä¸»è¦æ­é…äº†CAæœåŠ¡å™¨ä¸Šå…¬å¼€çš„Logï¼Œå°†è®°å½•CAçš„è¡Œä¸ºæ—¥å¿—ï¼Œè€Œæ¯ä¸€ä¸ªä¸å½“å‰è¯ä¹¦ç›¸å…³çš„æ—¥å¿—å°†è¢«è®¡å…¥æ­¤å­—æ®µï¼Œå¹¶è¢«CAè¿›è¡Œç­¾åã€‚æ ¡éªŒé˜¶æ®µå¯ä»¥æ ¹æ®Log IDå’ŒtimestampæŸ¥æ‰¾æ—¥å¿—ä¸­çš„å¯¹åº”æ“ä½œï¼Œå¯¹è¯ä¹¦è¿›è¡Œå®¡è®¡ä»¥ç¡®å®šå½“å‰è¯ä¹¦çš„åˆæ³•æ€§ã€‚è¯¥å­—æ®µçš„æå‡ºä¸»è¦å°±æ˜¯é˜²æ­¢CAè¢«å…¥ä¾µè€…åˆ©ç”¨åè·å–å¤§é‡éæ³•ç­¾å‘è¯ä¹¦ï¼Œè€Œé€æ˜æ€§çš„æ—¥å¿—ä¿è¯äº†è¯ä¹¦çš„ç­¾å‘æ˜¯åˆ°å—åˆ°ä¸¥æ ¼ç›‘æ§çš„ã€‚\nCRL è¯ä¹¦çš„æœ‰æ•ˆæœŸä¼¼ä¹å·²ç»èƒ½å¤Ÿé˜²æ­¢å›é€€ä¹‹å†…çš„æ”»å‡»äº†ï¼Œä½†æ˜¯ä¸‡ä¸€åœ¨æœ‰æ•ˆæœŸå†…å‘ç”Ÿäº†å¯¹åº”ç§é’¥çš„æ³„æ¼äº‹ä»¶ï¼Œè¯¥æ€ä¹ˆå–æ¶ˆæ‰è¯ä¹¦çš„æœ‰æ•ˆæ€§å‘¢ï¼Ÿè¿™æ—¶å€™å°±éœ€è¦crlå‡ºåœºäº†ã€‚\nä¸Šé¢å·²ç»æåˆ°äº†CRL Distribution Pointsï¼Œç›´æ¥ä»å¯¹åº”åœ°å€ä¸‹è½½ä¸ªcrlï¼š\nCertificate Revocation List (CRL): Version 2 (0x1) Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Last Update: Sep 19 02:13:00 2020 GMT Next Update: Sep 29 02:13:00 2020 GMT CRL extensions: X509v3 CRL Number: 1001 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Revoked Certificates: Serial Number: 049950FB5DD23C3502000000007A32AD Revocation Date: Sep 10 15:53:36 2020 GMT CRL entry extensions: X509v3 CRL Reason Code: Affiliation Changed Serial Number: 05303980A9456025080000000056050B Revocation Date: Sep 10 15:53:42 2020 GMT CRL entry extensions: X509v3 CRL Reason Code: Affiliation Changed ...... Signature Algorithm: sha256WithRSAEncryption 00:37:3c:7e:ba:71:d2:92:52:3a:f6:4d:86:c0:a2:c2:18:78: 34:0e:ea:80:41:08:82:32:54:42:f0:2c:d7:f7:e0:81:93:dc: 0d:e5:0b:71:1f:ae:7e:bf:1c:05:3c:3c:f8:2b:cb:99:20:21: 80:29:a9:81:1d:f4:33:f4:21:95:70:f1:4c:38:30:34:28:32: be:0a:0b:0d:09:5d:81:33:72:fb:40:16:db:26:a1:7d:e9:11: 56:74:11:58:e3:4d:37:93:23:68:6a:85:8c:89:05:7d:55:67: 8c:da:3c:02:cb:46:3b:4e:7d:c6:38:12:02:cc:a8:ff:57:04: 9d:0a:bf:07:30:36:5d:85:b7:4c:9e:a1:52:b8:2c:4a:ec:91: ba:ba:8f:74:60:f4:06:84:8b:d9:a7:08:3d:2a:cf:ee:66:c6: de:1e:ae:68:24:ed:0d:ca:d6:73:0e:40:b2:5c:91:00:dc:32: 72:04:8b:46:65:12:9c:56:9d:aa:76:89:7b:c2:74:a8:b0:a3: de:e6:d6:d1:12:87:16:34:98:9b:2e:bd:38:ea:1c:59:03:40: 0d:ba:0c:0c:f2:9e:31:64:33:1b:28:43:4e:3b:78:41:2e:d9: 82:21:39:97:fe:c0:ab:9f:82:8d:18:02:26:c4:b0:44:c5:74: 25:30:6a:50 è¿˜æ˜¯å…ˆå¯¹åº”ASN.1å¯¹äºcrlæ ¼å¼çš„æè¿°çœ‹ä¸€ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  CertificateList ::= SEQUENCE { tbsCertList TBSCertList, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING } TBSCertList ::= SEQUENCE { version Version OPTIONAL, -- if present, MUST be v2 signature AlgorithmIdentifier, issuer Name, thisUpdate Time, nextUpdate Time OPTIONAL, revokedCertificates SEQUENCE OF SEQUENCE { userCertificate CertificateSerialNumber, revocationDate Time, crlEntryExtensions Extensions OPTIONAL -- if present, MUST be v2 } OPTIONAL, crlExtensions [0] EXPLICIT Extensions OPTIONAL -- if present, MUST be v2 }   å¯ä»¥çœ‹åˆ°è¿™æ—¶å€™crlçš„è§£æå‡ºæ¥çš„æ ¼å¼é¡ºåºå·²ç»å’Œæ ‡å‡†çš„å®šä¹‰ç•¥æœ‰åŒºåˆ«ï¼Œä½†æ˜¯ä¸å½±å“ï¼Œåªè¦çŸ¥é“æ‰€æœ‰çš„åŠé”€åˆ—è¡¨ä¿¡æ¯è‚¯å®šéƒ½æ˜¯è¢«CAç­¾åäº†çš„ã€‚\nsignatureAlgorithmå’ŒsignatureValue æ²¡å•¥å¥½è¯´çš„ï¼Œå’Œä¹‹å‰è¯ä¹¦å’Œç”³è¯·æ–‡ä»¶æ²¡æœ‰åŒºåˆ«ã€‚\nCertList è¿™ä¸€æ®µå¯åˆ†ä¸ºä¸»è¦çš„ä¸¤ä¸ªéƒ¨åˆ†ï¼šåŠé”€æ–‡ä»¶ä¿¡æ¯å’ŒåŠé”€è¯ä¹¦åˆ—è¡¨ï¼Œè¿™ä¹Ÿæ˜¯è§£æå‡ºæ¥crlæ²¡æœ‰æŒ‰ç…§é¡ºåºæ’åˆ—çš„åŸå› ï¼Œä¸ºäº†æ‰“å°çš„å¥½çœ‹ï¼Œè¿™ä¸€æ®µè¢«æ‹†åˆ†æˆäº†ä¸¤éƒ¨åˆ†\nå…ˆçœ‹åŠé”€æ–‡ä»¶ä¿¡æ¯ï¼š\nversionã€signatureå’Œissuer å’Œä¹‹å‰å®Œå…¨ä¸€æ ·ï¼Œä¸å†èµ˜è¿°ã€‚\nthisUpdateï¼šæŒ‡å®šäº†æœ¬æ¬¡crlç­¾å‘çš„çš„æ—¶é—´ã€‚ä¸»è¦ç”¨æ¥ä¿è¯crlè¯ä¹¦çš„æ—¶æ•ˆæ€§\nnextUpdateï¼šå¯é€‰é¡¹ï¼ŒæŒ‡å®šäº†ä¸‹ä¸€æ¬¡crlç­¾å‘çš„æ—¶é—´\ncrlExtensionsï¼šåŒ…å«äº†æ‹“å±•ä¿¡æ¯ï¼Œæ³¨æ„è¿™ä¸ªå­—æ®µåœ¨å®é™…çš„è¯ä¹¦ä¸­æ˜¯æ”¾åœ¨revokedCertificatesåé¢çš„ã€‚åœ¨ç”¨ä¾‹çš„googleè¯ä¹¦çš„crlä¸­å¯ä»¥çœ‹åˆ°åŠé”€è¯ä¹¦çš„æ•°é‡(CRL Number: 1001)å’ŒAuthority Key Identifier,å¯ä»¥çœ‹åˆ°è¿™ä¸ªAuthority Key Identifierå’ŒX.509è¯ä¹¦ä¸­çš„ç›¸åŒå­—æ®µæ˜¯ä¸€æ¨¡ä¸€æ ·çš„ã€‚æ³¨æ„è¿™ä¸ªåœ°æ–¹CRL Numberæ˜¯ä¸ä¸€å®šç­‰äºrevokedCertificatesä¸­è¢«åŠé”€åˆ—è¡¨æ•°é‡çš„ï¼Œå…¶å®ä¸ºäº†åŠ å¿«æŸ¥æ‰¾æ•ˆç‡ï¼Œå·²ç»è¿‡æœŸçš„è¢«åŠé”€è¯ä¹¦æ˜¯å¯ä»¥ä»åˆ—è¡¨ä¸­ç§»é™¤ä»¥å‡å°åˆ—è¡¨çš„å¤§å°ã€‚\nrevokedCertificates è¿™æ˜¯crlçš„æ ¸å¿ƒéƒ¨åˆ†ï¼ŒåŒ…å«äº†è¢«åŠé”€è¯ä¹¦çš„å”¯ä¸€åºåˆ—å·(userCertificate CertificateSerialNumber)ï¼Œè¯ä¹¦çš„åŠé”€æ—¶é—´(revocationDate)ï¼Œä»¥åŠä¸€äº›æ‰©å±•ï¼Œç”¨ä¾‹ä¸­åŒ…å«äº†å…¸å‹ç”¨ä¾‹ï¼šåŠé”€åŸå› ç (CRL Reason Code)ã€‚\nä¸»è¦çœ‹ä¸€ä¸‹å”¯ä¸€åºåˆ—å·è¿™ä¸ªæ®µï¼Œè¿™ä¸ªæ®µæ˜¯åˆšå¥½å¯¹åº”X.509è¯ä¹¦ä¸­çš„serialNumberæ®µï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆè¿™ä¸ªæ®µéœ€è¦å”¯ä¸€çš„åŸå› ï¼šä»–æ ‡è¯†äº†ä¸€å¼ ç‹¬ä¸€æ— äºŒçš„è¯ä¹¦ã€‚\nå…¶å®è¿™æ—¶å€™æŸ¥è¯¢ä¸€ä¸ªåˆ—è¡¨æ˜¯å¦åŠé”€çš„æµç¨‹å·²ç»å¾ˆç®€å•äº†ï¼š\n æ¡æ‰‹é˜¶æ®µè·å–crl é€šè¿‡CAè¯ä¹¦æ ¡éªŒcrlç­¾å æŸ¥è¯¢å¯¹ç«¯è¯ä¹¦çš„åºåˆ—å·æ˜¯å¦åœ¨revokedCertificatesä¸­  ä½†æ˜¯è¿™æ˜¯å”¯ä¸€çš„æ–¹æ³•å—ï¼Ÿå¦‚æœç¢°åˆ°åƒå½“å¹´heartbleedä¸€æ ·çš„å¤§å‹æ³„æ¼äº‹ä»¶ï¼ŒåŠé”€åˆ—è¡¨æ˜¯ä¸æ˜¯ç‰¹åˆ«å¤§ï¼Œç‰¹åˆ«å¤§ä¼šé€ æˆä¸¤ä¸ªé—®é¢˜ï¼šä¸‹è½½æ…¢ã€æŸ¥è¯¢æ…¢ï¼Œæœ€ç»ˆå¯¼è‡´æ¡æ‰‹è¶…æ—¶ã€‚\nç¬¬äºŒç‚¹é—®é¢˜æ˜¯crlæœ‰æ›´æ–°ä¸åŠæ—¶çš„é—®é¢˜ï¼šCAæœºæ„åœ¨åŠé”€ä¸€å¼ è¯ä¹¦åï¼Œä¸ä¼šç«‹åˆ»å»æ›´æ–°CRLsæ–‡ä»¶ï¼Œå®¢æˆ·ç«¯å®šæœŸç¼“å­˜çš„CRLsæ–‡ä»¶ä¹Ÿä¸æ˜¯åŠæ—¶æ›´æ–°çš„ï¼Œæ‰€ä»¥ä¼šå¯¼è‡´ä¸€ç§æƒ…å†µæ˜¯ï¼ŒæŸå¼ è¯ä¹¦è¢«åŠé”€åï¼Œç”±äºCRLsæ–‡ä»¶æ²¡æœ‰åŠæ—¶æ›´æ–°çš„ç¼˜æ•…ï¼Œèº«ä»½æ ¡éªŒé€šè¿‡äº†ï¼Œè®¤ä¸ºè¯¥å¼ è¯ä¹¦æ²¡æœ‰é—®é¢˜ã€‚\næ‰€ä»¥ä¸ºäº†è§£å†³å¯¹åº”çš„é—®é¢˜ï¼ŒSSLä¸­åŒ…å«ä¸€ç§æ–°åè®®\nOCSP OCSPï¼ˆOnline Certificate Status Protocolï¼‰ï¼Œå³åœ¨çº¿è¯ä¹¦çŠ¶æ€åè®®ã€‚åŒæ ·æ˜¯ç”¨æ¥åšæœåŠ¡å™¨èº«ä»½æ ¡éªŒï¼Œç”±CAæœºæ„ç®¡ç†ï¼Œä½¿ç”¨æ•°å­—ç­¾åæŠ€æœ¯ä¿æŠ¤ï¼Œæµè§ˆå™¨å¯ä»¥ä»ä¸­è·å¾—è¯ä¹¦çš„åŠé”€çŠ¶æ€å’ŒåŠé”€åŸå› ï¼Œæ–¹å¼æ˜¯ç”±èº«ä»½æ ¡éªŒæ–¹æµè§ˆå™¨å‘é€OCSPè¯·æ±‚ï¼Œç­‰å¾…å“åº”æ¥å®Œæˆè¯ä¹¦çŠ¶æ€è·å–ã€‚å½“ç„¶OCSPçš„æ ¼å¼åŒæ ·è¦éµç…§æ ‡å‡†rfc6960ã€‚è¿™é‡Œå°±ä¸ç»†è§£æOCSPæ ¼å¼äº†ï¼Œå¯ä»¥å‚è€ƒæ ‡å‡†æ–‡æ¡£ã€‚\nå½“ç„¶OCSPæœ€ä¸ºåè®®å½“ç„¶ä¹Ÿæœ‰requestå’Œresponse(å…¶å®csrå°±æ˜¯è¯·æ±‚ï¼Œç”³è¯·ä¸‹æ¥çš„è¯ä¹¦å°±æ˜¯ç­”å¤)ï¼Œè¿™é‡Œè´´ä¸€ä¸‹requestçš„æ ¼å¼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  OCSPRequest ::= SEQUENCE { tbsRequest TBSRequest, optionalSignature [0] EXPLICIT Signature OPTIONAL } TBSRequest ::= SEQUENCE { version [0] EXPLICIT Version DEFAULT v1, requestorName [1] EXPLICIT GeneralName OPTIONAL, requestList SEQUENCE OF Request, requestExtensions [2] EXPLICIT Extensions OPTIONAL } Signature ::= SEQUENCE { signatureAlgorithm AlgorithmIdentifier, signature BIT STRING, certs [0] EXPLICIT SEQUENCE OF Certificate OPTIONAL} Version ::= INTEGER { v1(0) } Request ::= SEQUENCE { reqCert CertID, singleRequestExtensions [0] EXPLICIT Extensions OPTIONAL } CertID ::= SEQUENCE { hashAlgorithm AlgorithmIdentifier, issuerNameHash OCTET STRING, -- Hash of issuer\u0026#39;s DN issuerKeyHash OCTET STRING, -- Hash of issuer\u0026#39;s public key serialNumber CertificateSerialNumber }   å°¾å£° çœ‹èµ·æ¥X.509è¿™ä¸€ç³»åˆ—å¥½åƒå¾ˆç®€å•çš„æ ·å­ï¼Œç„¶è€Œè¿™é‡Œæ‰“å‡ºæ¥çš„å…¶å®éƒ½æ˜¯å®Œæˆè§£æä¹‹åçš„æ ·å­ï¼Œé‚£ä¹ˆè§£æä¹‹å‰çš„DERæ ¼å¼çš„è¯ä¹¦æ˜¯å•¥æ ·å­çš„å‘¢ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  00000000: 3082 04c8 3082 03b0 a003 0201 0202 1100 0...0........... 00000010: bc01 4105 22d8 cc7f 0200 0000 0079 647f ..A.\u0026#34;........yd. 00000020: 300d 0609 2a86 4886 f70d 0101 0b05 0030 0...*.H........0 00000030: 4231 0b30 0906 0355 0406 1302 5553 311e B1.0...U....US1. 00000040: 301c 0603 5504 0a13 1547 6f6f 676c 6520 0...U....Google 00000050: 5472 7573 7420 5365 7276 6963 6573 3113 Trust Services1. 00000060: 3011 0603 5504 0313 0a47 5453 2043 4120 0...U....GTS CA 00000070: 314f 3130 1e17 0d32 3030 3832 3630 3831 1O10...200826081 00000080: 3432 335a 170d 3230 3131 3138 3038 3134 423Z..2011180814 00000090: 3233 5a30 6831 0b30 0906 0355 0406 1302 23Z0h1.0...U.... 000000a0: 5553 3113 3011 0603 5504 0813 0a43 616c US1.0...U....Cal 000000b0: 6966 6f72 6e69 6131 1630 1406 0355 0407 ifornia1.0...U.. 000000c0: 130d 4d6f 756e 7461 696e 2056 6965 7731 ..Mountain View1 000000d0: 1330 1106 0355 040a 130a 476f 6f67 6c65 .0...U....Google 000000e0: 204c 4c43 3117 3015 0603 5504 0313 0e77 LLC1.0...U....w 000000f0: 7777 2e67 6f6f 676c 652e 636f 6d30 5930 ww.google.com0Y0 00000100: 1306 072a 8648 ce3d 0201 0608 2a86 48ce ...*.H.=....*.H. 00000110: 3d03 0107 0342 0004 bc1c aa96 6f6f 9948 =....B......oo.H 00000120: 7956 614b 7fff dc39 083a d44d e2d8 8780 yVaK...9.:.M.... 00000130: af3d 185e 712d ce09 7057 3938 5f2a eea8 .=.^q-..pW98_*.. 00000140: 35f4 3a86 865a 1dc7 3132 1b8d acd0 46ad 5.:..Z..12....F. 00000150: c3fc a5d3 1836 68ab a382 025c 3082 0258 .....6h....\\0..X 00000160: 300e 0603 551d 0f01 01ff 0404 0302 0780 0...U........... 00000170: 3013 0603 551d 2504 0c30 0a06 082b 0601 0...U.%..0...+.. ...   å•¥å•¥å•¥ï¼Œè¿™æ˜¯å•¥ï¼Ÿï¼Ÿ\nå…¶å®è¿™å°±æ˜¯åå¤æåˆ°çš„ASN.1æ ¼å¼ã€‚ç³»åˆ—ä¸‹ä¸€ç« å°±æ˜¯æ‰‹æ’•ASN.1, åšä¸€ä¸ªäººè‚‰decoder(æƒ³å¤šäº†\u0026hellip;)\n","description":"X.509è¯ä¹¦æ ¼å¼ä»‹ç»","id":6,"section":"posts","tags":["OpenSSL"],"title":"X.509ç³»åˆ—ï¼ˆä¸€ï¼‰ï¼šX.509 v3æ ¼å¼ä¸‹çš„è¯ä¹¦","uri":"https://summersummer3.github.io/posts/x509_1/"},{"content":"ASN.1ç¼–è§£ç æ ‡å‡†X.690 ä¹¦æ¥ä¸Šæ–‡ï¼Œæˆ‘ä»¬æœ‰æåˆ°X.509æ ¼å¼çš„è¯ä¹¦é€šå¸¸æ˜¯ä½¿ç”¨ASN.1çš„æ ¼å¼ç¼–ç çš„ã€‚é‚£ä¹ˆASN.1æ˜¯ä¸ªå•¥ï¼Œå¦‚ä½•è¿›è¡Œç¼–ç è§£ç å‘¢ã€‚è¿™ç¯‡æ–‡ç« ä¸»è¦ç”¨æ¥è§£è¯»ASN.1çš„æ ‡å‡†ï¼Œå­¦ä¹ æˆä¸ºè§£ç äººæŸ±åŠ›ã€‚\nASN.1ä¸TLV å…ˆçœ‹çœ‹wikiå¯¹äºANS.1æ ¼å¼çš„æè¿°ï¼š\n åœ¨ç”µä¿¡å’Œè®¡ç®—æœºç½‘ç»œé¢†åŸŸï¼ŒASN.1ï¼ˆAbstract Syntax Notation One) æ˜¯ä¸€å¥—æ ‡å‡†ï¼Œæ˜¯æè¿°æ•°æ®çš„è¡¨ç¤ºã€ç¼–ç ã€ä¼ è¾“ã€è§£ç çš„çµæ´»çš„è®°æ³•ã€‚å®ƒæä¾›äº†ä¸€å¥—æ­£å¼ã€æ— æ­§ä¹‰å’Œç²¾ç¡®çš„è§„åˆ™ä»¥æè¿°ç‹¬ç«‹äºç‰¹å®šè®¡ç®—æœºç¡¬ä»¶çš„å¯¹è±¡ç»“æ„ã€‚\n çœ‹èµ·æ¥å¾ˆå‰å®³ï¼Œå†çœ‹çœ‹å…¶ç±»åˆ«æœ‰å“ªäº›ï¼š\n ASN.1æœ¬èº«åªå®šä¹‰äº†è¡¨ç¤ºä¿¡æ¯çš„æŠ½è±¡å¥æ³•ï¼Œä½†æ˜¯æ²¡æœ‰é™å®šå…¶ç¼–ç çš„æ–¹æ³•ã€‚å„ç§ASN.1ç¼–ç è§„åˆ™æä¾›äº†ç”±ASN.1æè¿°å…¶æŠ½è±¡å¥æ³•çš„æ•°æ®çš„å€¼çš„ä¼ é€è¯­æ³•ï¼ˆå…·ä½“è¡¨è¾¾ï¼‰ã€‚æ ‡å‡†çš„ASN.1ç¼–ç è§„åˆ™æœ‰åŸºæœ¬ç¼–ç è§„åˆ™ï¼ˆBERï¼ŒBasic Encoding Rulesï¼‰ã€è§„èŒƒç¼–ç è§„åˆ™ï¼ˆCERï¼ŒCanonical Encoding Rulesï¼‰ã€å”¯ä¸€ç¼–ç è§„åˆ™ï¼ˆDERï¼ŒDistinguished Encoding Rulesï¼‰ã€å‹ç¼©ç¼–ç è§„åˆ™ï¼ˆPERï¼ŒPacked Encoding Rulesï¼‰XMLç¼–ç è§„åˆ™ï¼ˆXERï¼ŒXML Encoding Rulesï¼‰ã€‚\n å¾ˆæ˜¾ç„¶ï¼Œè¿™ç§ç¼–ç æ–¹æ³•éå¸¸å¤šã€‚ä½†æ˜¯ä¸è¦æ…Œï¼Œå¤§éƒ¨åˆ†å¯†ç ç›¸å…³æ ‡å‡†ç”¨åˆ°çš„ç¼–ç æ–¹å¼éƒ½æ˜¯BER/CER/DERï¼Œè€Œåé¢ä¸¤ç§åˆ™æ˜¯å¯¹BERå¢åŠ é™åˆ¶åçš„äº§ç‰©ã€‚è‡³äºPER/XERï¼Œè‡³å°‘åœ¨ç¬”è€…ç›®å‰å·¥ä½œä¸­è¿˜æ²¡æœ‰æ¥è§¦åˆ°è¿‡ï¼Œæœ¬æ–‡å°±ä¸è¿›è¡Œä»‹ç»äº†ã€‚\nä¸ºä»€ä¹ˆè¦æŠŠå‰ä¸‰è€…å½’ä¸ºä¸€ç±»å‘¢ï¼ŒåŸå› å¾ˆç®€å•ï¼Œè¿™ä¸‰ç§ç¼–ç æ–¹å¼æ˜¯ä¸€ç§å…¸å‹TLVçš„ç¼–ç æ–¹æ³•ã€‚TLV:Type-Length-Value, æ˜¯ä¸€ç§å„ç±»é€šè®¯åè®®ä¸­éƒ½éå¸¸å¸¸è§çš„ç¼–ç æ‰‹æ®µï¼Œä»–å°†ä¸€æ®µæ•°æ®åˆ†è§£ä½¿ç”¨Typeæè¿°äº†æ•°æ®ç±»å‹ï¼Œç”¨Lengthæè¿°çš„æ•°æ®é•¿åº¦ï¼Œæœ€åçš„Valueè¡¨ç¤ºäº†çœŸæ­£çš„dataã€‚å…¶ä¼˜ç‚¹ä¹Ÿéå¸¸æ˜æ˜¾ï¼Œä»–å¯ä»¥å°†ä¸€æ®µæ•°æ®ä»¥äºŒè¿›åˆ¶çš„æ ¼å¼ç¼–ç ï¼Œå¤§é‡å‹ç¼©äº†ç¼–ç å¯¼è‡´çš„æŠ¥æ–‡ä½“ç§¯è†¨èƒ€çš„æ¶ˆè€—ï¼ŒåŒæ—¶ç”±äºç¼–ç ç®€å•ï¼Œè§£æé€Ÿåº¦ä¹Ÿéå¸¸è¿…é€Ÿã€‚å…¶ç»“æ„å¾ˆç®€å•ï¼Œé€šå¸¸å¦‚ä¸‹ï¼š\nType | Length | Value\nä»¥ä¸€ä¸ªæ‰‹æœºå·ç çš„ç¼–ç ä¸ºä¾‹18570917612ï¼š\nå…ˆçœ‹Typeï¼Œå‡è®¾ç”¨ä¸€ä¸ªå­—èŠ‚è¡¨ç¤ºTypeï¼Œå¦‚0x00è¡¨ç¤ºæ‰‹æœºå·ç ï¼Œ0x01è¡¨ç¤ºå›ºå®šç”µè¯å·ç ï¼Œ0x02è¡¨ç¤ºä¼ çœŸå·ç­‰ç­‰ã€‚å½“ç„¶æ­¤æ—¶è¿˜å¯ä»¥åŒºåˆ†å›½å®¶å·ã€åŒºå·ç­‰ç­‰ï¼Œéƒ½å¯ä»¥é€šè¿‡Typeè¿›è¡Œæ‹“å±•ï¼Œè¿™é‡Œæˆ‘ä»¬ç®€å•åªè€ƒè™‘å·ç çš„ç±»å‹ã€‚é‚£æ˜¾ç„¶å¯ä»¥ç¼–ç ä¸º0x00, ç¼–ç çš„ç±»å‹é€šè¿‡ä¹Ÿç§°ä¸ºTagã€‚\nLengthå°±æ¯”è¾ƒç®€å•ï¼Œé€šå¸¸æ ‡è¯†å­—èŠ‚æ•°ï¼Œè€Œæ‰‹æœºå·ç é€šå¸¸æ˜¯ä½¿ç”¨ASCIIç æ¥æ ‡è¯†ï¼Œåˆ™æ¯ä¸€ä¸ªæ‰‹æœºå·ç æ•°å­—è¢«ç¼–ç ä¸ºä¸€ä¸ªå­—èŠ‚ï¼Œæ€»è®¡å°±æ˜¯11ï¼Œé•¿åº¦è¢«ç¼–ç ä¸º0x0B.\næœ€åValueå°±æ˜¯æ•°æ®ä¸»ä½“ï¼Œä½¿ç”¨ASCIIç¼–ç åˆ™ä¸ºï¼š0x31 0x38 0x35 0x37 0x30 0x39 0x31 0x37 0x36 0x31 0x32\næœ€ç»ˆè¿™ä¸ªæ‰‹æœºå·ç å°†è¢«ç¼–ç ä¸º(å»æ‰0xï¼Œç›´æ¥çœ‹çœŸå®çš„äºŒè¿›åˆ¶ä¸‹è¡¨ç¤º)ï¼š\n   Tag Length Value     00 0B 31 38 35 37 30 39 31 37 36 31 32    å½“ç„¶ï¼ŒTLVæ˜¯æ”¯æŒåµŒå¥—çš„ï¼Œå³ValueåŒæ ·æ˜¯ä¸€ä¸ªTLVç¼–ç çš„æ•°æ®ã€‚åé¢ä¹Ÿå°†ä¼šçœ‹åˆ°ã€‚\nX.690 æ—¢ç„¶ASN.1æ˜¯ä¸€ä¸ªé€šç”¨çš„ï¼Œå’Œé€šä¿¡ä¸å¯†ç å¼ºç›¸å…³çš„ç¼–ç è®°æ³•ï¼Œå½“ç„¶æ˜¯éœ€è¦ä¸€ä¸ªæ˜ç¡®çš„æ ‡å‡†ã€‚è€ŒX.690æ˜¯å½“å‰æ¯”è¾ƒå…¬è®¤çš„æ ‡å‡†ã€‚ä¸»è¦ä¹Ÿæ˜¯å®šä¹‰äº†BER/CER/DERè¿™ä¸‰ç§ç¼–ç æ ¼å¼ã€‚ä¸‹æ–‡çš„è§£æä¹Ÿæ˜¯éµå¾ªè¯¥æ ‡å‡†çš„(08/2015)ç‰ˆæœ¬ ã€‚\nBER ä½œä¸ºåŸºç¡€ç¼–ç è§„åˆ™ï¼Œæˆ‘ä»¬é¦–å…ˆå­¦ä¹ å®ƒã€‚BERé€šå¸¸æŠŠä¸€ä¸ªå­—èŠ‚å«åšOctetsï¼Œè€Œä»ä½åˆ°é«˜çš„æ¯”ç‰¹ä½åˆ†åˆ«è¢«å«åšbit1 - bit8ï¼Œå’Œé€šå¸¸è®¡ç®—æœºå¯¹äºæœ€ä½æ¯”ç‰¹ç§°ä½œbit0ç•¥æœ‰ä¸åŒã€‚\nå…ˆè´´ä¸€ä¸‹ä¹‹å‰çš„X.509è¯ä¹¦, ç”¨äºåæ–‡å®ä¾‹è§£æä¸­çš„å¯¹æ¯”:\nCertificate: Data: Version: 3 (0x2) Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f Signature Algorithm: sha256WithRSAEncryption Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT Subject: C = US, ST = California, L = Mountain View, O = Google LLC, CN = www.google.com Subject Public Key Info: Public Key Algorithm: id-ecPublicKey Public-Key: (256 bit) pub: 04:bc:1c:aa:96:6f:6f:99:48:79:56:61:4b:7f:ff: dc:39:08:3a:d4:4d:e2:d8:87:80:af:3d:18:5e:71: 2d:ce:09:70:57:39:38:5f:2a:ee:a8:35:f4:3a:86: 86:5a:1d:c7:31:32:1b:8d:ac:d0:46:ad:c3:fc:a5: d3:18:36:68:ab ASN1 OID: prime256v1 NIST CURVE: P-256 X509v3 extensions: X509v3 Key Usage: critical Digital Signature X509v3 Extended Key Usage: TLS Web Server Authentication X509v3 Basic Constraints: critical CA:FALSE X509v3 Subject Key Identifier: AF:32:A8:9D:20:98:F3:FD:14:41:FE:F4:C4:74:47:7C:D1:6C:81:B1 X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B Authority Information Access: OCSP - URI:http://ocsp.pki.goog/gts1o1core CA Issuers - URI:http://pki.goog/gsr2/GTS1O1.crt X509v3 Subject Alternative Name: DNS:www.google.com X509v3 Certificate Policies: Policy: 2.23.140.1.2.2 Policy: 1.3.6.1.4.1.11129.2.5.3 X509v3 CRL Distribution Points: Full Name: URI:http://crl.pki.goog/GTS1O1core.crl CT Precertificate SCTs: Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 5E:A7:73:F9:DF:56:C0:E7:B5:36:48:7D:D0:49:E0:32: 7A:91:9A:0C:84:A1:12:12:84:18:75:96:81:71:45:58 Timestamp : Aug 26 09:14:24.417 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:20:77:F3:D6:8B:51:4F:88:71:16:73:ED:36: 2F:64:F4:77:3E:92:D3:CE:97:1F:1C:53:FA:4E:FB:5B: D7:0A:4C:D6:02:21:00:9F:B9:FE:F1:F3:1C:0D:CF:20: 30:B1:1C:0A:01:65:AD:67:90:1F:B5:33:90:8D:49:4D: 2B:ED:1D:90:28:A1:6B Signed Certificate Timestamp: Version : v1 (0x0) Log ID : 07:B7:5C:1B:E5:7D:68:FF:F1:B0:C6:1D:23:15:C7:BA: E6:57:7C:57:94:B7:6A:EE:BC:61:3A:1A:69:D3:A2:1C Timestamp : Aug 26 09:14:24.367 2020 GMT Extensions: none Signature : ecdsa-with-SHA256 30:45:02:21:00:F4:67:8E:8B:ED:3F:B2:D4:EA:72:EB: 53:F1:52:57:98:D6:63:0E:C0:6B:68:46:CE:F3:AD:25: 52:AD:12:83:27:02:20:05:CA:04:76:D6:4F:2A:E5:D3: 96:85:79:A2:F3:85:29:9E:89:30:00:A7:20:99:2D:F7: C9:56:3C:4E:5D:5C:CF Signature Algorithm: sha256WithRSAEncryption 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: 32:99:29:f8:13:6b:72:af:16:79:63:d3:3f:76:56:57:19:78: 91:86:f8:7a:ee:26:67:98:dc:5e:e4:00:f5:87:a0:01:21:9d: cf:e5:9f:02:f3:2a:fd:0e:fd:78:af:2e:20:29:77:35:e2:c6: 30:ee:ef:be:f2:bb:26:02:52:a2:2d:27:78:ce:a9:8e:39:d0: a2:74:90:11:c5:92:58:3c:7a:88:1d:c7:5a:56:d4:1a:01:00: c3:9d:98:6f:41:02:1f:cb:e2:4d:99:6a:5c:d9:0f:c0:88:08: 15:c5:26:90:a2:a4:15:f6:71:e2:fe:a9:98:dc:40:2a:71:c1: 11:aa:00:73:52:24:74:aa:ae:72:55:2f:0d:31:b7:00:bb:1f: 87:4d:f5:05:ad:ff:7a:93:e0:cf:86:a5:1d:1b:7d:41:fa:10: 99:3b:00:7c:c9:dd:a9:52:5c:06:72:86:96:e7:05:97:77:12: 2f:26:bb:dc:65:c4:48:4d:9c:82:4b:7d:69:27:3f:85:00:2e: b1:5d:8d:dc  Identifier Octets æ ‡è¯†å­—èŠ‚ï¼Œå¯ä»¥ç†è§£ä¸ºTLVä¸­çš„Typeã€‚BERä¸­å°†å…¶åˆ†è§£æˆä¸‰æ®µå¦‚ä¸‹ï¼š\n1 2 3 4  * Bit 8 7 6 5 1 * +-------+-----+------------+ * | Class | P/C | Tag number | * +-------+-----+------------+   å…ˆçœ‹Classæ®µï¼Œä¸¤ä¸ªæ¯”ç‰¹bit7-bit8ï¼Œå®šä¹‰äº†å››ç§ç±»å‹ï¼š\n   Class Bit 8 Bit 7     Universal (0x00) 0 0   Application (0x40) 0 1   Context-specific (0x80) 1 0   Private (0xC0) 1 1    å…¶ä¸­Universalæ˜¯æœ€å¸¸ç”¨çš„ï¼Œå±äºNativeçš„ç±»å‹éƒ½å°†å±äºè¯¥æ®µã€‚è€ŒContext-specificä¹Ÿæ¯”è¾ƒå¤šè§ï¼Œå¯†ç å­¦ç›¸å…³ç¼–ç è¾ƒå¤šã€‚é€šå¸¸å½“å­—æ®µçš„ç±»å‹éæ ‡å‡†ç±»å‹æ—¶éƒ½å°†ä½¿ç”¨è¯¥ç±»å‹ä½œä¸ºIdentifier Octetsçš„é«˜ä½ã€‚ä»¥X.509è¯ä¹¦ä¸­æ ‡å‡†ASN.1ç‰ˆæœ¬å·ä¸ºä¾‹ï¼ŒTypeè¢«æè¿°ä¸ºA0ï¼š\n1 2 3 4  Version ::= INTEGER { v1(0), v2(1), v3(2) } version [0] EXPLICIT Version DEFAULT v1, /* Tag is \u0026#39;A0\u0026#39;: 0x80 | 0x20 | 0 */   æ­¤æ—¶A0çš„é«˜ä½æ¯”ç‰¹å³ä¸º1å’Œ0ï¼Œå¯¹åº”Context-specificã€‚Context-specificå®ƒåªèƒ½ä½¿ç”¨åœ¨SEQUENCEã€SETå’ŒCHOICEç±»å‹çš„ç»„ä»¶ä¸­ï¼Œè€Œä¸”å¯ä»¥çœ‹åˆ°æœ‰ä¸€ä¸ªå…³é”®å­—EXPLICITä»¥åŠå¯¹åº”çš„å…³é”®å­—IMPLICITç”¨äºé…åˆä½¿ç”¨ã€‚è€Œä¸­æ‹¬å·ä¸­é—´çš„0åˆ™æ ‡è¯†äº†å¯¹åº”çš„Tag number, æ³¨æ„è¯¥æ•°å­—ä»…åœ¨è¯¥ä¸Šä¸‹æ–‡ä¸­(å³å•ç‹¬SEQUENCEã€SETå’ŒCHOICEç»„æˆçš„å†…éƒ¨)ç”Ÿæ•ˆã€‚\nå…¶ä»–ä¸¤ç§ä½¿ç”¨å¾ˆå°‘ï¼Œä¹Ÿä¸æ¨èä½¿ç”¨ï¼Œå¤šç”¨äºæŸäº›åº”ç”¨å’Œå…¬å¸å†…éƒ¨çš„ç§æœ‰åè®®ï¼Œæ­¤å¤„ä¸è®¨è®ºäº†ã€‚\nå†çœ‹çœ‹P/C, å¯¹åº”1ä¸ªæ¯”ç‰¹ï¼š0 = Primitive(0x00); 1 = Constructed(0x20)ã€‚é€šå¸¸è¯¥ä½æ ‡è¯†åç»­çš„Valueæ˜¯ä¸€ä¸ªåŸå­å€¼è¿˜æ˜¯ä¸€ä¸ªåµŒå¥—çš„TLV. ä¾‹å¦‚INTEGERåªèƒ½ä¸ºPrimitiveï¼Œè€ŒSEQUENCE ä¸€å®šæ˜¯Constructedï¼›å½“ç„¶ä¹Ÿæœ‰Bothå…è®¸çš„ç±»å‹ï¼Œå¦‚BIT STRINGï¼Œå¯èƒ½æ˜¯åµŒå¥—çš„ä¹Ÿå¯èƒ½æ˜¯åŸå­çš„ï¼Œä¸è¿‡æ˜¾ç„¶åµŒå¥—çš„æƒ…å†µæ¯”è¾ƒå°‘ï¼ŒX.509è¯ä¹¦æš‚æ—¶æ²¡æ‰¾åˆ°ç›¸å…³ä¾‹å­ã€‚\næœ€åæ˜¯æœ€å…³é”®çš„Tag Numberï¼Œä½¿ç”¨äº†5ä¸ªæ¯”ç‰¹(bit1 - bit5)æ ‡è¯†äº†æœ€åŸºæœ¬çš„åŸç”Ÿç±»å‹ï¼Œä¸‹è¡¨å°†è§£é‡Šå¸¸ç”¨çš„ç±»å‹ï¼š\n   Name Permitted Construction Decimal Tag number Hexadecimal Tag number     End-of-Content (EOC) Primitive 0 0   BOOLEAN Primitive 1 1   INTEGER Primitive 2 2   BIT STRING Both 3 3   OCTET STRING Both 4 4   NULL Primitive 5 5   OBJECT IDENTIFIER Primitive 6 6   UTF8String Both 12 C   SEQUENCE and SEQUENCE OF Constructed 16 10   SET and SET OF Constructed 17 11   PrintableString Both 19 13   T61String Both 20 14   IA5String Both 22 16   UTCTime Both 23 17   GeneralizedTime Both 24 18   UniversalString Both 28 1C   BMPString Both 30 1E    å…·ä½“çš„åœ¨X.509æ‰€éœ€çš„ç¼–ç å­—æ®µå°†åœ¨å®ä¾‹ä¸­è¿›è¡Œè®²è§£ã€‚éœ€è¦ç‰¹åˆ«æåˆ°çš„EOCé€šå¸¸ç”¨åœ¨TLVä¸²ç»“å°¾æ ‡è¯†æ•°æ®å·²ç»“æŸï¼Œå±äºä¸€ç§å¯é€‰ç¼–ç æ–¹å¼ï¼ŒX.509ä¸­æœªä½¿ç”¨ã€‚\nä¸€ä¸ªé—®é¢˜åœ¨äºï¼Œæ­¤æ—¶Tag Numberæ˜¯æ— æ³•è¶…è¿‡0x0Fçš„ï¼Œè€Œæ ¹æ®X.690æ ‡å‡†å®é™…ä¸Šæ˜¯æœ‰è¶…è¿‡0x0Fç§Tagçš„ï¼Œæ­¤æ—¶è¯¥å¦‚ä½•ç¼–ç å‘¢ï¼ŸASN.1ä½¿ç”¨0b11111ä½œä¸ºTag Numberè¿›è¡Œæ‹“å±•ï¼Œæ­¤æ—¶æ¥ä¸‹æ¥çš„å­—èŠ‚ä¸ºçœŸå®çš„Tag Numberï¼Œå…¶ä¸­å½“æœ€é«˜ä½æ¯”ç‰¹bit8ä¸ºæ ‡è¯†ä½ï¼Œ0æ ‡è¯†ä¸ºæœ€åä¸€ä¸ªå­—èŠ‚ï¼Œ1æ ‡è¯†ä¸ºä¸­é—´å­—èŠ‚ï¼Œæœ€åè¿›è¡Œæ¯”ç‰¹ä¸²çš„æ‹¼æ¥ï¼Œå¤§ç«¯ç¼–ç ã€‚ç±»ä¼¼ä¸‹é¢çš„æ ‡è¯†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  * Leading Octet Bit 8 7 6 5 1 * +-------+-----+---------+ * | Class | P/C | 0b11111 | * +-------+-----+---------+ * 2nd Octet Bit 8 7 1 * +---+------------+ * | 1 | 0bxxxxxxx | * +---+-----+------+ ... * Last Octet Bit 8 7 1 * +---+------------+ * | 0 | 0bxxxxxxx | * +---+-----+------+ * Example for tag number 0x80: 0b10000000 * binary : [class:P/C:11111][1:0000001][0:0000000] for 3-byte   ä¸è¿‡è¿™ç§æƒ…å†µæ¯”è¾ƒå°‘è§ï¼Œåœ¨å¯†ç å­¦æ ‡å‡†ä¸­åŸºæœ¬ä¸ä¼šå‡ºç°ã€‚\nLength octets æ ‡è¯†äº†ç¼–ç å†…å®¹çš„é•¿åº¦ï¼Œå±äºæ¯”è¾ƒç®€å•çš„å­—æ®µã€‚ä¸Tag Numberç¼–ç æ–¹å¼ç±»ä¼¼ï¼Œä¹Ÿè¢«åŒºåˆ†ä¸ºäº†çŸ­æ¨¡å¼ä¸é•¿æ¨¡å¼ï¼š\nçŸ­æ¨¡å¼ä¸‹ï¼Œbit8å°†ä¸º0ï¼Œå‰©ä¸‹çš„æ¯”ç‰¹å°†ä½œä¸ºå®é™…æ•°æ®é•¿åº¦ã€‚ä¾‹å¦‚ä¸Šé¢çš„æ‰‹æœºå·ç é•¿åº¦11ï¼Œå°†è¢«ç¼–ç ä¸º0b00001011ã€‚æ˜¾ç„¶è¿™ç§æƒ…å†µä¸‹é•¿åº¦æ˜¯æœ‰é™çš„ï¼šä¸èƒ½è¶…è¿‡127(0b01111111)ä¸ªbyte.\nè¶…è¿‡127ä¹‹åå°†ä½¿ç”¨é•¿æ¨¡å¼ï¼šç¬¬ä¸€ä¸ªå­—èŠ‚çš„æœ€é«˜æ¯”ç‰¹bit8ç½®1ï¼Œå‰©ä¸‹çš„æ¯”ç‰¹å°†æŒ‡ç¤ºè¯¥é•¿åº¦å°†ç”±å¤šå°‘ä¸ªå­—èŠ‚æ¥è¡¨ç¤ºï¼ŒåŒæ ·çš„å°†é€šè¿‡å¤§ç«¯ç¼–ç çš„æ–¹å¼å½¢æˆä¸€ä¸²æ¯”ç‰¹ä¸²è¿›è¡Œç¼–ç ã€‚ä»¥ä¸Šä¸€ç¯‡X.509çš„è¯ä¹¦ç­¾åæ®µä¸ºä¾‹ï¼š\n/* * Type 0x03 : Bit String * Length: * 1st Octet: 0b10000002(0x82): bit-8 = 1 stands for long form; * bit1-7 = 0x2 encode the number of subsequent octets in the length octets, bit-7 is the most significant bit; Note: 0xFF can\u0026#39;t be used. * 2nd and 3rd Octet: bit 8 of the first subsequent octet is the most significant bit; * 0b00000001|00000001(0x01 0x01) for content length 0x101. */ signatureValue BIT STRING (Encoded as: [03] [82 01 01] [Signature]) è¿™é‡Œæœ‰ä¸ªç–‘é—®ï¼šä¸ºå•¥RSA-2048ä¸ºå•¥å‡ºæ¥éœ€è¦0x101ä¸ªå­—èŠ‚ï¼Œå¤šäº†ä¸€ä¸ªå­—èŠ‚å•Šã€‚å…¶å®çœ‹ä¸€ä¸‹å°±çŸ¥é“ï¼Œç¼–ç çš„æœ€é«˜å­—èŠ‚ä¸º0x00ã€‚è‡³äºè¿™ä¸ªçš„ç”¨æ³•å¦‚ä½•å°†åœ¨åç»­å¯¹ä¸åŒTypeçš„å†…å®¹åšç¼–ç æ—¶è®²åˆ°ã€‚\næ­¤å¤–ASN.1æä¾›äº†å¦å¤–ä¸€ç§çµæ´»çš„ç¼–ç æ–¹å¼ï¼šå³å½“Lengthè¢«ç¼–ç ä¸º0b10000000(0x80)æ—¶ï¼Œé•¿åº¦è¢«å®šä¹‰ä¸ºä¸å®šæ¨¡å¼(Indefinite)ï¼Œåç»­Contents octetsçš„å°¾éƒ¨åˆ™å¿…é¡»åŠ ä¸Šä¸ŠèŠ‚æåˆ°çš„EOCï¼Œæ ‡è¯†å†…å®¹ç»“æŸã€‚\nContents octets ç¼–ç å†…å®¹ï¼Œè¿™ä¸ªéƒ¨åˆ†å°†å¯¹X.509ç³»åˆ—æ‰€éœ€å¸¸ç”¨çš„ç±»å‹ç¼–ç æ–¹å¼è¿›è¡Œè¯¦è¿°\nEOC EOCæ¨¡å¼ä¸€å®šä¸ºä»¥ä¸‹æ ¼å¼:\n   Identifier Length Contents     0x00 0x00 NULL    Boolean å¸ƒå°”ç±»å‹éå¸¸ç®€å•ï¼ŒTypeçš„Classä¸ºUniversal ï¼ŒéåµŒå¥—ï¼ŒTag numberä¸º0x1, Lengthä¸º0x1ã€‚å½“Valueå­—èŠ‚ä¸ºå…¨0æ—¶è®°ä¸ºfalse, å¦åˆ™ä¸ºtrueï¼›ä¸‹è¡¨è¡¨ç¤ºä¸€ç§å¸ƒå°”ç±»å‹çš„ç¼–ç ï¼Œå…±3å­—èŠ‚ã€‚\n   Identifier Length Contents     0x01 0x01 0xFF    X.509ä¸­æœ‰ä¸€ä¸ªæ ‡å‡†çš„æ‹“å±•å­—æ®µç”¨äº†è¯¥å¸ƒå°”ç±»å‹ï¼š\n/* X509v3 Basic Constraints: critical CA:FALSE */ /* encode: */ [01] [01] [FF] Integer Typeçš„Classä¸ºUniversal ï¼ŒéåµŒå¥—ï¼ŒTag numberä¸º0x02, Lengthä¸ºç¼–ç çš„å­—èŠ‚é•¿åº¦ï¼Œcontentä¸ºå¤§æ•°ç¼–ç çš„æ•´æ•°ï¼Œå³ç¬¬ä¸€ä¸ªå­—èŠ‚çš„æœ€é«˜æ¯”ç‰¹ä¸ºMSBï¼Œç›´æ¥ä»¥ä¸Šä¸€ç« è¯ä¹¦ä¸­é—´çš„serialNumber, å¾ˆç®€å•ï¼Œæ ‡è¯†äº†ä¸€ä¸ªå¤§æ•°88æ¯”ç‰¹ã€11å­—èŠ‚çš„å¤§æ•°ï¼š\n1 2 3 4 5 6  CertificateSerialNumber ::= INTEGER serialNumber CertificateSerialNumber /* Serial Number: bc:01:41:05:22:d8:cc:7f:02:00:00:00:00:79:64:7f */ [02] [11] [00 BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F]   å…¶ä¸­æ•°å­—çš„æ¯”è¾ƒä¸æ™®é€šæ•°å­—æ¯”è¾ƒæ²¡æœ‰å·®åˆ«ï¼Œå¦‚ä¸Šè¿°æ•°å­—ä¸[02] [10] [BC 01 41 05 22 D8 CC 7F 02 00 00 00 00 79 64 7F]æ¯”è¾ƒæ˜¯ç›¸ç­‰çš„ã€‚\nBitstring Typeçš„Classä¸ºUniversalï¼Œå¯ä»¥ä¸ºprimitiveä¹Ÿå¯ä»¥ä¸ºconstructed. Tag numberä¸º0x3. Lengthä¸ºç¼–ç çš„å­—èŠ‚é•¿åº¦ï¼›å…¶contentçš„ç»„æˆï¼Œç¬¬ä¸€ä¸ªå­—èŠ‚å°†ç¼–ç äº†æœ€åä¸€ä¸ªå­—èŠ‚ä¸­å¡«å……çš„0bitçš„ä¸ªæ•°, æ•…è§£ç æ—¶ä¹Ÿåº”è¯¥å»é™¤æ‰æœ€åä¸€ä¸ªè‡ªå·±çš„å¯¹åº”æ¯”ç‰¹æ•°çš„0ï¼Œè¯¥å­—èŠ‚è¢«ç§°ä¸ºUnused bitsï¼›é€šå¸¸å¯ä»¥ä½¿ç”¨å¤šä¸ªprimitiveçš„Bitstringåˆ†æ®µï¼Œç»„æˆä¸€ä¸ªconstructedçš„Bitstring, æ­¤æ—¶Lengthå¯ä»¥è®¾ç½®ä¸ºä¸å®šé•¿æ¨¡å¼0x80. é€šå¸¸ä¸éœ€è¦ä½¿ç”¨constructæ¨¡å¼ã€‚çœ‹ä¸‹é¢çš„ä¾‹å­ï¼š\n/* If of type BIT STRING, the value \u0026#39;0A3B5F291CD\u0026#39;H */ /* Primitive mode encode: 04 stands for the last byte include 4 bit padding */ [03] [07] [[04] 0A 3B 5F 29 1C D0] /* * Constructed mode encode: 23 stands for 0x00(class) | 0x20(constructed) | 0x03(Tag number) * The Bitstring consists of 2 sub-bitstrings: 0A3B, first byte 00 stands for 0 padding bits; * And 5F291CD0, first byte 04 last byte include 4 bit padding. */ [23] [0C] [[[03] [03] [[00] 0A 3B]] [[03] [05] [[04] 5F 29 1C D0]]] è§£é‡Šä¸€ä¸‹X.509é‡Œç­¾åæ®µçš„ç¼–ç ï¼š\nsignatureValue BIT STRING /* * Signature Algorithm: sha256WithRSAEncryption * 7a:9a:76:80:c9:39:13:8e:60:b1:93:5d:99:49:1b:71:b5:b2: * 2e:bd:4b:db:56:f0:eb:fa:f4:ae:93:f6:1b:dd:b0:df:2a:81: * 08:fc:4a:a9:ec:b1:ae:09:f0:fa:40:7b:b8:be:dc:08:4c:46: * ... */ /* The first byte 00 stands for 0 padding bits */ Encoded as: [03] [82 01 01] [[00] 7A 9A 76 80 C9 39 13 8E 60 B1 93 5D ...] Octetstring ä¸BitstringåŸºæœ¬ç±»ä¼¼ï¼Œå·®åˆ«åœ¨äºTag numberä¸º0x3ï¼Œä¸”å› ä¸ºæœ€å°ä»¥å­—èŠ‚ä¸ºå•ä½ï¼Œæ— éœ€ç¬¬ä¸€ä¸ªå­—èŠ‚æ ‡è¯†å¡«å……ä¿¡æ¯ã€‚é€šå¸¸åœ¨X.509ä½¿ç”¨åœ¨Extensionä¸­ï¼Œæ ‡å‡†ä¸‹ASN.1çš„extnValueæ ¼å¼ä¸ºOctetstringï¼ŒåŒæ—¶ç”±äºæ­¤ç±»å‹æ”¯æŒå…¶ä»–ç±»å‹çš„åµŒå¥—ï¼Œä»¥ä¹‹å‰è¯ä¹¦authorityKeyIdentifierçš„extnValueä¸ºä¾‹ï¼š\n1 2 3 4 5 6 7 8  Extension ::= SEQUENCE { extnID OBJECT IDENTIFIER, critical BOOLEAN DEFAULT FALSE, extnValue OCTET STRING } /* X509v3 Authority Key Identifier: keyid:98:D1:F8:6E:10:EB:CF:9B:EC:60:9F:18:90:1B:A0:EB:7D:09:FD:2B */ [04] [18] [30 16 80 14 98 D1 F8 6E 10 EB CF 9B EC 60 9F 18 90 1B A0 EB 7D 09 FD 2B]   NULL Typeçš„Classä¸ºUniversalï¼Œprimitive. Tag numberä¸º0x5ï¼ŒLengthä¸€å®šä¸º0. ä¸éœ€è¦Contentï¼Œå³é€šå¸¸ç¼–ç å›ºå®šä¸º05 00; X.509ä¸­åœ¨AlgorithmIdentifierä¼šå‡ºç°ï¼Œå¦‚æœ¬æ–‡çš„ä¾‹å­ä¸­ï¼š\n1 2 3 4 5 6  AlgorithmIdentifier ::= SEQUENCE { algorithm OBJECT IDENTIFIER, parameters ANY DEFINED BY algorithm OPTIONAL } /* parameters == NULL encoded in {} */ [30] [0D] [[[06] [09] [2A 86 48 86 F7 0D 01 01 0B]] {[05] [00]}]   Sequence/Sequence of è®¸å¤šä½¿ç”¨ASN.1å®šä¹‰çš„åè®®éƒ½æ˜¯åŸºäºè¯¥ç±»å‹å®šä¹‰çš„. Typeçš„Classä¸ºUniversal, Constructed, Tag numberä¸º0x10. æ•…Identifieré€šå¸¸ä¸º0x30ã€‚é€šè¿‡ä¸Šä¸€èŠ‚å°±èƒ½çœ‹åˆ°ï¼Œå…¶å®æ•´å¼ X.509è¯ä¹¦å°±æ˜¯ä¸€ä¸ªsequenceï¼Œå®ƒç”± Version, CertificateSerialNumber, AlgorithmIdentifierç­‰å¤šä¸ªç±»å‹çš„å­—æ®µç»„åˆè€Œæˆã€‚ä¾‹å­å¯ä»¥å‚è€ƒä¸Šé¢çš„AlgorithmIdentifierï¼›åŒæ—¶å¯ä»¥çœ‹ä¸€ä¸‹æ•´å¼ è¯ä¹¦çš„ä¾‹å­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13  Certificate ::= SEQUENCE { tbsCertificate TBSCertificate, signatureAlgorithm AlgorithmIdentifier, signatureValue BIT STRING } /* Cert: length = 0x4C8 */ /* * TBSCertificate and signatureAlgorithm are also SEQUENCEs with length 0x3B0 and 0x0D * signatureValue is BIT STRING with length 0x101, bits padding number is 0 */ [30] [82 04 C8] [[[30] [82 03 B0] [A0 03 02 01 02 02 11 00 ...]] [[30] [0D] [30 0D 06 09 2A 86 48 86 ...]] [[03] [82 01 01] [[00] 7A 9A 76 80 C9 39 13 8E 60 B1 93 5D 99 49 1B 71 ...]]]   æ³¨æ„ï¼šè¯ä¹¦ä¸­è¢«ç­¾åçš„å­—æ®µéœ€è¦å¿½ç•¥æ‰Certificateç¼–ç ä¸­çš„Identifierå’ŒLengthï¼Œæœ¬ä¾‹ä¸­è¢«ç­¾åæ®µå°†å¿½ç•¥æ‰å‰ä¸¤ä¸ªä¸­æ‹¬å·çš„å†…å®¹, å³ç¬¬ä¸‰ä¸ªä¸­æ‹¬å·ä¸­çš„ç¬¬ä¸€ä¸ªä¸­æ‹¬å·[[30] [82 03 B0] [A0 03 02 01 02 02 11 00 ...] ä¸ºè¢«ç­¾åæ®µ.\nSet/Set of Typeçš„Classä¸ºUniversal, Constructed, Tag numberä¸º0x11. æ•…Identifieré€šå¸¸ä¸º0x31ã€‚ä¸SequenceåŸºæœ¬ä¸€è‡´ï¼ŒåŒºåˆ«åœ¨äºæ­¤ç±»å‹åœ¨å®šä¹‰ã€è§£æå’Œç¼–ç æ—¶æ— éœ€å¼ºåˆ¶é¡ºåºï¼Œæ²¡æœ‰å‰åé¡ºåºï¼Œå„æˆå‘˜ä½“ç­‰ä»·ã€‚åœ¨X.509ä¸­Nameç±»å‹åŒ…å«setç±»å‹.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  Name ::= CHOICE { -- only one possibility for now -- rdnSequence RDNSequence } RDNSequence ::= SEQUENCE OF RelativeDistinguishedName RelativeDistinguishedName ::= SET SIZE (1..MAX) OF AttributeTypeAndValue AttributeTypeAndValue ::= SEQUENCE { type AttributeType, value AttributeValue } AttributeType ::= OBJECT IDENTIFIER AttributeValue ::= ANY -- DEFINED BY AttributeType /* The encoding of a choice value shall be the same as the encoding of a value of the chosen type. */ /* * Issuer: C = US, O = Google Trust Services, CN = GTS CA 1O1 * Sequence { *\tSet { *\tSequence { *\ttype OBJECT IDENTIFIER, value AttributeValue *\t}, *\tSequence { *\ttype OBJECT IDENTIFIER, value AttributeValue *\t}, ... }, *\tSet { ... } * } */ /* Sequence 30 { set 31 { Sequence 30 {OID 06, Printable String 13 }} ... } */ [30] [42] [[[31] [0B] [[30] [09] [[[06] [03] [55 04 06]] [[13] [02] [55 53]]]]] ... ]   UTCTime Typeçš„Classä¸ºUniversal, Primitiveå’ŒConstructedéƒ½å¯èƒ½, é€šå¸¸ä¸ºPrimitiveï¼ŒTag numberä¸º0x17ã€‚å…¶ç¼–ç ä¸ºasciiç ä¸‹çš„YYMMDDhhmm[ss]Zæˆ–YYMMDDhhmm[ss](+|-)hhmmã€‚\nYYè¡¨ç¤ºå¹´ï¼Œå…¶ä¸­å¦‚æœYY \u0026lt; 50åˆ™å¹´ä»½ä¸º20YYå¹´ï¼Œå¦åˆ™ä¸º19YYå¹´ï¼Œå¦‚YY = 50åˆ™æ ‡è¯†1950å¹´ï¼›MMè¡¨ç¤ºæœˆä»½ï¼ŒDDè¡¨ç¤ºæ—¥ï¼›hhmmssè¡¨ç¤ºæ—¶åˆ†ç§’ï¼Œå…¶ä¸­ssæ˜¯å¯é€‰é¡¹ã€‚\nZåˆ™æ ‡è¯†Zuluæ—¶é—´ï¼Œè€Œ(+|-)hhmmåˆ™æ ‡è¯†äº†ä¸æ ¼æ—å¨æ²»æ ‡å‡†æ—¶é—´çš„æ—¶å·®, +æ ‡è¯†æ ‡å‡†æ—¶é—´æå‰ï¼Œ-æ ‡è¯†æ¨åã€‚Zä¸æ—¶å·®ä¸èƒ½å…±ç”¨ã€‚\nçœ‹çœ‹X.509ä¸­çš„ä¾‹å­ï¼š\n/* Validity Not Before: Aug 26 08:14:23 2020 GMT Not After : Nov 18 08:14:23 2020 GMT */ /* ascii code, print as 200826081423Z */ [17] [0D] [32 30 30 38 32 36 30 38 31 34 32 33 5A] /* ascii code, print as 201118081423Z */ [17] [0D] [32 30 31 31 31 38 30 38 31 34 32 33 5A]  Restricted character string æ ‡è¯†ä¸€ç»„æ”¶åˆ°é™åˆ¶çš„stringç±»å‹ï¼Œå¦‚NumericString/VisibleString/PrintableStringç­‰. X.509æœ€ä¸»è¦ä½¿ç”¨çš„æ˜¯PrintableStringã€‚ä»¥Setä¾‹å­ä¸­çš„Nameé‡Œå¯æ‰“å°å­—ç¬¦USä¸ºä¾‹ï¼Œidentifier = 0x13ï¼š\n /* * PrintableString * length = 2 * \u0026#34;US\u0026#34; : 0x55 0x53 */ [13] [02] [55 53] Object identifier ç®€ç§°OIDï¼Œæ˜¯ä¸€ä¸ªç”¨æ¥ç¼–ç ç‰¹æ®Šæ„ä¹‰å­—æ®µçš„æ ‡å‡†å®šä¹‰IDï¼Œå±äºITU-Tå’ŒISO/IECå…±åŒå¼€å‘çš„ä¸€ç§å¹¿æ³›ä½¿ç”¨çš„æœºåˆ¶æ¥å‘½åä»»ä½•ç±»å‹çš„å¯¹è±¡ã€æ¦‚å¿µæˆ–äº‹ç‰©ï¼Œå…·æœ‰ä¸€ä¸ªå…¨å±€æ˜ç¡®çš„åç§°å’Œä¸€ä¸ªé•¿ç”Ÿå‘½å‘¨æœŸçš„åç§°ã€‚\nTypeçš„Classä¸ºUniversal, Primitive, Tag numberä¸º0x6.\nå…ˆçœ‹è¯¥OIDè§£ç çš„æ ¼å¼ï¼Œé€šå¸¸ä¸ºa.b.c.d....(è¢«ç§°ä¸º dot notation). å…¶ä¸­æ¯ä¸€ä¸ª.å°†åˆ†å‰²ä¸€ä¸ªç‰¹æ®Šæ„ä¹‰çš„å­—ç¬¦ã€‚\n aä¸­æ¯”è¾ƒå…¸å‹çš„æœ‰iso(1)å’Œjoint-iso-itu-t(2) bä¸­æ¯”è¾ƒå…¸å‹çš„æœ‰member-body(2); identified-organization(3); ds(5); country(16) cåœ¨X.509å…¸å‹æœ‰certificateExtension(29); attributeType(4) dåœ¨X.509å…¸å‹æœ‰countryName(6); organizationName(10)  å½“ç„¶è¿˜èƒ½å»¶ç»­ã€‚å…¶ä¸­æœ€å…¸å‹çš„OIDæ˜¯ç®—æ³•IDï¼Œä»¥ä¸Šé¢è¯ä¹¦ä¸ºä¾‹å­ï¼šsha256WithRSAEncryptionçš„OIDä¸º1.2.840.113549.1.1.11; å¯¹åº”{iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1) sha256WithRSAEncryption(11)}.\nå…·ä½“æŸ¥è¯¢OIDå«ä¹‰å¯ä»¥æŸ¥çœ‹ç½‘ç«™http://oid-info.comï¼Œå¯ä»¥æŸ¥åˆ°å¤§éƒ¨åˆ†ç¬¦åˆæ ‡å‡†å®šä¹‰ä¸‹çš„OIDçš„è¯¦ç»†æè¿°ï¼Œä»¥åŠæ¯ä¸ªOIDä¸‹çš„child OIDï¼Œéå¸¸æ–¹ä¾¿ã€‚å…·ä½“å®ç°X.509åŠŸèƒ½ç›¸å…³æ‰€éœ€çš„OIDå®šä¹‰å¯ä»¥åœ¨ä¸‹ä¸€éƒ¨åˆ†çš„libmbedtlsæºç åˆ†æä¸­çœ‹åˆ°oid.hä¸­çš„å®šä¹‰ã€‚\nå…¶contentç¼–ç æ–¹å¼éå¸¸ç‰¹æ®Šï¼š\n aå’Œbå°†ä½œä¸ºç¬¬ä¸€ä¸ªå­—èŠ‚è¿›è¡Œç¼–ç ï¼Œç¼–ç ç»“æœä¸ºï¼ša * 40 + bã€‚ä¸¾ä¸ªä¾‹å­2.5çš„ç¼–ç ç»“æœä¸º0x55 = 85 = 2 * 40 + 5ã€‚ å‰©ä¸‹çš„æ¯ä¸ªå­—èŠ‚çš„ç¼–ç ç›¸åŒï¼Œéå¸¸ç±»ä¼¼è¶…è¿‡30ä¹‹åçš„Tag numberçš„ç¼–ç æ–¹å¼ï¼šé¦–å…ˆè¢«åˆ†å‰²ä¸ºæœ€å°‘æ•°é‡çš„æ²¡æœ‰å¤´é›¶æ•°å­—çš„7ä½æ•°å­—. è¿™äº›æ•°å­—ä»¥big-endianæ ¼å¼è¿›è¡Œç»„ç»‡, å¹¶ä¸”ä¸€ä¸ªæ¥ä¸€ä¸ªåœ°ç»„åˆæˆå­—èŠ‚. ç¼–ç çš„æœ€åä¸€ä¸ªå­—èŠ‚jå°†ä¸º0,å…¶ä»–æ‰€æœ‰å­—èŠ‚çš„æœ€é«˜ä½(ä½8)éƒ½ä¸º1ã€‚ä¸¾ä¸ªä¾‹å­840 = 0b1101001000ï¼Œç¼–ç ä¸º0b0000110 | 0b1001000ï¼Œæœ€åè¡¥å……é«˜ä½æ ‡è®°ä½0b10000110 | 0b01001000, å³0x86 0x48  çœ‹X.509ä¸­å¯¹sha256WithRSAEncryptionçš„ç¼–ç ï¼š\n/* 1.2.840.113549.1.1.11 */ /* * 0x2A = 42 = 1 * 40 + 2: \u0026#34;1.2\u0026#34; * 840 : 0x86 0x48 * 113549 = 0b (0000110 | 1110111 | 0001101): 0b10000110 0b11110111 0b00001101 = 0x86 0xF7 0x0D * Remained is simple encode as short integer. */ [06] [09] [2A 86 48 86 F7 0D 01 01 0B]  å®ŒæˆåŸºç¡€ç±»å‹çš„å­¦ä¹ ï¼Œæˆ‘ä»¬è¿”å›å»çœ‹å¯¹äºX.509 Versionçš„ç¼–ç å°±å¥½ç†è§£äº†ï¼š\n1 2 3 4 5 6 7 8 9 10  version [0] EXPLICIT Version DEFAULT v1, Version ::= INTEGER { v1(0), v2(1), v3(2) } /* * EXPLICIT implies a context-specific(0x80) and construted by a integer; * [0] stands for the tag number; * so identifier: \u0026#39;A0\u0026#39;: 0x80 | 0x20 | 0 , length: 0x03, content: type integer; * Interger tag 0x02, length 0x01, content 0x02; */ [A0] [03] [[02] [01] [02]]   å®ŒæˆåŸºç¡€çš„BERç¼–ç è§„åˆ™çš„å­¦ä¹ ä¹‹åï¼ŒCERå’ŒDERå°±å¾ˆå¥½ç†è§£äº†ï¼Œä»–ä»¬å¯¹BERå¤šåŠ äº†ä¸€äº›å¯ç”¨æ€§çš„é™åˆ¶ã€‚å…ˆçœ‹ä¸¤è€…å…±æœ‰çš„ä¸X.509ç›¸å…³çš„é™åˆ¶ã€‚\nCommon Restrictions  Bool FALSEæ‰€æœ‰æ¯”ç‰¹åº”è¢«ç¼–ç 1ï¼Œå³è¯¥å­—èŠ‚ä¸º0xFF Bitstringä¸åº”è¯¥å‡ºç°éœ€è¦è¡¥å……æ¯”ç‰¹çš„æƒ…å†µï¼Œå³Unused bitsåº”è¯¥ä¸º0 Sequence/Setä¸­è¢«è®¾ç½®ä¸ºé»˜è®¤å€¼çš„æˆå‘˜ä¸åº”ç¼–ç  UTCTimeä»…æœ‰Zæ¨¡å¼  CER  identifierä¸ºConstrutedæ—¶ï¼Œé•¿åº¦åº”è¯¥æŒ‡å®šä¸ºindefinite(æ­¤å¤„æœ‰ç–‘é—®ï¼Œ.ceræ ¼å¼ä¸‹çš„è¯ä¹¦constructedä¹Ÿæœ‰ä½¿ç”¨definiteé•¿åº¦çš„) identifierä¸ºprimitiveæ—¶ï¼Œé•¿åº¦åº”è¯¥æŒ‡å®šä¸ºæœ€çŸ­å­—èŠ‚ï¼šä¾‹å¦‚é•¿åº¦0x10åœ¨BERä¸­å¯ä»¥ç¼–ç ä¸º0x81 0x10, CERå¢åŠ äº†è¯¥é™åˆ¶  DER  é•¿åº¦åªèƒ½ä½¿ç”¨definiteæ¨¡å¼ bitstring, octetstring å’Œ restricted character stringä¸èƒ½ä½¿ç”¨construted Setä¸­çš„ç»„æˆå€¼éœ€ä¸ASN.1å®šä¹‰çš„é¡ºåºä¸€è‡´  åŸºæœ¬ä¸Šçœ‹å®Œæ­¤æ–‡å°±å¯ä»¥åŒ–èº«äººè‚‰è§£ç å™¨äº†ï¼Œæœ€åæ¨èä¸€ä¸ªå·¥å…·ï¼šASN.1 Editor, å¾ˆå¥½ç”¨ã€‚\nå°†ç€é‡åˆ†æX.509çš„ç¼–ç è§£ç åœ¨libmbedtlsä¸­çš„æºç åˆ†æï¼Œç›¸å½“ç¡¬æ ¸ã€‚\n","description":"X.509è¯ä¹¦ç¼–ç ä»‹ç»","id":7,"section":"posts","tags":["OpenSSL"],"title":"X.509ç³»åˆ—ï¼ˆäºŒï¼‰ï¼šASN.1ç¼–è§£ç æ ‡å‡†X.690","uri":"https://summersummer3.github.io/posts/x509_2/"},{"content":"é—®é¢˜æ¥æº OpenSSL Engineæ˜¯å•¥ï¼Œåœ¨è¿™ä¸ªåœ°æ–¹å°±ä¸ç»†è¯´äº†ï¼Œèµ„æ–™å¾ˆå¤šï¼Œå¯ä»¥çœ‹çœ‹çŸ¥ä¹è¿™ç¯‡ä¸­æ–‡æ–‡æ¡£:\nhttps://zhuanlan.zhihu.com/p/70444766\nè‹±æ–‡æ–‡æ¡£:\nhttps://wiki.openssl.org/index.php/Creating_an_OpenSSL_Engine_to_use_indigenous_ECDH_ECDSA_and_HASH_Algorithms#Author\nç›´æ¥è¿›å…¥æ­£é¢˜ï¼Œæˆ‘ä»¬é¦–å…ˆæŸ¥çœ‹ä¸€ä¸ªOpenSSL Engineçš„ä¾‹å­ï¼š\nhttps://github.com/nibrunie/OSSL_EngineX\nç›´æ¥æŸ¥çœ‹bindä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static int bind(ENGINE* e, const char* id) { int ret = 0; if (!ENGINE_set_id(e, engine_id)) { fprintf(stderr, \u0026#34;ENGINE_set_id failed\\n\u0026#34;); goto end; } if (!ENGINE_set_name(e, engine_name)) { printf(\u0026#34;ENGINE_set_name failed\\n\u0026#34;); goto end; } if (!ENGINE_set_digests(e, digest_selector)) { printf(\u0026#34;ENGINE_set_digest failed\\n\u0026#34;); goto end; } ret = 1; end: return ret; } IMPLEMENT_DYNAMIC_BIND_FN(bind) IMPLEMENT_DYNAMIC_CHECK_FN()   å¯ä»¥çœ‹åˆ°OpenSSLå»åŠ è½½Engineçš„åŠ¨æ€åº“æ—¶ï¼Œéœ€è¦åŠ¨æ€åº“å»è°ƒç”¨ IMPLEMENT_DYNAMIC_BIND_FN å®Œæˆengineç»‘å®šåˆå§‹åŒ–ã€‚\nåŸºæœ¬ä¸Šæ‰€ä»¥æ•™ä½ å†™engineçš„æ•™ç¨‹åˆ°è¿™å°±ç»“æŸäº†ï¼Œä½†æ˜¯å†…éƒ¨åˆ°åº•æ˜¯æ€ä¹ˆè¦å…³è”ä¸Šè¿™ä¸ªå‡½æ•°ï¼Œå¹¶ä¸”è§¦å‘ä¸Šé¢çš„bindå‡½æ•°çš„å‘¢ï¼Ÿæˆ‘ä»¬å…ˆæ¥çœ‹çœ‹è¿™ä¸ªå®çš„å…·ä½“å®šä¹‰ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12  \\# define IMPLEMENT_DYNAMIC_BIND_FN(fn) \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns); \\ OPENSSL_EXPORT \\ int bind_engine(ENGINE *e, const char *id, const dynamic_fns *fns) { \\ if (ENGINE_get_static_state() == fns-\u0026gt;static_state) goto skip_cbs; \\ CRYPTO_set_mem_functions(fns-\u0026gt;mem_fns.malloc_fn, \\ fns-\u0026gt;mem_fns.realloc_fn, \\ fns-\u0026gt;mem_fns.free_fn); \\ skip_cbs: \\ if (!fn(e, id)) return 0; \\ /* è°ƒç”¨äº†ä¸Šé¢ä¾‹å­ä¸­çš„bindå‡½æ•° */ return 1; }   å¯ä»¥çœ‹åˆ°æ­¤å¤„å®šä¹‰äº†å‡½æ•°bind_engineï¼Œä»–ä¼šå»æ‰§è¡Œç”¨å®åŒ…è£¹ä½çš„å‡½æ•°ï¼Œä»¥å®Œæˆåˆå§‹åŒ–ã€‚ç„¶è€Œä½ å»æœç´¢è¿™ä¸ªå‡½æ•°åœ¨OpenSSLä¸­è°ƒç”¨ä½ ä¸€å®šä¼šå¾ˆå¤±æœ›ï¼Œè‚¯å®šæ²¡æœ‰ä½ æƒ³è¦çš„ç»“æœã€‚æœç„¶ä¸æ˜¯è¿™ä¹ˆç®€å•çš„ï¼Œåˆæ˜¯ä»€ä¹ˆé’©å­æŒ‚åœ¨äº†ä»€ä¹ˆctxä¸Šå§ï¼Œåº”è¯¥ä¹Ÿä¸éš¾ã€‚\næˆ‘æ‰¾äº†ä¸å°‘èµ„æ–™ï¼ŒåŸºæœ¬æ²¡å‘ç°å•¥é è°±çš„åˆ†æï¼Œæ²¡åŠæ³•è‡ªå·±çœ‹æºç å§ã€‚ç»“æœç»è¿‡åˆ†æï¼Œæˆ‘æ·±åˆ»çš„ç†è§£äº†OpenSSLçš„é­”é¬¼è°ƒç”¨ï¼Œé’©å­çš„æŒ‚è½½å¯ä»¥è¯´æ˜¯å¾ˆé­”å¹»ã€‚æ­¤å¤„æºç åˆ†æåŸºäºç›®å‰çš„ä¸»çº¿masterï¼Œåº”è¯¥ä¹Ÿæ˜¯æœªæ¥OpenSSL 3.0çš„æ¶æ„äº†ã€‚\nè‡³äºEngineæ˜¯æ€ä¹ˆè®¾ç½®ä¸Šé‡ç½®åçš„å¯†ç ç®—æ³•çš„ï¼Œå°†åœ¨åç»­æ›´æ–°ã€‚\nä»åŠ è½½Engineçš„mainå‡½æ•°åˆ†æèµ· è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬æŸ¥çœ‹æ‰§è¡ŒengineåŠ è½½çš„å¯æ‰§è¡Œç¨‹åºçš„æºç :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  int main(void) { // initializing OpenSSL library  OPENSSL_load_builtin_modules(); ENGINE_load_dynamic(); // building OpenSSL\u0026#39;s configuration file path  char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { fprintf(stderr, \u0026#34;OpenSSL failed to load required configuration\\n\u0026#34;); ERR_print_errors_fp(stderr); return 1; } ENGINE* eng = ENGINE_by_id(\u0026#34;engineX\u0026#34;); if(NULL == eng) { printf(\u0026#34;failed to retrieve engine by id (mppa)\\n\u0026#34;); return 1; } printf(\u0026#34;EngineX has been successfully loaded \\n\u0026#34;); ... }   å¯ä»¥çœ‹åˆ°æˆ‘ä»¬è¿™ä¸ªä¾‹å­æ˜¯ä»ä¸€ä¸ªcnfé…ç½®æ–‡ä»¶å»åŠ è½½å¯¹åº”çš„engineçš„ï¼Œè¿™é‡Œæä¸€å¥ï¼ŒåŠ è½½engineæœ‰å‡ ä¸ªæ–¹å¼ï¼Œå¦‚å‘½ä»¤è¡ŒåŠ è½½ï¼Œæ‰‹åŠ¨ä»£ç åŠ è½½ç­‰ã€‚è¿™é‡Œç”¨é…ç½®æ–‡ä»¶åŠ è½½åšä¾‹å­æ˜¯å› ä¸ºè¿™ä¸ªåœºæ™¯æ›´åŠ æ¥è¿‘å®é™…ä¸šåŠ¡åœºæ™¯ï¼Œè€Œä¸”æµç¨‹åŸºæœ¬æ¶µç›–å…¨æµç¨‹ï¼Œå€¼å¾—æºç å»åˆ†æã€‚æ¥ä¸‹æ¥æˆ‘ä»¬æŒ‰ç…§è°ƒç”¨é¡ºåºæ¥åˆ†æè¿™æ ·ä¸€ä¸ªæ¼«é•¿çš„è°ƒç”¨è¿‡ç¨‹ã€‚\nOPENSSL_load_builtin_modules ç¬¬ä¸€ä¸ªå‡½æ•°ï¼Œåˆå§‹åŒ–äº†ä¸€ä¸ªé»˜è®¤çš„conf_module, ä¸”åå­—å«åš\u0026rsquo;engines\u0026rsquo;ã€‚ç›´æ¥çœ‹æºç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  void OPENSSL_load_builtin_modules(void) { ... /* æˆ‘ä»¬å…¶ä»–çš„éƒ½ä¸é‡è¦ï¼Œç›´æ¥çœ‹è¿™ä¸ªå’ŒEngineç›¸å…³çš„ */ #ifndef OPENSSL_NO_ENGINE  ENGINE_add_conf_module(); #endif  ... } void ENGINE_add_conf_module(void) { CONF_module_add(\u0026#34;engines\u0026#34;, int_engine_module_init, int_engine_module_finish); }   æ¥åˆ°æˆ‘ä»¬çš„ç¬¬ä¸€ä¸ªå¤§å‘ï¼ŒOpenSSLçš„åŠ¨æ€é…ç½®æ–‡ä»¶åŠ è½½ï¼Œä½†è¿™é‡Œæˆ‘ä»¬ä¸éœ€è¦ç»†è‡´äº†è§£ï¼Œå…ˆç®€å•åˆ†æä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  int CONF_module_add(const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { if (module_add(NULL, name, ifunc, ffunc)) return 1; else return 0; } /* é‡è¦çš„ç»“æ„ä½“ä¸å…¨å±€å˜é‡ */ static STACK_OF(CONF_MODULE) *supported_modules = NULL; static STACK_OF(CONF_IMODULE) *initialized_modules = NULL; struct conf_module_st { /* DSO of this module or NULL if static */ DSO *dso; /* Name of the module */ char *name; /* Init function */ conf_init_func *init; /* Finish function */ conf_finish_func *finish; /* Number of successfully initialized modules */ int links; void *usr_data; }; typedef struct conf_module_st CONF_MODULE; static CONF_MODULE *module_add(DSO *dso, const char *name, conf_init_func *ifunc, conf_finish_func *ffunc) { CONF_MODULE *tmod = NULL; /* è‹¥supported_modulesä¸ºç©ºï¼Œ åˆ™åˆå§‹åŒ–æ­¤å…¨å±€å˜é‡ï¼Œå³å †æ ˆçš„åˆå§‹åŒ– */ if (supported_modules == NULL) supported_modules = sk_CONF_MODULE_new_null(); if (supported_modules == NULL) return NULL; /* ç”³è¯·é…ç½®æ–‡ä»¶æ¨¡å—ç»“æ„ä½“conf_module_stçš„ç©ºé—´ */ if ((tmod = OPENSSL_zalloc(sizeof(*tmod))) == NULL) { CONFerr(CONF_F_MODULE_ADD, ERR_R_MALLOC_FAILURE); return NULL; } /* * æ­¤å¤„ç¬¬ä¸€æ¬¡è°ƒç”¨ï¼Œdsoä¸ºNULLï¼› * dso = dynamic shared object, å¯ä»¥ç†è§£ä¸ºæ˜¯ä¸€ä¸ªOpenSSLå»åŠ è½½åŠ¨æ€åº“çš„ç»“æ„ä½“ï¼› */ tmod-\u0026gt;dso = dso; /* æ­¤å¤„è®°ä½ï¼Œå°†åˆå§‹åŒ–ä¸€ä¸ªå«\u0026#34;engines\u0026#34;çš„conf_module */ tmod-\u0026gt;name = OPENSSL_strdup(name); /* é…ç½®æ–‡ä»¶initå‡½æ•°ï¼Œ æ­¤å¤„å³int_engine_module_initã€‚è¿™ä¸ªå‡½æ•°æ˜¯å…³é”® */ tmod-\u0026gt;init = ifunc; /* é…ç½®æ–‡ä»¶finishå‡½æ•°ï¼Œ æ­¤å¤„å³int_engine_module_finish */ tmod-\u0026gt;finish = ffunc; if (tmod-\u0026gt;name == NULL) { OPENSSL_free(tmod); return NULL; } /* å°†è¿™ä¸ªçš„conf_moduleç»“æ„ä½“å…¥æ ˆè¿›supported_modulesè¿™ä¸ªå…¨å±€å˜é‡æ ˆä¸­ */ if (!sk_CONF_MODULE_push(supported_modules, tmod)) { OPENSSL_free(tmod-\u0026gt;name); OPENSSL_free(tmod); return NULL; } return tmod; }   æ­¤å¤„æœ‰ä¸€ä¸ªOpenSSLçš„ä¸€ä¸ªçŸ¥è¯†ç‚¹ï¼ŒOpenSSLä¸­å¯ä»¥å®šä¹‰ä»»æ„ç±»å‹çš„å®‰å…¨æ ˆï¼Œå¹¶ä¸”ç”Ÿæˆæ“ä½œè¿™ä¸ªç±»å‹æ ˆçš„å‡½æ•°æ—ã€‚ä¾‹å¦‚æœ‰ä¸€ä¸ªç»“æ„ä½“å«XXï¼Œåˆ™å¯ä»¥é€šè¿‡DEFINE_STACK_OF(XX)è¿™ä¸ªå®æ¥å®šä¹‰XXç»“æ„ä½“çš„æ ˆå’Œå‡½æ•°æ—ï¼Œé€šè¿‡STACK_OF(XX)æ¥å£°æ˜ä¸€ä¸ªæ ˆã€‚äº‹å®ä¸Šï¼Œå½“æˆ‘ä»¬çœ‹OpenSSLæºç æ—¶çœ‹åˆ°sk_è¿™ç§å‰ç¼€çš„éƒ½æ˜¯å †æ ˆæ“ä½œï¼Œè€Œä¸”æ˜¯æœç´¢ä¸åˆ°å®ç°çš„ (1.0.2ç‰ˆæœ¬åº”è¯¥å¯ä»¥æ‰¾åˆ°ï¼Œä¹‹åçš„ç‰ˆæœ¬éƒ½æ³›åŒ–äº†ï¼Œä»£ç å†™çš„ç§€ï¼Œçœ‹ä»£ç çš„è‡ªé—­)ã€‚\nè¯¦è§å®˜æ–¹æ–‡æ¡£ï¼šhttps://www.openssl.org/docs/man1.1.0/man3/DEFINE_STACK_OF.html\næ­¤å¤„æœ‰ä¸¤ä¸ªæ ˆæ“ä½œ: åˆå§‹åŒ–æ—¶supported_modulesä¸ºç©ºï¼Œæ‰€ä»¥å°†è°ƒç”¨sk_CONF_MODULE_new_nullå…ˆå»ºç«‹ä¸Šä¸€ä¸ªç©ºå®¹å™¨ã€‚ä¹‹åsk_CONF_MODULE_pushä½¿ä¸Šé¢åˆå§‹åŒ–çš„çš„CONF_MODULEå…¥æ ˆï¼Œä¹‹åæƒ³è¦å–åˆ°è¿™ä¸ªmoduleåˆ™éœ€è¦é€šè¿‡supported_modulesè¿™ä¸ªå…¨å±€æ ˆæ¥å–ã€‚\næ­¤å¤„å¤šæä¸€å¥ï¼ŒOpenSSLè¿˜æœ‰ä¸€ä¸ªç±»ä¼¼çš„ç»“æ„ä½“LHASHï¼Œå®ƒæ˜¯OpenSSLå†…éƒ¨çš„å“ˆå¸Œè¡¨ï¼Œå¦‚æœè¿™ç¯‡æ–‡ç« æœ‰ä¸‹æˆ‘ä»¬åº”è¯¥ä¼šç¢°åˆ°å®ƒï¼Œç›´æ¥ç†è§£æˆæ˜¯ä¸€ä¸ªkv_mapå°±å¥½ã€‚æ‰€æœ‰lh_å‰ç¼€å¼€å¤´çš„ä¹Ÿéƒ½æ˜¯å“ˆå¸Œè¡¨æ“ä½œã€‚\nENGINE_load_dynamic ç¬¬äºŒä¸ªå‡½æ•°ï¼Œæ¯”è¾ƒç»•ï¼Œç®€å•ç†è§£å°±æ˜¯ï¼šåˆå§‹åŒ–äº†ä¸€ä¸ªengine, åå­—å«åšdynamicï¼ŒOpenSSLç”¨è¿™ä¸ªengineæ¥åŠ¨æ€åŠ è½½åˆ«çš„engine\u0026hellip;\né¡ºä¾¿æä¸€å¥ï¼ŒENGINE_load_dynamic åœ¨1.1.xç‰ˆæœ¬å·²ç»åºŸå¼ƒäº†ï¼Œç»Ÿä¸€éƒ½æ˜¯è°ƒç”¨OPENSSL_init_cryptoè¿™ä¸ªå‡½æ•°ï¼Œopts = OPENSSL_INIT_ENGINE_DYNAMICã€‚è¿™åˆæ˜¯OpenSSLéå¸¸æ¶å¿ƒçš„åœ°æ–¹äº†ï¼Œç‰ˆæœ¬å…¼å®¹å¯ä»¥è¯´æ˜¯ç›¸å½“emmmmmmmm\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  \\# define ENGINE_load_dynamic() \\ OPENSSL_init_crypto(OPENSSL_INIT_ENGINE_DYNAMIC, NULL) int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings) { ... /* * RUN_ONCEæ˜¯å¤šçº¿ç¨‹æ—¶éœ€è¦å…³å¿ƒçš„ï¼Œæˆ‘ä»¬è¿™é‡Œä¸å…³å¿ƒï¼Œå°±ç­‰äºè°ƒç”¨ossl_init_engine_dynamic * æœ€åä¸€æ³¢å®å±•å¼€ï¼Œè°ƒç”¨çš„æ˜¯ engine_load_dynamic_int è¿™ä¸ªå‡½æ•° */ if ((opts \u0026amp; OPENSSL_INIT_ENGINE_DYNAMIC) \u0026amp;\u0026amp; !RUN_ONCE(\u0026amp;engine_dynamic, ossl_init_engine_dynamic)) return 0; ... } void engine_load_dynamic_int(void) { ENGINE *toadd = engine_dynamic(); /* è¿™å‘½åçœŸæ˜¯ç»äº†Orz */ if (!toadd) return; ENGINE_add(toadd); /* * If the \u0026#34;add\u0026#34; worked, it gets a structural reference. So either way, we * release our just-created reference. */ ENGINE_free(toadd); /* * If the \u0026#34;add\u0026#34; didn\u0026#39;t work, it was probably a conflict because it was * already added (eg. someone calling ENGINE_load_blah then calling * ENGINE_load_builtin_engines() perhaps). */ ERR_clear_error(); }   engine_dynamic ä¸¤ä¸ªæ ¸å¿ƒå‡½æ•°ï¼Œç¬¬ä¸€ä¸ª engine_dynamic æ–°å»ºäº†ä¸€ä¸ªidå«åš'dynamic'çš„engineï¼ŒæŒ‚ä¸Šäº†è¿™ä¸ªengineçš„å…·ä½“å¤„ç†å‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  static ENGINE *engine_dynamic(void) { /* OpenSSLç”³è¯·ç»“æ„ä½“ç©ºé—´ç»å¸¸ä½¿ç”¨çš„xx_new */ ENGINE *ret = ENGINE_new(); if (ret == NULL) return NULL; if (!ENGINE_set_id(ret, engine_dynamic_id) || !ENGINE_set_name(ret, engine_dynamic_name) || !ENGINE_set_init_function(ret, dynamic_init) || !ENGINE_set_finish_function(ret, dynamic_finish) || !ENGINE_set_ctrl_function(ret, dynamic_ctrl) || !ENGINE_set_flags(ret, ENGINE_FLAGS_BY_ID_COPY) || !ENGINE_set_cmd_defns(ret, dynamic_cmd_defns)) { ENGINE_free(ret); return NULL; } return ret; }   æˆ‘ä»¬æ‰«ä¸€çœ¼ENGINEç»“æ„ä½“ï¼Œé¦–å…ˆè¦æœ‰ä¸€ä¸ªæ¦‚å¿µï¼ŒENGINE_set_xx å°±æ˜¯å»è®¾ç½®è¿™ä¸ªç»“æ„ä½“çš„ç›¸åº”å­—æ®µï¼Œæ‰€ä»¥å¯ä»¥è®°å½•ä¸€ä¸‹è¿™ä¸ªç»“æ„ä½“è¢«åˆå§‹åŒ–æˆå•¥æ ·äº†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  struct engine_st { const char *id; const char *name; const RSA_METHOD *rsa_meth; const DSA_METHOD *dsa_meth; const DH_METHOD *dh_meth; const EC_KEY_METHOD *ec_meth; const RAND_METHOD *rand_meth; /* Cipher handling is via this callback */ ENGINE_CIPHERS_PTR ciphers; /* Digest handling is via this callback */ ENGINE_DIGESTS_PTR digests; /* Public key handling via this callback */ ENGINE_PKEY_METHS_PTR pkey_meths; /* ASN1 public key handling via this callback */ ENGINE_PKEY_ASN1_METHS_PTR pkey_asn1_meths; ENGINE_GEN_INT_FUNC_PTR destroy; ENGINE_GEN_INT_FUNC_PTR init; ENGINE_GEN_INT_FUNC_PTR finish; ENGINE_CTRL_FUNC_PTR ctrl; ENGINE_LOAD_KEY_PTR load_privkey; ENGINE_LOAD_KEY_PTR load_pubkey; ENGINE_SSL_CLIENT_CERT_PTR load_ssl_client_cert; const ENGINE_CMD_DEFN *cmd_defns; int flags; /* reference count on the structure itself */ CRYPTO_REF_COUNT struct_ref; /* * reference count on usability of the engine type. NB: This controls the * loading and initialisation of any functionality required by this * engine, whereas the previous count is simply to cope with * (de)allocation of this structure. Hence, running_ref \u0026lt;= struct_ref at * all times. */ int funct_ref; /* A place to store per-ENGINE data */ CRYPTO_EX_DATA ex_data; /* Used to maintain the linked-list of engines. */ struct engine_st *prev; struct engine_st *next; }   æ•´ç†å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  static const char *engine_dynamic_id = \u0026#34;dynamic\u0026#34;; static const char *engine_dynamic_name = \u0026#34;Dynamic engine loading support\u0026#34;; static const ENGINE_CMD_DEFN dynamic_cmd_defns[] = { {DYNAMIC_CMD_SO_PATH, \u0026#34;SO_PATH\u0026#34;, \u0026#34;Specifies the path to the new ENGINE shared library\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_NO_VCHECK, \u0026#34;NO_VCHECK\u0026#34;, \u0026#34;Specifies to continue even if version checking fails (boolean)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_ID, \u0026#34;ID\u0026#34;, \u0026#34;Specifies an ENGINE id name for loading\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LIST_ADD, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;Whether to add a loaded ENGINE to the internal list (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_LOAD, \u0026#34;DIR_LOAD\u0026#34;, \u0026#34;Specifies whether to load from \u0026#39;DIR_ADD\u0026#39; directories (0=no,1=yes,2=mandatory)\u0026#34;, ENGINE_CMD_FLAG_NUMERIC}, {DYNAMIC_CMD_DIR_ADD, \u0026#34;DIR_ADD\u0026#34;, \u0026#34;Adds a directory from which ENGINEs can be loaded\u0026#34;, ENGINE_CMD_FLAG_STRING}, {DYNAMIC_CMD_LOAD, \u0026#34;LOAD\u0026#34;, \u0026#34;Load up the ENGINE specified by other settings\u0026#34;, ENGINE_CMD_FLAG_NO_INPUT}, {0, NULL, NULL, 0} }; /* åŠ è½½åŠ¨æ€engineæ—¶çš„å‘½ä»¤ */ # define ENGINE_FLAGS_BY_ID_COPY (int)0x0004  ENGINE dynamic = {.id = engine_dynamic_id, .name = engine_dynamic_name, .init = dynamic_init, /* ç©ºå‡½æ•°ï¼Œç›´æ¥return 0 */ .finish = dynamic_finish, /* ç©ºå‡½æ•°ï¼Œç›´æ¥return 0 */ .ctrl = dynamic_ctrl, /* æœ€é‡è¦çš„å‡½æ•°ï¼Œåæ–‡å°†åˆ†æå¦‚ä½•è°ƒç”¨åˆ°è¿™æ¥ */ .flags = ENGINE_FLAGS_BY_ID_COPYï¼Œ .cmd_defns = dynamic_cmd_defns /*å®šä¹‰äº†dynamicè¿™ä¸ªengine ctrlä¸‹çš„åˆæ³•cmd*/ .prev = NULL, .next = NULL /* è¯´æ˜engineéƒ½æ˜¯ä»¥åŒå‘é“¾è¡¨å½¢å¼ç®¡ç† */ };   å®Œæˆåˆå§‹åŒ–åï¼Œå°†è¿”å›ä¸Šè¿™ä¸ªnewå‡ºæ¥çš„ENGINEç»“æ„ä½“ã€‚éšåä¸¢åˆ°ENGINE_add é‡Œã€‚\nENGINE_add ä¸Šé¢ç»“æ„ä½“åˆ†æå…¶å®å·²ç»å¯ä»¥çœ‹åˆ°ï¼Œæ‰€æœ‰çš„engineéƒ½å°†ä»¥åŒå‘é“¾è¡¨å½¢å¼ç®¡ç†ï¼Œé“¾è¡¨å»ºç«‹ç®€å•ç²—æš´ï¼Œç›´æ¥å®šä¹‰å…¨å±€å˜é‡ä¸€å¤´ä¸€å°¾ï¼Œæ·»åŠ æ—¶å°±å¾€å°¾å·´åŠ ï¼Œæœç´¢å°±ä»å¤´ç»“ç‚¹å¼€å§‹æœç´¢ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  static ENGINE *engine_list_head = NULL; static ENGINE *engine_list_tail = NULL; /* Add another \u0026#34;ENGINE\u0026#34; type into the list. */ int ENGINE_add(ENGINE *e) { int to_return = 1; /* ä¸€äº›å…¥å‚æ£€æŸ¥ï¼Œomit */ ... /* å…¨å±€å˜é‡æ“ä½œæ—¶éœ€è¦åŠ é”ä»¥æ”¯æŒå¤šçº¿ç¨‹ */ CRYPTO_THREAD_write_lock(global_engine_lock); /* æ ¸å¿ƒå‡½æ•°ï¼Œå°†åˆšåˆšnewå‡ºæ¥çš„dynamicåŠ å…¥å…¨å±€é“¾è¡¨ä¸­ */ if (!engine_list_add(e)) { ENGINEerr(ENGINE_F_ENGINE_ADD, ENGINE_R_INTERNAL_LIST_ERROR); to_return = 0; } CRYPTO_THREAD_unlock(global_engine_lock); return to_return; } static int engine_list_add(ENGINE *e) { int conflict = 0; ENGINE *iterator = NULL; if (e == NULL) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ERR_R_PASSED_NULL_PARAMETER); return 0; } /* ä»é“¾è¡¨å¤´å¼€å§‹è¿­ä»£ */ iterator = engine_list_head; /* ç›´æ¥éå†åˆ°å°¾éƒ¨æŸ¥çœ‹æœ‰æ²¡æœ‰é‡idçš„æƒ…å†µï¼Œé‡idç›´æ¥æŠ¥é”™é€€å‡º */ while (iterator \u0026amp;\u0026amp; !conflict) { conflict = (strcmp(iterator-\u0026gt;id, e-\u0026gt;id) == 0); iterator = iterator-\u0026gt;next; } if (conflict) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } if (engine_list_head == NULL) { /* We are adding to an empty list. */ if (engine_list_tail) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* engine_listä¸ºç©ºçš„è¯åˆ™é“¾è¡¨å¤´ä¸ºæ–°å»ºçš„engine */ engine_list_head = e; e-\u0026gt;prev = NULL; /* * The first time the list allocates, we should register the cleanup. */ engine_cleanup_add_last(engine_list_cleanup); } else { /* We are adding to the tail of an existing list. */ if ((engine_list_tail == NULL) || (engine_list_tail-\u0026gt;next != NULL)) { ENGINEerr(ENGINE_F_ENGINE_LIST_ADD, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } /* å°†æ–°engineåŠ åˆ°é˜Ÿå°¾çš„åé¢ */ engine_list_tail-\u0026gt;next = e; e-\u0026gt;prev = engine_list_tail; } /* * Having the engine in the list assumes a structural reference. */ e-\u0026gt;struct_ref++; engine_ref_debug(e, 0, 1); /* å°†é˜Ÿå°¾æŒ‡å‘æ–°engine */ engine_list_tail = e; e-\u0026gt;next = NULL; return 1; }   è¿™æ ·ï¼Œidä¸º'dynamic'è¢«åŠ å…¥äº†å…¨å±€engineåˆ—è¡¨å½“ä¸­ï¼Œè¢«ç®¡ç†èµ·æ¥ã€‚\nCONF æˆ‘ä»¬è¿™é‡Œå¯¹OpenSSLçš„åŠ¨æ€é…ç½®confä¸éœ€è¦ç»†è‡´åˆ†æï¼Œéšç€ä»£ç åˆ†æå³å¯ã€‚å®˜æ–¹æ–‡æ¡£å…¶å®å¯¹confæ ¼å¼è®²è§£çš„å¾ˆæ¸…æ¥šï¼Œå¯ä»¥å­¦ä¹ :\nhttps://www.openssl.org/docs/man1.1.1/man5/config.html\nEngine Configuration Moduleè¿™ä¸ªå°èŠ‚\nä¾‹å­ä¸­confæ–‡ä»¶ é¦–å…ˆæˆ‘ä»¬æ¥çœ‹engineXä¾‹å­ä¸­çš„confæ˜¯æ€ä¹ˆå†™çš„ï¼š\nopenssl_conf = openssl_def [openssl_def] engines = engine_section [engine_section] engine_x = engine_x_section [engine_x_section] engine_id = engineX dynamic_path = ${ENV::PWD}/build/engine_ex.so default_algorithms = ALL init = 1 ç®€å•å­¦ä¹ ä¸€ä¸‹confä¹‹åï¼Œæˆ‘ä»¬ä¹‹åè¿™ä¸ªé…ç½®æ–‡ä»¶æ ¸å¿ƒçš„sectionå°±æ˜¯engine_sectionï¼Œå…¶ä¸­dynamic_pathå®šä¹‰ä¸Šäº†è¯¥engineå…±äº«åº“çš„è·¯å¾„ã€‚æˆ‘ä»¬çœ‹çœ‹ä¾‹å­ä¸­æ˜¯å¦‚ä½•æ ¹æ®è¿™ä¸ªé…ç½®æ–‡ä»¶å»åŠ è½½å¯¹åº”çš„engineçš„\nCONF_modules_load_file 1 2 3 4 5 6 7 8  ... char openssl_cnf_path[] = \u0026#34;./openssl.cnf\u0026#34;; // loading configuration  if (CONF_modules_load_file(openssl_cnf_path, \u0026#34;openssl_conf\u0026#34;, 0) != 1) { ... } ...   CONF_modules_load_fileæ˜¯å»åŠ è½½é…ç½®å¹¶ä½¿èƒ½é…ç½®çš„æ¥å£ï¼Œè¿™é‡Œæˆ‘ä»¬ä¸»è¦å…³å¿ƒå¦‚ä½•å»æ ¹æ®é…ç½®æ–‡ä»¶å»åŠ è½½åŠ¨æ€åº“ï¼Œå…·ä½“æ€ä¹ˆå®Œæˆé…ç½®æ–‡ä»¶è§£æçš„æµç¨‹è¿™é‡Œä¸è®¨è®ºã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  int CONF_modules_load_file(const char *filename, const char *appname, unsigned long flags) { return CONF_modules_load_file_with_libctx(NULL, filename, appname, flags); } int CONF_modules_load_file_with_libctx(OPENSSL_CTX *libctx, const char *filename, const char *appname, unsigned long flags) { char *file = NULL; CONF *conf = NULL; int ret = 0; conf = NCONF_new_with_libctx(libctx, NULL); if (conf == NULL) goto err; if (filename == NULL) { file = CONF_get1_default_config_file(); if (file == NULL) goto err; } else { file = (char *)filename; } if (NCONF_load(conf, file, NULL) \u0026lt;= 0) { if ((flags \u0026amp; CONF_MFLAGS_IGNORE_MISSING_FILE) \u0026amp;\u0026amp; (ERR_GET_REASON(ERR_peek_last_error()) == CONF_R_NO_SUCH_FILE)) { ERR_clear_error(); ret = 1; } goto err; } ret = CONF_modules_load(conf, appname, flags); err: if (filename == NULL) OPENSSL_free(file); NCONF_free(conf); if (flags \u0026amp; CONF_MFLAGS_IGNORE_RETURN_CODES) return 1; return ret; }   å¯ä»¥çœ‹åˆ°è¿™é‡Œä¸»è¦æœ‰ä¸‰æ­¥æ“ä½œNCONF_new_with_libctxã€NCONF_loadã€CONF_modules_loadï¼Œæˆ‘ä»¬ä¸€ä¸ªä¸€ä¸ªåˆ†æã€‚\nNCONF_new_with_libctx è¿™ä¸ªå‡½æ•°ä¸»è¦æ˜¯åˆå§‹åŒ–ä¸Šäº†ä¸€ä¸ªCONFç»“æ„ä½“ï¼ŒåŒæ—¶å°†è¿™ä¸ªç»“æ„ä½“çš„METHODå®šä¹‰æˆäº†é»˜è®¤æ–¹æ³•ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  /* é…ç½®æ–‡ä»¶çš„methodæ¨¡æ¿ */ struct conf_method_st { const char *name; CONF *(*create) (CONF_METHOD *meth); int (*init) (CONF *conf); int (*destroy) (CONF *conf); int (*destroy_data) (CONF *conf); int (*load_bio) (CONF *conf, BIO *bp, long *eline); int (*dump) (const CONF *conf, BIO *bp); int (*is_number) (const CONF *conf, char c); int (*to_int) (const CONF *conf, char c); int (*load) (CONF *conf, const char *name, long *eline); }; /* * æ‰€æœ‰çš„ AA = BB éƒ½ä¼šæŒ‰ç…§è¿™ä¸ªæ ¼å¼ä¿å­˜ * å¦‚[openssl_def] engines = engine_section * æ­¤æ—¶è¿™ä¸ªåº•ä¸‹conf_stçš„å“ˆå¸Œè¡¨ä¸­å°†ä¿å­˜ä¸Šä¸€ä»½ * {.section = \u0026#34;openssl_def\u0026#34;, .name = \u0026#34;engines\u0026#34;, value = \u0026#34;engine_section\u0026#34;} */ typedef struct { char *section; char *name; char *value; } CONF_VALUE; struct conf_st { CONF_METHOD *meth; /* åŠ¨æ€é…ç½®çš„æ–¹æ³•ï¼Œè¿™é‡Œä½¿ç”¨default */ void *meth_data; LHASH_OF(CONF_VALUE) *data; /* ä¸Šæ–‡æœ‰æåˆ°çš„å“ˆå¸Œè¡¨ */ unsigned int flag_dollarid:1; OPENSSL_CTX *libctx; }; /* * The following section contains the \u0026#34;New CONF\u0026#34; functions. They are * completely centralised around a new CONF structure that may contain * basically anything, but at least a method pointer and a table of data. * These functions are also written in terms of the bridge functions used by * the \u0026#34;CONF classic\u0026#34; functions, for consistency. */ CONF *NCONF_new_with_libctx(OPENSSL_CTX *libctx, CONF_METHOD *meth) { CONF *ret; if (meth == NULL) meth = NCONF_default(); ret = meth-\u0026gt;create(meth); if (ret == NULL) { CONFerr(0, ERR_R_MALLOC_FAILURE); return NULL; } /* è¿™ä¸ªæµç¨‹ä¸­æ˜¯NULLï¼Œä¸éœ€è¦åˆ†æ */ ret-\u0026gt;libctx = libctx; return ret; }   æˆ‘ä»¬å…ˆçœ‹NCONF_defaultï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /* æ ‡è®°ä¸Šè¿™äº›æ–¹æ³•ï¼Œç›¸å…³å®šä¹‰åç»­ä¼šç»™å‡ºï¼Œä¸”å°†ä¼šä½¿ç”¨ */ static CONF_METHOD default_method = { \u0026#34;OpenSSL default\u0026#34;, def_create, def_init_default, def_destroy, def_destroy_data, def_load_bio, def_dump, def_is_number, def_to_int, def_load }; CONF_METHOD *NCONF_default(void) { return \u0026amp;default_method; }   ç¬¬ä¸€ä¸ªåœ¨default_methodè¢«ä½¿ç”¨çš„æ–¹æ³•å°±æ˜¯def_create, å¾ˆæ˜æ˜¾æ˜¯å»ç”³è¯·ä¸€å—CONFç»“æ„ä½“å†…å­˜ï¼Œä¹‹åè°ƒç”¨def_init_defaultå»åˆå§‹åŒ–ç»“æ„ä½“ :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  static CONF *def_create(CONF_METHOD *meth) { CONF *ret; ret = OPENSSL_malloc(sizeof(*ret)); if (ret != NULL) /* è¿™é‡Œè°ƒç”¨`def_init_default` */ if (meth-\u0026gt;init(ret) == 0) { OPENSSL_free(ret); ret = NULL; } return ret; } static int def_init_default(CONF *conf) { if (conf == NULL) return 0; memset(conf, 0, sizeof(*conf)); /* å°†æ–°ç”³è¯·çš„CONFç»“æ„ä½“çš„methodå­—æ®µè®¾ç½®ä¸ºé»˜è®¤method */ conf-\u0026gt;meth = \u0026amp;default_method; /* meth_dataçš„è®¾ç½®ï¼Œè¿™ä¸ªæ˜¯.confæ–‡ä»¶å­—ç¬¦è§£ææ—¶å€™ä½¿ç”¨çš„ï¼Œæˆ‘ä»¬è¿™é‡Œä¸è®² */ conf-\u0026gt;meth_data = (void *)CONF_type_default; return 1; }   NCONF_load åˆå§‹åŒ–å¥½CONFç»“æ„ä½“ï¼Œç¡®å®šå¥½å¯¹åº”é…ç½®æ–‡ä»¶åï¼Œå¼€å§‹å¯¹é…ç½®æ–‡ä»¶è¿›è¡Œè§£æï¼ŒNCONF_load ï¼ˆOpenSSLè¿é…ç½®æ–‡ä»¶æ ¼å¼éƒ½è‡ªå·±å®šä¹‰è‡ªå·±è§£æï¼Œç¡¬æ ¸ç¡¬æ ¸ï¼‰å°†è°ƒç”¨åˆ°é»˜è®¤æ–¹æ³•ä¹‹ def_load\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  int NCONF_load(CONF *conf, const char *file, long *eline) { if (conf == NULL) { CONFerr(CONF_F_NCONF_LOAD, CONF_R_NO_CONF); return 0; } return conf-\u0026gt;meth-\u0026gt;load(conf, file, eline); } static int def_load(CONF *conf, const char *name, long *line) { int ret; BIO *in = NULL; /* è¿™é‡Œé€šè¿‡BIOè¯»å…¥æ–‡ä»¶(Binary IO, opensslè‡ªå·±å®šä¹‰çš„ioï¼Œç®€å•ç†è§£å°±æ˜¯ä¸€å—å†…å­˜Orz) */ #ifdef OPENSSL_SYS_VMS  in = BIO_new_file(name, \u0026#34;r\u0026#34;); #else  in = BIO_new_file(name, \u0026#34;rb\u0026#34;); #endif  ... /* æ­£å¼è§£æï¼ŒæŒ‰æ®µè§£æï¼› * è¿™é‡Œä¸åˆ†æå’‹è§£æçš„ï¼Œå¾ˆå¤æ‚å¾ˆé•¿ï¼Œç”šè‡³èƒ½å¤„ç†ä¸€äº›ç¯å¢ƒå˜é‡$(xxx)... æœ * æœ€åç»“æœéƒ½å­˜åœ¨å“ˆå¸Œè¡¨dataä¸­ */ ret = def_load_bio(conf, in, line); BIO_free(in); return ret; }   CONF_modules_load æ ¸å¿ƒè¿‡ç¨‹ï¼Œä»CONFå»åŠ è½½ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„'engines'è¿™ä¸ªmodule:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125  int CONF_modules_load(const CONF *cnf, const char *appname, unsigned long flags) { STACK_OF(CONF_VALUE) *values; CONF_VALUE *vl; char *vsection = NULL; int ret, i; if (!cnf) return 1; /* å…ˆè·å–åˆ°å¯¹åº”çš„sectionåï¼Œè¿™é‡Œå°±æ˜¯\u0026#34;openssl_conf\u0026#34; */ if (appname) vsection = NCONF_get_string(cnf, NULL, appname); if (!appname || (!vsection \u0026amp;\u0026amp; (flags \u0026amp; CONF_MFLAGS_DEFAULT_SECTION))) vsection = NCONF_get_string(cnf, NULL, \u0026#34;openssl_conf\u0026#34;); if (!vsection) { ERR_clear_error(); return 1; } OSSL_TRACE1(CONF, \u0026#34;Configuration in section %s\\n\u0026#34;, vsection); /* * æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ®µ openssl_conf * [openssl_def] * engines = engine_section */ values = NCONF_get_section(cnf, vsection); if (!values) return 0; for (i = 0; i \u0026lt; sk_CONF_VALUE_num(values); i++) { vl = sk_CONF_VALUE_value(values, i); /* éå†æ‰€æœ‰çš„valueï¼Œè¿™é‡Œåªæœ‰ä¸€ä¸ª \u0026#39;engines\u0026#39; */ ret = module_run(cnf, vl-\u0026gt;name, vl-\u0026gt;value, flags); OSSL_TRACE3(CONF, \u0026#34;Running module %s (%s) returned %d\\n\u0026#34;, vl-\u0026gt;name, vl-\u0026gt;value, ret); if (ret \u0026lt;= 0) if (!(flags \u0026amp; CONF_MFLAGS_IGNORE_ERRORS)) return ret; } return 1; } static int module_run(const CONF *cnf, const char *name, const char *value, unsigned long flags) { CONF_MODULE *md; int ret; if (!RUN_ONCE(\u0026amp;load_builtin_modules, do_load_builtin_modules)) return -1; /* è¿™é‡Œä¼šåœ¨supported_modulesè¿™ä¸ªæ ˆä¸Šæ‰¾åˆ°\u0026#39;engines\u0026#39;è¿™ä¸ªCONF_MODULEï¼Œå¼€å§‹é­”å¹»è¡¨æ¼” */ md = module_find(name); ... /* initè¿™ä¸ªmoduleï¼Œè¿™é‡Œå°†å»è°ƒç”¨åˆ°\u0026#39;dynamic\u0026#39;è¿™ä¸ªengineï¼Œä¸‹é¢å°†åˆ†æ */ ret = module_init(md, name, value, cnf); ... return ret; } /* initialize a module */ /* æ­¤å¤„å°†ç”³è¯·ä¸Šä¸€ä¸ªæ‰€è°“çš„initialized moduleï¼Œ * ä¹‹åè°ƒç”¨\u0026#39;engines\u0026#39;çš„initå‡½æ•° * è‹¥æˆåŠŸï¼Œå°†\u0026#39;engines\u0026#39; pushè¿›çš„å…¨å±€å˜é‡æ ˆ initialized_modules */ static int module_init(CONF_MODULE *pmod, const char *name, const char *value, const CONF *cnf) { int ret = 1; int init_called = 0; CONF_IMODULE *imod = NULL; /* Otherwise add initialized module to list */ imod = OPENSSL_malloc(sizeof(*imod)); if (imod == NULL) goto err; imod-\u0026gt;pmod = pmod; imod-\u0026gt;name = OPENSSL_strdup(name); /* å³\u0026#39;engines\u0026#39; */ imod-\u0026gt;value = OPENSSL_strdup(value); imod-\u0026gt;usr_data = NULL; if (!imod-\u0026gt;name || !imod-\u0026gt;value) goto memerr; /* Try to initialize module */ if (pmod-\u0026gt;init) { /* è°ƒç”¨enginesçš„initï¼Œå³ç¬¬ä¸€éƒ¨åˆ†æåˆ°çš„int_engine_module_initå‡½æ•° */ ret = pmod-\u0026gt;init(imod, cnf); init_called = 1; /* Error occurred, exit */ if (ret \u0026lt;= 0) goto err; } if (initialized_modules == NULL) { initialized_modules = sk_CONF_IMODULE_new_null(); if (!initialized_modules) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } } /* å°†\u0026#39;engines\u0026#39; pushè¿›çš„å…¨å±€å˜é‡æ ˆ initialized_modules */ if (!sk_CONF_IMODULE_push(initialized_modules, imod)) { CONFerr(CONF_F_MODULE_INIT, ERR_R_MALLOC_FAILURE); goto err; } pmod-\u0026gt;links++; return ret; err: ... }   CONFçš„ç¬¬ä¸€éƒ¨åˆ†å¤„ç†å®Œæ¯•ï¼Œå¼€å§‹æŸ¥çœ‹å¦‚ä½•ç»§ç»­è§£æè¿™ä¸ªé…ç½®\nint_engine_module_init è¿™éƒ¨åˆ†å¼€å§‹å–enginesè¿™ä¸ªsectionä¸‹çš„æ•°æ®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  static int int_engine_module_init(CONF_IMODULE *md, const CONF *cnf) { STACK_OF(CONF_VALUE) *elist; CONF_VALUE *cval; int i; OSSL_TRACE2(CONF, \u0026#34;Called engine module: name %s, value %s\\n\u0026#34;, CONF_imodule_get_name(md), CONF_imodule_get_value(md)); /* Value is a section containing ENGINEs to configure */ elist = NCONF_get_section(cnf, CONF_imodule_get_value(md)); /* * è·å–engine_sectionä¸‹çš„åˆ—è¡¨ï¼Œè¿™é‡Œå°±ä¸€ä¸ªsectionå«åšengine_x_section * [engine_section] * engine_x = engine_x_section */ if (!elist) { ENGINEerr(ENGINE_F_INT_ENGINE_MODULE_INIT, ENGINE_R_ENGINES_SECTION_ERROR); return 0; } for (i = 0; i \u0026lt; sk_CONF_VALUE_num(elist); i++) { cval = sk_CONF_VALUE_value(elist, i); /* * name: engine_x, value: engine_x_section * å‡†å¤‡å¼€å§‹åŠ è½½äº† */ if (!int_engine_configure(cval-\u0026gt;name, cval-\u0026gt;value, cnf)) return 0; } return 1; }   int_engine_configure æ˜¯åŠ è½½engineçš„ä¸»è¦æµç¨‹ï¼Œæˆ‘ä»¬æŒ‰é¡ºåºæ¥ä¸€æ­¥ä¸€æ­¥åˆ†æå†…éƒ¨çš„å¾ªç¯\nint_engine_configure  é¦–å…ˆåŠ è½½ä¸Švalueçš„sectionï¼š  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { int i; int ret = 0; long do_init = -1; STACK_OF(CONF_VALUE) *ecmds; CONF_VALUE *ecmd = NULL; const char *ctrlname, *ctrlvalue; ENGINE *e = NULL; int soft = 0; name = skip_dot(name); OSSL_TRACE1(CONF, \u0026#34;Configuring engine %s\\n\u0026#34;, name); /* Value is a section containing ENGINE commands */ /* åœ¨confçš„å“ˆå¸Œè¡¨ä¸­æ‰¾ å«åšengine_x_sectionçš„section */ ecmds = NCONF_get_section(cnf, value); /* * æ­¤æ—¶ecmdsæ˜¯ä¸€ä¸ªæ ˆï¼ŒæŒ‰é¡ºåºæœ‰ä»¥ä¸‹CONF_VALUE (å…±æœ‰section = \u0026#34;engine_x_section\u0026#34;) * {.name = \u0026#34;engine_id\u0026#34;, .value = \u0026#34;engineX\u0026#34;} * {.name = \u0026#34;dynamic_path\u0026#34;, .value = \u0026#34;${ENV::PWD}/build/engine_ex.so\u0026#34;(è¿™é‡Œå·²ç»é€šé…ç¬¦è§£æ * äº†)} * {.name = \u0026#34;default_algorithms\u0026#34;, .value = \u0026#34;ALL\u0026#34;} * {.name = \u0026#34;init\u0026#34;, .value = \u0026#34;1\u0026#34;} */ if (!ecmds) { ENGINEerr(ENGINE_F_INT_ENGINE_CONFIGURE, ENGINE_R_ENGINE_SECTION_ERROR); return 0; } ... }    æŒ‰ç…§é¡ºåºè§£æï¼š\nç¬¬ä¸€ä¸ªæ˜¯engine_id:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  static int int_engine_configure(const char *name, const char *value, const CONF *cnf) { ... /* å¼€å§‹å¯¹ecmdsä¸­æ ˆä¸Šçš„CONF_VALUEéå†ï¼Œè¿™éƒ¨åˆ†ä»£ç éƒ½åœ¨è¿™ä¸ªforå¾ªç¯ä¸­ */ for (i = 0; i \u0026lt; sk_CONF_VALUE_num(ecmds); i++) { ecmd = sk_CONF_VALUE_value(ecmds, i); /* è§£æå‡ºctrlnameå’Œctrlvalueï¼Œå¯¹åº”ç»“æ„ä½“ä¸­.nameå’Œ.value, ä¸‹åŒ */ ctrlname = skip_dot(ecmd-\u0026gt;name); ctrlvalue = ecmd-\u0026gt;value; OSSL_TRACE2(CONF, \u0026#34;ENGINE: doing ctrl(%s,%s)\\n\u0026#34;, ctrlname, ctrlvalue); /* First handle some special pseudo ctrls */ /* Override engine name to use */ if (strcmp(ctrlname, \u0026#34;engine_id\u0026#34;) == 0) /* æŠŠnameåˆ¶æˆconfæ–‡ä»¶ä¸­engine_id */ name = ctrlvalue; ... } ... }   ç¬¬äºŒä¸ªæ˜¯dynamic_pathï¼Œ è¿™ä¸ªå®šä¹‰æœ€å…³é”®ï¼Œæ‰¾åˆ°è¿™ä¸ªnameï¼Œå¼€å§‹æŒ‰ç…§æŒ‡å®šè·¯å¾„åŠ è½½åŠ¨æ€åº“engine:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  for(...) { ... else if (strcmp(ctrlname, \u0026#34;dynamic_path\u0026#34;) == 0) { /* * çœ‹åˆ°è¿™é‡Œæ˜¯ä¸æ˜¯è±ç„¶å¼€æœ—ï¼Œé¦–å…ˆæ‰¾åˆ°ç¬¬äºŒéƒ¨åˆ†åˆå§‹åŒ–çš„å«åšdynamicçš„engine * ä½†è¿™ä¸ªåœ°æ–¹æœ‰ä¸ªå€¼å¾—æ³¨æ„çš„ç‚¹ï¼Œåº•ä¸‹åˆ†æENGINE_by_id */ e = ENGINE_by_id(\u0026#34;dynamic\u0026#34;); /* æ‹¿åˆ°\u0026#39;dynamic\u0026#39;è¿™ä¸ªENGINEç»“æ„ä½“åï¼Œè¿›è¡Œä¸‰æ­¥æ“ä½œï¼Œå®Œæˆäº†engineXè¿™ä¸ªsoçš„åŠ è½½ */ /* ä¹‹åæˆ‘ä»¬å°†å•ç‹¬æŠŠENGINE_ctrl_cmd_stringæ‹¿å‡ºæ¥åˆ†æï¼Œè§‚å¯Ÿå®ƒæ˜¯å¦‚ä½•å»åŠ è½½çš„*/ if (!e) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;SO_PATH\u0026#34;, ctrlvalue, 0)) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;LIST_ADD\u0026#34;, \u0026#34;2\u0026#34;, 0)) goto err; if (!ENGINE_ctrl_cmd_string(e, \u0026#34;LOAD\u0026#34;, NULL, 0)) goto err; ... } /* * å®Œæˆè¿™ä¸‰æ­¥æ“ä½œåï¼Œ\u0026#39;dynamic\u0026#39;å‰¯æœ¬è¿™ä¸ªengineå·²ç»è¢«é‡å†™æˆäº† \u0026#39;engineX\u0026#39;ï¼ * åŒæ—¶è¿™ä¸ªengineXä¹ŸåŠ å…¥äº†enginesçš„é˜Ÿåˆ—ä¸­ã€‚ */ ENGINE *ENGINE_by_id(const char *id) { /* å…¥å‚æ£€æŸ¥å’Œç¯å¢ƒåˆå§‹åŒ–æ£€æŸ¥ omit */ ... /* åŠ é”åå¼€å§‹éå†é“¾è¡¨ï¼ŒåŒ¹é…id = \u0026#34;dynamic\u0026#34; */ CRYPTO_THREAD_write_lock(global_engine_lock); iterator = engine_list_head; while (iterator \u0026amp;\u0026amp; (strcmp(id, iterator-\u0026gt;id) != 0)) iterator = iterator-\u0026gt;next; if (iterator != NULL) { /* * We need to return a structural reference. If this is an ENGINE * type that returns copies, make a duplicate - otherwise increment * the existing ENGINE\u0026#39;s reference count. */ /* åŒ¹é…æˆåŠŸåçš„å°æ“ä½œï¼šçœ‹ENGINE_load_dynamicæºç å¯ä»¥çœ‹åˆ° dynamic-\u0026gt;flag è¢«è®¾ç½®æˆäº† ENGINE_FLAGS_BY_ID_COPY */ if (iterator-\u0026gt;flags \u0026amp; ENGINE_FLAGS_BY_ID_COPY) { ENGINE *cp = ENGINE_new(); if (cp == NULL) iterator = NULL; else { /* æ­¤å¤„å¾ˆé‡è¦ï¼ */ /* æ­¤å¤„å–å‡ºçš„dynamicï¼Œä¸æ˜¯ç›´æ¥å–å‡ºé“¾è¡¨ä¸­çš„engineèŠ‚ç‚¹ï¼Œè€Œæ˜¯å¤åˆ¶äº†ä¸€ä¸ªèŠ‚ç‚¹ */ engine_cpy(cp, iterator); iterator = cp; } } else { iterator-\u0026gt;struct_ref++; engine_ref_debug(iterator, 0, 1); } } CRYPTO_THREAD_unlock(global_engine_lock); if (iterator != NULL) /* ä½œä¸ºå–å‡ºè¿”å›å€¼ï¼Œå¾—åˆ°äº†ä¸€ä¸ªdynamicçš„å‰¯æœ¬ */ return iterator; }     æ³¨æ„ï¼Œæ­¤æ—¶eè¿™ä¸ªå±€éƒ¨å˜é‡å·²ç»æ˜¯ä¸€ä¸ªidä¸º'engineX'çš„ENGINEç»“æ„ä½“äº†ï¼Œä¹Ÿå°±æ˜¯å®Œæˆäº†åŠ¨æ€åŠ è½½çš„engineï¼\nç¬¬ä¸‰æ­¥æ˜¯default_algorithms:\n1 2 3 4 5  for (...) { else if (strcmp(ctrlname, \u0026#34;default_algorithms\u0026#34;) == 0) { if (!ENGINE_set_default_string(e, ctrlvalue)) ... }   ç¬¬å››æ­¥ï¼Œå®ŒæˆInit:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  for (...) { if (strcmp(ctrlname, \u0026#34;init\u0026#34;) == 0) { if (!NCONF_get_number_e(cnf, value, \u0026#34;init\u0026#34;, \u0026amp;do_init)) goto err; if (do_init == 1) { /* * æ­¤å¤„ä¸º1ï¼Œå®Œæˆengine init, * å…·ä½“ä»£ç å°±æ˜¯è°ƒç”¨ENGINE_initå»æ‰§è¡Œe-\u0026gt;init, å¢åŠ å¼•ç”¨æ•°ä¹‹ç±»çš„ï¼Œæˆ‘ä»¬è¿™é‡Œå…¶å®æ˜¯ç©ºçš„ * ä¹‹åå»æŠŠè¿™ä¸ªengineåŒæ—¶åŠ å…¥initialized_enginesè¿™ä¸ªå…¨å±€å˜é‡æ ˆä¸­ã€‚ä»£ç ä¸çœ‹äº† */ if (!int_engine_init(e)) goto err; ... }   å°±æ­¤CONF_modules_loadå…¨éƒ¨è¿è¡Œå®Œæˆï¼ŒengineXåŠ è½½å®Œæ¯•ã€‚åç»­åªéœ€è¦åƒmainå‡½æ•°ä¸­çš„ä½¿ç”¨ENGINE_by_id(\u0026quot;engineX\u0026quot;);å°±å¯ä»¥å–å¾—è¿™ä¸ªengineäº†ã€‚åœ†æ»¡ã€‚\nä½†æ˜¯ bind_engine åœ¨å“ªè°ƒç”¨çš„å‘¢ï¼Œè¿˜æ˜¯æ²¡çœ‹åˆ°ï¼Œé‚£å¿…ç„¶æ˜¯åœ¨ENGINE_ctrl_cmd_stringæµç¨‹ä¸­ã€‚æ‰€ä»¥ä¸‹é¢é‡ç‚¹è®²è®²è¿™ä¸ªå‡½æ•°ã€‚\nENGINE_ctrl_cmd_string ä»cmd_nameå»è·å–cmd_num 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { int num, flags; long l; char *ptr; ... /* å®çš„å‘½åå·²ç»æš´éœ²äº†ä¸€åˆ‡ï¼Œé€šè¿‡cmd_nameå¾—åˆ°cmd_num */ if (e-\u0026gt;ctrl == NULL || (num = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FROM_NAME, 0, (void *)cmd_name, NULL)) \u0026lt;= 0) { ... } ... } int ENGINE_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... /* * Intercept any \u0026#34;root-level\u0026#34; commands before trying to hand them on to * ctrl() handlers. */ switch (cmd) { /* è¿™éƒ¨åˆ†æ˜¯é€šç”¨çš„ctrlï¼ŒèŒƒå›´ä¸º10 ~ 18, å…¨éƒ¨è¿›å…¥int_ctrl_helper */ case ENGINE_CTRL_HAS_CTRL_FUNCTION: return ctrl_exists; case ENGINE_CTRL_GET_FIRST_CMD_TYPE: case ENGINE_CTRL_GET_NEXT_CMD_TYPE: case ENGINE_CTRL_GET_CMD_FROM_NAME: case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD: case ENGINE_CTRL_GET_NAME_FROM_CMD: case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD: case ENGINE_CTRL_GET_DESC_FROM_CMD: case ENGINE_CTRL_GET_CMD_FLAGS: /* * è¿™é‡Œdynamicçš„flagä¸ºENGINE_FLAGS_BY_ID_COPYï¼Œ0x0004 * ENGINE_FLAGS_MANUAL_CMD_CTRL = 0x0002ï¼Œä¸çš„ç»“æœä¸º0 */ if (ctrl_exists \u0026amp;\u0026amp; !(e-\u0026gt;flags \u0026amp; ENGINE_FLAGS_MANUAL_CMD_CTRL)) return int_ctrl_helper(e, cmd, i, p, f); if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); /* * For these cmd-related functions, failure is indicated by a -1 * return value (because 0 is used as a valid return in some * places). */ return -1; } default: break; } /* Anything else requires a ctrl() handler to exist. */ /* è¿™é‡Œæ˜¯ç¡®å®šå½“å‰engine-\u0026gt;ctrl != NULL */ if (!ctrl_exists) { ENGINEerr(ENGINE_F_ENGINE_CTRL, ENGINE_R_NO_CONTROL_FUNCTION); return 0; } /* è°ƒç”¨ä¸Šé¢çœ‹åˆ°çš„ dynamic-\u0026gt;ctrl = dynamic_ctrl, åé¢ä¼šè°ƒç”¨åˆ°è¿™æ¥ */ return e-\u0026gt;ctrl(e, cmd, i, p, f); } /* è¿™ä¸ªå‡½æ•°ä¹Ÿå°†åå¤è°ƒç”¨ï¼ˆåæ§½ä¸‹opensslè¿™é¬¼ä¹‹è®¾è®¡ï¼‰ï¼Œæˆ‘ä»¬è¿™é‡Œå…ˆçœ‹å½“å‰çš„cmd */ static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { int idx; char *s = (char *)p; const ENGINE_CMD_DEFN *cdp; ... /* Now handle cmd_name -\u0026gt; cmd_num conversion */ if (cmd == ENGINE_CTRL_GET_CMD_FROM_NAME) { /* ä»dynamicçš„cmd_defnsä¸­å»åŒ¹é…cmd_name,å‡è®¾æ˜¯\u0026#34;SO_PATH\u0026#34;, ç›´æ¥å»æŸ¥ç¬¬äºŒéƒ¨åˆ†çš„dynamic_cmd_defnsï¼Œåˆšå¥½åŒ¹é…ä¸Šidx = 0 */ if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_name(e-\u0026gt;cmd_defns, s)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NAME); return -1; } /* æŸ¥idx = 0æ—¶çš„ cmd_num = 200 = DYNAMIC_CMD_SO_PATH */ return e-\u0026gt;cmd_defns[idx].cmd_num; } ... }   å¯ä»¥çœ‹åˆ°è¿™é‡Œçš„numè¿”å›å›æ¥çš„DYNAMIC_CMD_SO_PATHï¼Œæ˜¯é dynamic.cmd_defnsä¸­çš„ENGINE_CMD_DEFNæ•°ç»„è¡¨æŸ¥è¯¢å¾—åˆ°çš„ã€‚å¾€ä¸‹æ¥ç€çœ‹ENGINE_ctrl_cmd_string\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { /* ç»§ç»­è°ƒç”¨å…¬ç”¨ctrlï¼Œè¿›å…¥åˆ°int_ctrl_helper (çœ‹åº•ä¸‹å¼€æºçš„æ³¨é‡Šï¼Œä¸¤ä¸ªå‡½æ•°åšçš„ctrlæ“ä½œä¸€æ ·çš„ï¼Œä¸ºå•¥è¿™ä¹ˆæä¹Ÿè®¸å°±æ˜¯æœªè§£ä¹‹è°œå§) */ ... if (!ENGINE_cmd_is_executable(e, num)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_CMD_NOT_EXECUTABLE); return 0; } /* é¡¾åæ€ä¹‰ï¼Œæ‹¿åˆ°dynamicçš„flagï¼Œè¿™é‡Œå°†å¾—åˆ°idx = 0æ—¶ï¼Œcmd_defnsè¡¨ä¸­0å¤„çš„ç¬¬å››ä¸ªå…ƒç´  */ flags = ENGINE_ctrl(e, ENGINE_CTRL_GET_CMD_FLAGS, num, NULL, NULL); if (flags \u0026lt; 0) { /* * Shouldn\u0026#39;t happen, given that ENGINE_cmd_is_executable() returned * success. */ ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } } static int int_ctrl_helper(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... if ((e-\u0026gt;cmd_defns == NULL) || ((idx = int_ctrl_cmd_by_num(e-\u0026gt;cmd_defns, (unsigned int)i)) \u0026lt; 0)) { ENGINEerr(ENGINE_F_INT_CTRL_HELPER, ENGINE_R_INVALID_CMD_NUMBER); return -1; } /* Now the logic splits depending on command type */ cdp = \u0026amp;e-\u0026gt;cmd_defns[idx]; switch (cmd) { ... case ENGINE_CTRL_GET_CMD_FLAGS: /* å¯ä»¥æŸ¥å‡ºæ¥ä¸Šé¢çš„æ˜¯ ENGINE_CMD_FLAG_STRING = 0x0002 */ return cdp-\u0026gt;cmd_flags; } ... }   åˆ«é—®ä¸ºå•¥ä¸ä¸€æ¬¡æŸ¥å‡ºæ¥ï¼Œè¦å¤šæ¬¡éå†ï¼Œé—®å°±æ˜¯æ¶æ„ã€‚ç»§ç»­çœ‹ENGINE_ctrl_cmd_stringï¼Œç»ˆäºè¦åšçœŸæ­£çš„æ“ä½œäº†ï¼Œ å¯ä»¥çœ‹åˆ°ï¼Œæœ€åè¿›å…¥äº†dynamic_ctrlï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62  int ENGINE_ctrl_cmd_string(ENGINE *e, const char *cmd_name, const char *arg, int cmd_optional) { ... /* ENGINE_CMD_FLAG_NO_INPUT = 0x0004 */ if (flags \u0026amp; ENGINE_CMD_FLAG_NO_INPUT) { /* å¦‚æœå‘½ä»¤æŸ¥å‡ºæ¥çš„flagåº”è¯¥æ²¡æœ‰arg_input, ä½†argéç©ºï¼Œç›´æ¥é€€å‡º???? */ if (arg != NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_NO_INPUT); return 0; } /* * We deliberately force the result of ENGINE_ctrl() to 0 or 1 rather * than returning it as \u0026#34;return data\u0026#34;. This is to ensure usage of * these commands is consistent across applications and that certain * applications don\u0026#39;t understand it one way, and others another. */ /* æœ€å\u0026#34;LOAD\u0026#34;å‘½ä»¤èµ°çš„è¿™ */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* So, we require input */ if (arg == NULL) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_COMMAND_TAKES_INPUT); return 0; } /* ä¸€å®šæœ‰æ›´å¥½çš„å†™æ³•å§ï¼Œè¿™ç§åˆ¤æ–­ä¹Ÿå¤ªè¿·æƒ‘äº†ã€‚ã€‚ */ /* If it takes string input, that\u0026#39;s easy */ if (flags \u0026amp; ENGINE_CMD_FLAG_STRING) { /* Same explanation as above */ /* æ‰€ä»¥åº”è¯¥è°ƒç”¨åˆ°è¿™ï¼Œæ³¨æ„æ­¤æ—¶num å°†å¤§äº200, è‚¯å®šä¸æ˜¯é»˜è®¤çš„æµç¨‹ï¼Œ è¿™å°±èµ°åˆ°äº†return e-\u0026gt;ctrl(e, cmd, i, p, f); å³ dynamic_ctrl */ if (ENGINE_ctrl(e, num, 0, (void *)arg, NULL) \u0026gt; 0) return 1; return 0; } /* æ­¤æ—¶argæ˜¯æ•°å­—ï¼Œéœ€è¦ä»strè½¬intï¼ŒLIST_ADDèµ°è¿™ */ if (!(flags \u0026amp; ENGINE_CMD_FLAG_NUMERIC)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_INTERNAL_LIST_ERROR); return 0; } l = strtol(arg, \u0026amp;ptr, 10); if ((arg == ptr) || (*ptr != \u0026#39;\\0\u0026#39;)) { ENGINEerr(ENGINE_F_ENGINE_CTRL_CMD_STRING, ENGINE_R_ARGUMENT_IS_NOT_A_NUMBER); return 0; } /* * Force the result of the control command to 0 or 1, for the reasons * mentioned before. */ if (ENGINE_ctrl(e, num, l, NULL, NULL) \u0026gt; 0) return 1; ... }   æ‰€ä»¥è¿™ä¸ªå‡½æ•°çš„ä¸»è¦æ­¥éª¤å°±æ˜¯æ ¹æ®è¾“å…¥çš„cmd_nameä»dynamicä¸­æŒ‚è½½çš„cmd_defnså–å‡ºå¯¹åº”çš„cmd_numå’Œflagï¼Œä¹‹åç”¨cmd_numè°ƒç”¨åˆ°dynamicæŒ‚è½½çš„ctrlå­—æ®µå‡½æ•°å»åšçœŸæ­£çš„æ“ä½œã€‚æˆ‘ä»¬ç”¨ä¸€å¼ è¡¨ç»Ÿè®¡ä¸‹ä¸‰æ¬¡å–åˆ°çš„ç»“æœï¼š\n   cmd_name cmd_num flag     \u0026ldquo;SO_PATH\u0026rdquo; DYNAMIC_CMD_SO_PATH = 200 ENGINE_CMD_FLAG_STRING 0x0002   \u0026ldquo;LIST_ADD\u0026rdquo; DYNAMIC_CMD_LIST_ADD = 203 ENGINE_CMD_FLAG_NUMERIC 0x0001   \u0026ldquo;LOAD\u0026rdquo; DYNAMIC_CMD_LOAD = 206 ENGINE_CMD_FLAG_NO_INPUT 0x0004    æ ¹æ®è¿™ä¸ªè¡¨ï¼Œæˆ‘ä»¬å»çœ‹å¯¹äºdynamic-\u0026gt;ctrlå³dynamic_ctrlå‡½æ•°å¯¹è¿™å‡ ä¸ªcmdçš„æ“ä½œ\ndynamic_ctrl å…ˆçœ‹è¿™ä¸ªå‡½æ•°çš„å…¬å…±éƒ¨åˆ†ï¼Œå¯¹ç›¸åŒçš„engineä¼šåˆå§‹åŒ–ä¸Šä¸€ä¸ªctxä¸Šä¸‹æ–‡ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156  /* åŠ¨æ€åº“åŠ è½½çš„ä¸Šä¸‹æ–‡ */ struct st_dynamic_data_ctx { /* The DSO object we load that supplies the ENGINE code */ DSO *dynamic_dso; /* * The function pointer to the version checking shared library function */ dynamic_v_check_fn v_check; /* * The function pointer to the engine-binding shared library function */ dynamic_bind_engine bind_engine; /* The default name/path for loading the shared library */ char *DYNAMIC_LIBNAME; /* Whether to continue loading on a version check failure */ int no_vcheck; /* If non-NULL, stipulates the \u0026#39;id\u0026#39; of the ENGINE to be loaded */ char *engine_id; /* * If non-zero, a successfully loaded ENGINE should be added to the * internal ENGINE list. If 2, the add must succeed or the entire load * should fail. */ int list_add_value; /* The symbol name for the version checking function */ const char *DYNAMIC_F1; /* The symbol name for the \u0026#34;initialise ENGINE structure\u0026#34; function */ const char *DYNAMIC_F2; /* * Whether to never use \u0026#39;dirs\u0026#39;, use \u0026#39;dirs\u0026#39; as a fallback, or only use * \u0026#39;dirs\u0026#39; for loading. Default is to use \u0026#39;dirs\u0026#39; as a fallback. */ int dir_load; /* A stack of directories from which ENGINEs could be loaded */ STACK_OF(OPENSSL_STRING) *dirs; }; static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { /* è¿™ä¸ªå‡½æ•°å°†ä¼šåˆå§‹åŒ–å¹¶ä¿å­˜åŠ¨æ€åº“æ•°æ®çš„ctxï¼Œè¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆå¯ä»¥åå¤è°ƒç”¨è¿™ä¸ªæ¥å£çš„åŸå›  */ dynamic_data_ctx *ctx = dynamic_get_data_ctx(e); int initialised; if (!ctx) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_NOT_LOADED); return 0; } /* å¯ä»¥çœ‹åˆ°ï¼ŒåŠ è½½å®Œæˆçš„æ ‡å¿—æ˜¯dynamic_dsoé’©å­å·²ç»æŒ‚ä¸Šäº† */ initialised = ((ctx-\u0026gt;dynamic_dso == NULL) ? 0 : 1); /* All our control commands require the ENGINE to be uninitialised */ if (initialised) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_ALREADY_LOADED); return 0; } /* cmdè§£æï¼Œåº•ä¸‹é€ä¸ªåˆ†æ */ ... } /* * This function retrieves the context structure from an ENGINE\u0026#39;s \u0026#34;ex_data\u0026#34;, * or if it doesn\u0026#39;t exist yet, sets it up. */ static dynamic_data_ctx *dynamic_get_data_ctx(ENGINE *e) { dynamic_data_ctx *ctx; if (dynamic_ex_data_idx \u0026lt; 0) { /* * Create and register the ENGINE ex_data, and associate our \u0026#34;free\u0026#34; * function with it to ensure any allocated contexts get freed when * an ENGINE goes underground. */ int new_idx = ENGINE_get_ex_new_index(0, NULL, NULL, NULL, dynamic_data_ctx_free_func); if (new_idx == -1) { ENGINEerr(ENGINE_F_DYNAMIC_GET_DATA_CTX, ENGINE_R_NO_INDEX); return NULL; } CRYPTO_THREAD_write_lock(global_engine_lock); /* Avoid a race by checking again inside this lock */ if (dynamic_ex_data_idx \u0026lt; 0) { /* Good, someone didn\u0026#39;t beat us to it */ dynamic_ex_data_idx = new_idx; new_idx = -1; } CRYPTO_THREAD_unlock(global_engine_lock); /* * In theory we could \u0026#34;give back\u0026#34; the index here if (new_idx\u0026gt;-1), but * it\u0026#39;s not possible and wouldn\u0026#39;t gain us much if it were. */ } ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx); /* Check if the context needs to be created */ if ((ctx == NULL) \u0026amp;\u0026amp; !dynamic_set_data_ctx(e, \u0026amp;ctx)) /* \u0026#34;set_data\u0026#34; will set errors if necessary */ return NULL; return ctx; } /* * ç®€å•çš„è¯´å°±æ˜¯å»æŸ¥æŒ‚åœ¨engine-\u0026gt;ex_dataï¼Œ * è¿™ä¸ªå°±æ˜¯åŠ¨æ€åº“åŠ è½½çš„ä¸Šä¸‹æ–‡ï¼Œex_dataæ˜¯ä¸ªæ ˆå¯èƒ½æœ‰å¤šä¸ªä¸Šä¸‹æ–‡ï¼Œ * æ ¹æ®ä¸€ä¸ªå…¨å±€å˜é‡dynamic_ex_data_idxç¡®å®šå½“å‰ä½¿ç”¨ä¸Šä¸‹æ–‡ * å½“ç„¶ç¬¬ä¸€æ¬¡è°ƒç”¨ctxæ˜¯ç©ºçš„ï¼Œæ‰€ä»¥éœ€è¦è°ƒç”¨ä¸€ä¸‹dynamic_set_data_ctxåˆå§‹åŒ– */ static int dynamic_set_data_ctx(ENGINE *e, dynamic_data_ctx **ctx) { /* ç”³è¯·ctxçš„mem */ dynamic_data_ctx *c = OPENSSL_zalloc(sizeof(*c)); int ret = 1; if (c == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); return 0; } c-\u0026gt;dirs = sk_OPENSSL_STRING_new_null(); if (c-\u0026gt;dirs == NULL) { ENGINEerr(ENGINE_F_DYNAMIC_SET_DATA_CTX, ERR_R_MALLOC_FAILURE); OPENSSL_free(c); return 0; } /* åˆå§‹åŒ–ä¸€äº›å­—æ®µï¼Œä¸‹é¢æ€»ç»“ */ c-\u0026gt;DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, ; c-\u0026gt;DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;; c-\u0026gt;dir_load = 1; CRYPTO_THREAD_write_lock(global_engine_lock); /* ç¬¬ä¸€æ¬¡è¿›æ¥ä¸ºNULL(ç„¶è€Œæ­£å¸¸æ˜¯ä¸ºctx = NULLæ‰ä¼šè°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œå¯èƒ½æ˜¯å†—ä½™æ ¡éªŒ)*/ if ((*ctx = (dynamic_data_ctx *)ENGINE_get_ex_data(e, dynamic_ex_data_idx)) == NULL) { /* Good, we\u0026#39;re the first */ /* æŠŠctxæŒ‚åœ¨engine-\u0026gt;ex_dataä¸Š */ ret = ENGINE_set_ex_data(e, dynamic_ex_data_idx, c); if (ret) { *ctx = c; c = NULL; } } CRYPTO_THREAD_unlock(global_engine_lock); /* * If we lost the race to set the context, c is non-NULL and *ctx is the * context of the thread that won. */ if (c) sk_OPENSSL_STRING_free(c-\u0026gt;dirs); OPENSSL_free(c); return ret; } /* * å¾—åˆ°æœ€åçš„ç»“æœ dynamic-\u0026gt;ex_data = ctx; * ctx = {.DYNAMIC_F1 = \u0026#34;v_check\u0026#34;, .DYNAMIC_F2 = \u0026#34;bind_engine\u0026#34;, c-\u0026gt;dir_load = 1} * æƒŠå¥‡çš„å‘ç°äº† bind_engine è™½ç„¶ä»–åªæ˜¯ä¸ªå­—ç¬¦ä¸²ï¼Œä½†æ˜¯æˆ‘ç›¸ä¿¡ä½ å·²ç»çŸ¥é“åŸå› äº† * ä»–éœ€è¦åœ¨åŠ¨æ€åº“ä¸­å»å¯»æ‰¾è¿™ä¸ªç¬¦å· */   ä¹‹åæˆ‘ä»¬é€ä¸€åˆ†æè¿™ä¸‰ä¸ªcmd\nDYNAMIC_CMD_SO_PATHå’ŒDYNAMIC_CMD_LIST_ADD 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { /* æ³¨æ„ï¼Œ på°±æ˜¯ctrlvalueï¼Œå³ä»confä¸­å–ä¸‹æ¥çš„å€¼ */ case DYNAMIC_CMD_SO_PATH: /* a NULL \u0026#39;p\u0026#39; or a string of zero-length is the same thing */ if (p \u0026amp;\u0026amp; (strlen((const char *)p) \u0026lt; 1)) p = NULL; OPENSSL_free(ctx-\u0026gt;DYNAMIC_LIBNAME); if (p) /* å¾ˆæ˜æ˜¾åªæ˜¯åšäº†ä¸ªç®€å•çš„å¤åˆ¶ï¼Œæ­¤æ—¶è·¯å¾„å·²ç»èµ‹å€¼ä¸Šäº† */ ctx-\u0026gt;DYNAMIC_LIBNAME = OPENSSL_strdup(p); else ctx-\u0026gt;DYNAMIC_LIBNAME = NULL; return (ctx-\u0026gt;DYNAMIC_LIBNAME ? 1 : 0); case DYNAMIC_CMD_LIST_ADD: if ((i \u0026lt; 0) || (i \u0026gt; 2)) { ENGINEerr(ENGINE_F_DYNAMIC_CTRL, ENGINE_R_INVALID_ARGUMENT); return 0; } /* å¾ˆç®€å•ï¼Œèµ‹å€¼è€Œå·² */ ctx-\u0026gt;list_add_value = (int)i; return 1; ... } }   è¿™ä¸¤ä¸ªéƒ½å¾ˆç®€å•ï¼Œæœ€åéš¾ç‚¹éƒ½ç»™äº†LOAD\nDYNAMIC_CMD_LOAD æœ€å…³é”®çš„å‡½æ•°ï¼Œå®Œæˆäº†å…¨éƒ¨çš„åŠ è½½ï¼Œè§£é‡Šéƒ½åœ¨æ³¨é‡Šé‡Œï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172  static int dynamic_ctrl(ENGINE *e, int cmd, long i, void *p, void (*f) (void)) { ... switch (cmd) { case DYNAMIC_CMD_LOAD: return dynamic_load(e, ctx); ... } } static int dynamic_load(ENGINE *e, dynamic_data_ctx *ctx) { ENGINE cpy; dynamic_fns fns; /* * å…ˆnewä¸€ä¸ªDSOç»“æ„ä½“ï¼ŒDSOè¿™ä¸€å¥—å‡½æ•°æ€ä¹ˆç©çš„è¿™é‡Œå…ˆä¸è®²äº†ï¼Œ * å¯ä»¥ç†è§£ä¸ºå†…éƒ¨ä¹Ÿæœ‰ä¸€ä¸ªåŠ è½½é’©å­ï¼Œæœ‰4ä¸ªæŒ‚è½½ç‚¹ï¼Œä¼°è®¡å†å±•å¼€è®²è¯»è€…ç–¯äº† */ if (ctx-\u0026gt;dynamic_dso == NULL) ctx-\u0026gt;dynamic_dso = DSO_new(); if (ctx-\u0026gt;dynamic_dso == NULL) return 0; /* æ­¤å¤„æ£€æŸ¥DYNAMIC_LIBNAMEä¸èƒ½ä¸ºç©ºï¼Œè¿™ä¸ªå°±æ˜¯dsoçš„åŠ è½½åœ°å€ */ if (!ctx-\u0026gt;DYNAMIC_LIBNAME) { if (!ctx-\u0026gt;engine_id) return 0; DSO_ctrl(ctx-\u0026gt;dynamic_dso, DSO_CTRL_SET_FLAGS, DSO_FLAG_NAME_TRANSLATION_EXT_ONLY, NULL); ctx-\u0026gt;DYNAMIC_LIBNAME = DSO_convert_filename(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;engine_id); } /* æ ¸å¿ƒåŠ è½½å‡½æ•°int_loadï¼Œçœ‹ä¸‹é¢åˆ†æ */ if (!int_load(ctx)) { ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_NOT_FOUND); DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; return 0; } /* We have to find a bind function otherwise it\u0026#39;ll always end badly */ /* * æ­¤æ—¶engineåŠ¨æ€åº“å·²ç»åŠ è½½å¦‚å†…å­˜ï¼Œç¬¦å·è¡¨ä¸å¯¹åº”åœ°å€ä¹Ÿå‡†å¤‡å®Œæˆ * æ‰€ä»¥è‚¯å®šæ˜¯éœ€è¦å»å¯»æ‰¾è¿™ä¸ªç»‘å®šengineå®ŒæˆåŠ è½½çš„å‡½æ•°äº†ï¼Œèƒœåˆ©çš„æ›™å…‰ * DSO_bind_funcä¼šåœ¨ç¬¦å·è¡¨ä¸­å»åŒ¹é…ç¬¬äºŒä¸ªå‚æ•°å­—ç¬¦ä¸²ï¼Œè¿™é‡Œå°±æ˜¯æˆ‘ä»¬è¦çš„\u0026#34;bind_engine\u0026#34; * å¹¶è¿”å›ä¸Šå®ƒçš„å‡½æ•°åœ°å€ï¼ŒæŒ‚è½½åœ¨ctx-\u0026gt;bind_engineä¸Š */ if (! (ctx-\u0026gt;bind_engine = (dynamic_bind_engine) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F2))) { ctx-\u0026gt;bind_engine = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_DSO_FAILURE); return 0; } /* Do we perform version checking? */ if (!ctx-\u0026gt;no_vcheck) { unsigned long vcheck_res = 0; /* * Now we try to find a version checking function and decide how to * cope with failure if/when it fails. */ ctx-\u0026gt;v_check = (dynamic_v_check_fn) DSO_bind_func(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_F1); if (ctx-\u0026gt;v_check) vcheck_res = ctx-\u0026gt;v_check(OSSL_DYNAMIC_VERSION); /* * We fail if the version checker veto\u0026#39;d the load *or* if it is * deferring to us (by returning its version) and we think it is too * old. */ if (vcheck_res \u0026lt; OSSL_DYNAMIC_OLDEST) { /* Fail */ ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_VERSION_INCOMPATIBILITY); return 0; } } /* * First binary copy the ENGINE structure so that we can roll back if the * hand-over fails */ memcpy(\u0026amp;cpy, e, sizeof(ENGINE)); /* * Provide the ERR, \u0026#34;ex_data\u0026#34;, memory, and locking callbacks so the * loaded library uses our state rather than its own. FIXME: As noted in * engine.h, much of this would be simplified if each area of code * provided its own \u0026#34;summary\u0026#34; structure of all related callbacks. It * would also increase opaqueness. */ fns.static_state = ENGINE_get_static_state(); CRYPTO_get_mem_functions(\u0026amp;fns.mem_fns.malloc_fn, \u0026amp;fns.mem_fns.realloc_fn, \u0026amp;fns.mem_fns.free_fn); /* * Now that we\u0026#39;ve loaded the dynamic engine, make sure no \u0026#34;dynamic\u0026#34; * ENGINE elements will show through. */ engine_set_all_null(e); /* Try to bind the ENGINE onto our own ENGINE structure */ /* !!!!Attension, ç»ˆäºè°ƒç”¨æˆåŠŸäº†ï¼Œæˆ‘ä»¬çš„engineXç»ˆäºè¢«è®¾ç½®å¥½äº†ï¼ */ if (!ctx-\u0026gt;bind_engine(e, ctx-\u0026gt;engine_id, \u0026amp;fns)) { ctx-\u0026gt;bind_engine = NULL; ctx-\u0026gt;v_check = NULL; DSO_free(ctx-\u0026gt;dynamic_dso); ctx-\u0026gt;dynamic_dso = NULL; ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_INIT_FAILED); /* Copy the original ENGINE structure back */ memcpy(e, \u0026amp;cpy, sizeof(ENGINE)); return 0; } /* Do we try to add this ENGINE to the internal list too? */ /* æŠŠè¿™ä¸ªengineçš„å‰¯æœ¬addè¿›ä¸Šé¢engineå…¨å±€é“¾è¡¨ï¼Œå¤§åŠŸå‘Šæˆï¼*/ if (ctx-\u0026gt;list_add_value \u0026gt; 0) { if (!ENGINE_add(e)) { /* Do we tolerate this or fail? */ if (ctx-\u0026gt;list_add_value \u0026gt; 1) { /* * Fail - NB: By this time, it\u0026#39;s too late to rollback, and * trying to do so allows the bind_engine() code to have * created leaks. We just have to fail where we are, after * the ENGINE has changed. */ ENGINEerr(ENGINE_F_DYNAMIC_LOAD, ENGINE_R_CONFLICTING_ENGINE_ID); return 0; } /* Tolerate */ ERR_clear_error(); } } return 1; } static int int_load(dynamic_data_ctx *ctx) { int num, loop; /* Unless told not to, try a direct load */ /* * DSO_loadå»æ‰“å¼€ctx-\u0026gt;DYNAMIC_LIBNAMEï¼ŒæŠŠegineå¯¹åº”çš„libåº“åŠ è½½è¿›å†…å­˜ * è§£æç¬¦å·è¡¨å’Œå¯¹åº”åœ°å€åˆ°ä¸Šé¢ç”³è¯·å¥½çš„ctx-\u0026gt;dynamic_dsoç»“æ„ä½“ä¸­ */ if ((ctx-\u0026gt;dir_load != 2) \u0026amp;\u0026amp; (DSO_load(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, NULL, 0)) != NULL) return 1; /* If we\u0026#39;re not allowed to use \u0026#39;dirs\u0026#39; or we have none, fail */ if (!ctx-\u0026gt;dir_load || (num = sk_OPENSSL_STRING_num(ctx-\u0026gt;dirs)) \u0026lt; 1) return 0; for (loop = 0; loop \u0026lt; num; loop++) { /* è¿˜æœ‰é“¾æ¥çš„dsoè¿™é‡Œä¼šå¤„ç†é€’å½’çš„å»åŠ è½½ï¼Œå¯¹åº”çš„éœ€è¦åœ¨ctx-\u0026gt;dirsä¸­ */ const char *s = sk_OPENSSL_STRING_value(ctx-\u0026gt;dirs, loop); char *merge = DSO_merge(ctx-\u0026gt;dynamic_dso, ctx-\u0026gt;DYNAMIC_LIBNAME, s); if (!merge) return 0; if (DSO_load(ctx-\u0026gt;dynamic_dso, merge, NULL, 0)) { /* Found what we\u0026#39;re looking for */ OPENSSL_free(merge); return 1; } OPENSSL_free(merge); } return 0; }   ç»ˆäºç»ˆäºç»ˆäºï¼Œæ‰¾åˆ°ç›®æ ‡äº†ï¼Œè¿™ä¸ªå«åš'dynamic'çš„engineå‰¯æœ¬å®Œæˆäº†å˜æˆengineXçš„èœ•å˜ã€‚\nåç»­ éš¾æ€ªè¿™ä¹ˆå¤šäººå–·OpenSSLçƒ‚ï¼Œè¿™å¤æ‚çš„æµç¨‹ï¼Œè¿™ä¸€ä¸ªåˆä¸€ä¸ªçš„é’©å­ã€‚ä¸è¿‡è¿™ä¸€ä¸²æºç è¯»ä¸‹æ¥çœ‹æ˜ç™½çš„æ—¶å€™è¿˜æ˜¯æœ‰ç¥æ¸…æ°”çˆ½çš„æ„Ÿè§‰ã€‚\næœ‰ç¼˜åé¢ä¼šåˆ†æå¯†ç ç®—æ³•å…·ä½“æŒ‚è½½ï¼Œå¦‚ENGINE_set_digestsã€‚\næˆ‘å¾ˆèœï¼Œæœ‰é”™è¯¯çš„åœ°æ–¹æ¬¢è¿æŒ‡æ­£\n","description":"OpenSSL Engineæ’ä»¶çš„åŠ è½½è¿‡ç¨‹æºç åˆ†æ","id":8,"section":"posts","tags":["OpenSSL"],"title":"OpenSSL EngineåŠ è½½","uri":"https://summersummer3.github.io/posts/openssl_engine/"},{"content":"æ¤­åœ†æ›²çº¿åŸºæœ¬å­¦ä¹  æ–‡ç« ï¼šhttps://andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/#elliptic-curves\nä¹¦ç±ï¼šå¯†ç å­¦åŸç†ä¸å®è·µ ç¬¬6ç« \næ¤­åœ†æ›²çº¿æ–¹ç¨‹ $$\n\\left\\lbrace (x, y) \\in \\mathbb{R}^2\\ |\\ y^2 = x^3 + ax + b,\\ 4 a^3 + 27 b^2 \\ne 0 \\right\\rbrace\\ \\cup\\ \\left\\lbrace 0 \\right\\rbrace\n$$\nç¾¤ä¸é˜¿è´å°”ç¾¤ â€‹\t$\\mathbb{G}$ æ˜¯ä¸€ä¸ª ç¾¤ (Group) å¦‚æœè¯¥é›†åˆä¸Šå®šä¹‰äº†ä¸€ç§è¿ç®— $ + $:\n å°é—­æ€§: $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ ,åˆ™ $a + b \\in \\mathbb{G}$ ; ç»“åˆå¾‹: $a \\in \\mathbb{G}, b \\in \\mathbb{G}, c \\in \\mathbb{G}$, $ (a + b) + c = a + (b +c)$ ; å­˜åœ¨å•ä½å…ƒ $0 \\in \\mathbb{G}$, ä½¿å¾— $a \\in \\mathbb{G}$ï¼Œ$a + 0 = 0 + a = a$; æ¯ä¸€ä¸ªå…ƒç´ å­˜åœ¨é€†å…ƒï¼šå¯¹äºé›†åˆå†…ä»»æ„å…ƒç´ $a, \\exists b \\in \\mathbb{G}$ æ»¡è¶³ $a + b = 0$ï¼Œè®°åš$a = -b$  å¦‚æœè¯¥ç¾¤è¿˜æ»¡è¶³:\näº¤æ¢å¾‹ï¼š $a \\in \\mathbb{G}, b \\in \\mathbb{G}$ï¼Œ $a + b = b + a$  åˆ™è¯¥ç¾¤è¢«ç§°ä¸ºé˜¿è´å°”ç¾¤.\næœ‰é™åŸŸ $\\mathbb{F}$ æ˜¯ä¸€ä¸ª åŸŸ(Field) å¦‚æœè¯¥é›†åˆä¸Šå®šä¹‰äº†ä¸¤ç§è¿ç®— $(\\cdot\\ ;+)$\n å°é—­æ€§: $a \\in \\mathbb{F}, b \\in \\mathbb{F}$ï¼Œåˆ™ $a + b \\in \\mathbb{G}; a \\cdot b \\in \\mathbb{G}$ ç»“åˆå¾‹: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$ï¼Œ$ (a + b) + c = a + (b +c);\\ (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$ å­˜åœ¨åŠ æ³•å•ä½å…ƒ $0 \\in \\mathbb{F}$ï¼Œä½¿å¾— $a \\in \\mathbb{F}$ï¼Œ$a + 0 = 0 + a = a$ å­˜åœ¨ä¹˜æ³•å•ä½å…ƒ $e \\in \\mathbb{F}$ï¼Œä½¿å¾— $a \\in \\mathbb{F}$ï¼Œ$a \\cdot e = e \\cdot a = a$ äº¤æ¢å¾‹ï¼š $a \\in \\mathbb{F}, b \\in \\mathbb{F}$ï¼Œ $a + b = b + a$ï¼Œ$a \\cdot b = b \\cdot a$ é€†å…ƒ: å¯¹äºé›†åˆå†…ä»»æ„å…ƒç´ $a, \\exists b \\in \\mathbb{F}; \\exists c \\in \\mathbb{F}$ æ»¡è¶³ $a + b = 0; a \\cdot c = e$ï¼Œ è®°åš$a = -b;\\ a = c^{-1}$ï¼Œ$0^{-1}$æ— æ„ä¹‰ åˆ†é…å¾‹: $a \\in \\mathbb{F}, b \\in \\mathbb{F}, c \\in \\mathbb{F}$ï¼›$a \\cdot (b + c) = a \\cdot b + a \\cdot c$  æ³¨æ„ï¼šåŠ æ³•é€†å…ƒå®šä¹‰å‡æ³•ï¼Œä¹˜æ³•é€†å…ƒå®šä¹‰é™¤æ³•\næœ‰é™åŸŸæŒ‡çš„æ˜¯å…ƒç´ æœ‰é™çš„åŸŸï¼Œå±äºè®¡ç®—æœºå’Œå¯†ç å­¦çš„åŸºæœ¬æ•°å­¦åŸç†ä¹‹ä¸€\nå…¸å‹çš„æœ‰é™åŸŸä¾‹å­ï¼š$\\mathbb{F}_p = {0, 1, \u0026hellip;, p-1}$, $p$ä¸ºè´¨æ•°ï¼Œ\nå®šä¹‰ (+)ï¼š$a + b \\mod p$\nå®šä¹‰ ($\\cdot$)ï¼š$a \\cdot b \\mod p$\nè®¡ç®— $a ^ {-1}$ : æ‹“å±•æ¬§å‡ é‡Œå¾—ç®—æ³•\næ¤­åœ†æ›²çº¿ä¸Šçš„ç¾¤  æ›²çº¿ä¸Šçš„ç‚¹çš„é›†åˆç»„æˆç¾¤ $x$æ— ç©·è¿œç‚¹ä¸ºå•ä½å…ƒ$0$ ç‚¹$P$ä¸å®ƒçš„é€†$Q$å…³äºç›´çº¿$x = 0$å¯¹ç§° åŠ æ³•å®šä¹‰ï¼š$P + Q + R = 0$ï¼Œå¦‚æœè¿™ä¸‰ç‚¹æ˜¯é0ç‚¹ï¼Œä¸”åœ¨åŒä¸€æ¡ç›´çº¿ä¸Š(å³ä¸€æ¡ç›´çº¿ä¸è¯¥æ›²çº¿ç›¸äº¤äºä¸‰ç‚¹ï¼Œæ— ç©·è¿œç‚¹ä¸º0) $=\u0026gt; P + Q = -R$  åŠ æ³•åŒæ ·éœ€è¦æ»¡è¶³ç»“åˆå¾‹.\nå‡ ä½•æ„ä¹‰ä¸Šçš„åŠ æ³• æœ€é‡è¦çš„æƒ…å†µ:\n å¦‚æœ $P=Q, P + Q$ï¼Œç‰©ç†æ„ä¹‰æ˜¯åˆ‡çº¿, ä¸æ›²çº¿äº¤äºå¦ä¸€ç‚¹$R$, æ»¡è¶³ï¼š$2P = -R$ å¦‚æœ$P, Q$ç›´çº¿çš„ç¬¬ä¸‰ç‚¹åˆšå¥½ä¸º$P\\ or\\ Q$ï¼Œåˆ™ä¹Ÿå°†åŒ…å«ä¸€æ¡åˆ‡çº¿ï¼Œè®¡ç®—ç›¸åŒ: $P + Q + P = 0\\ =\u0026gt; P + Q = -P$  ä»£æ•°æ„ä¹‰ä¸Šçš„åŠ æ³• ä¸åŒä¸¤ç‚¹ç›¸åŠ  $P(P_x, P_y), Q(Q_x, Q_y)ï¼ŒP\\ \\ne Q$, æ±‚ $T(T_x, T_y) = P + Q$\næ›²çº¿æ–¹ç¨‹ï¼š$y^2 = x^3 +ax + b$\n  è®¡ç®—æ–œç‡ $k = \\frac{P_y - Q_y}{P_x - Q_x}$\n  æ›²çº¿æ–¹ç¨‹è¿ç«‹ä¸Šç›´çº¿æ–¹ç¨‹ $y = kx + c$\n=\u0026gt; $ 0 = x^3 - k^2x^2 + (a - 2kc)x + b - c^2$\n  é“­è®°ä¸‰æ¬¡æ±‚æ ¹å…¬å¼ä¹‹ä¸‰æ ¹ä¹‹å’Œæ˜¯äºŒæ¬¡é¡¹ç³»æ•°çš„ç›¸åæ•°: $T_x = k^2 - P_x - Q_x$\n  ç”±äºæ–œç‡ $k = \\frac{T_y - P_y}{T_x - P_x}$ï¼Œ$T_y = k(T_x - P_x) + P_y$\n  ç›¸åŒä¸¤ç‚¹ç›¸åŠ  $P(P_x, P_y)$ï¼Œæ±‚ $T(T_x,T_y) = P + P = 2P$\nå’Œä¸Šé¢åŸºæœ¬ç›¸åŒï¼Œä½†è®¡ç®—ç›´çº¿æ–œç‡éœ€è¦æ ¹æ®åˆ‡çº¿è®¡ç®—\nå¯¹æ›²çº¿æ–¹ç¨‹ä¸¤è¾¹æ±‚éšå¾®åˆ†:\n$\\mathrm{d}(y^2) = \\mathrm{d}(x^3 +ax + b)$ =\u0026gt; $2y\\mathrm{d}y = (3x^2 + a)\\mathrm{d}x$\nå°†$P_x, P_y$å¸¦å…¥ï¼Œè·å¾—æ–œç‡:\n$k = \\frac{\\mathrm{d}y}{\\mathrm{d}x} = \\frac{3P_x^2 + a}{2P_y}$\næ‰€ä»¥ $T_x = k^2 - 2P_x$ï¼Œ$T_y = k(T_x - P_x) + P_y$\næ ‡é‡ç§¯ $P(P_x, P_y)$ï¼Œæ±‚ $nP = \\underbrace{P + P + P + \u0026hellip; + P}_{\\text{n times}}$ï¼Œ$n \u0026gt; 2$\n  å°† $n$ ç”¨äºŒè¿›åˆ¶è¡¨ç¤ºï¼›ä»¥151ä¸ºä¾‹å­ï¼Œ$151_{10} = 10010111_2 = 2^0 + 2^1 + 2^2 + 2^4 + 2^7$\n  $nP = P + 2P + 2^2P + 2^4P + 2^7P$\n  æ ¹æ®ä¸Šé¢ä¸¤é¡¹è®¡ç®—è§„åˆ™ï¼Œåˆ†åˆ«è®¡ç®—$P, 2Pï¼ŒP + 2P$\n  è®¡ç®—$2^2P = 4P = 2 \\cdot 2P$ï¼Œå¯¹$2P$åšç›¸åŒç‚¹ç›¸åŠ å³å¯\n  åŒç†è®¡ç®—$2^3P = 8P = 2 \\cdot 4P$ï¼Œ$2^4P = 16P = 2 \\cdot 8P$, ä¾æ¬¡ç±»æ¨ï¼Œæ¯è®¡ç®—åˆ°ä¸€ä¸ªäºŒè¿›åˆ¶ä¸­ä¸º$1$çš„é˜¶æ•°ï¼Œ å®Œæˆä¸€æ¬¡ä¸¤ç‚¹ç›¸åŠ å³å¯\n  æ›²çº¿ä¸Šçš„æœ‰é™åŸŸ å–å‡ ä½•æ›²çº¿ä¸Šçš„åæ ‡$(x, y)$ï¼Œ$x, y \\in \\mathbb{F}_p$, $p$ æ˜¯ä¸€ä¸ªè´¨æ•°ï¼Œå½¢æˆä¸€æ¡ç¦»æ•£æ›²çº¿ï¼š\n$$\n\\begin{array}{rcl}\n\\left\\lbrace(x, y) \\in (\\mathbb{F}_p)^2 \\right. \u0026amp; \\left. | \\right. \u0026amp; \\left. y^2 \\equiv x^3 + ax + b \\pmod{p}, \\right.\n\\left. 4a^3 + 27b^2 \\not\\equiv 0 \\pmod{p}\\right\\rbrace\\ \\cup\\ \\left\\lbrace0\\right\\rbrace\n\\end{array}\n$$\nä»è¿ç»­æ›²çº¿ä¸Šçš„åŠ æ³•å¯ä»¥æ¨å‡ºæœ‰é™åŸŸä¸Šçš„åŠ æ³•å…¬å¼ï¼š\n$P(P_x, P_y), Q(Q_x, Q_y)ï¼ŒP\\ \\ne Q$, æ±‚ $T(T_x, T_y) = P + Q$\n$$\n\\begin{array}{rcl}\nk \u0026amp; = \u0026amp;(P_y - Q_y)(P_x - Q_x)^{-1} \\bmod{p} \\\nT_x \u0026amp; = \u0026amp; (k^2 - P_x - Q_x) \\bmod{p} \\\nT_y \u0026amp; = \u0026amp; [P_y + k(T_x - P_x)] \\bmod{p} \\\n\\end{array}\n$$\nè‹¥$P\\ = Q$\n$$\nk = (3 P_x^2 + a)(2 P_y)^{-1} \\bmod{p}\n$$\næ›²çº¿ä¸Šçš„å¾ªç¯å­ç¾¤ å¾ªç¯å­ç¾¤çš„é˜¶ å¯¹äºç¦»æ•£æ›²çº¿ä¸Šçš„ä»»æ„ç‚¹$P$, å­˜åœ¨æœ€å°çš„ $n$ ä½¿å¾— $nP = 0$, æ­¤æ—¶ $n$ ç§°ä½œä»¥ $P$ ä¸ºåŸºç‚¹çš„å¾ªç¯å­ç¾¤çš„é˜¶\næ‰¾åŸºç‚¹çš„æ–¹æ³•  è®¡ç®—æ¤­åœ†æ›²çº¿çš„é˜¶$N$ (Schoof\u0026rsquo;s algorithm: https://en.wikipedia.org/wiki/Schoof%27s_algorithm) é€‰æ‹©ä¸€ä¸ªé˜¶ä¸º$n$çš„å­ç¾¤ã€‚nå¿…é¡»æ˜¯ç´ æ•°ä¸”å¿…é¡»æ˜¯$N$çš„å› å­ è®¡ç®—è¾…å› å­ $h = N/n$ åœ¨æ›²çº¿ä¸Šé€‰æ‹©ä¸€ä¸ªéšæœºçš„ç‚¹ $T$ è®¡ç®—$G = hT$ï¼Œç‚¹ä¹˜ å¦‚æœ$G = 0$, è¿”å›4ï¼Œ å¦åˆ™æ‰¾åˆ°åŸºç‚¹ $G$, å­ç¾¤çš„é˜¶ä¸º $n$, $h$ è¢«ç§°ä¸ºè¾…å› å­  åŸç†: æ ¹æ®æ‹‰æ ¼æœ—æ—¥å®šç†ï¼Œ$n$ æ•´é™¤ $N$ ä¸” $n$ ä¸ºè´¨å› å­ï¼Œä¸”ä»»æ„ç‚¹ $T$ æ»¡è¶³$NT = 0$ï¼Œ åˆ™ï¼š$n(hT) = 0$ æ’æˆç«‹, é‚£ä¹ˆè‹¥$hT\\ \\ne 0$ï¼Œåˆ™ $hT$ ä½œä¸ºåŸºç‚¹çš„é˜¶ä¸€å®šä¸º$n$. ($n$ ä¸€å®šæ˜¯ç´ æ•°, å¦åˆ™ä¸æˆç«‹)\næ›²çº¿ä¸Šçš„ç¦»æ•£å¯¹æ•°é—®é¢˜ å¯¹äºæ›²çº¿ä¸Šçš„åŸºç‚¹ $G$ï¼Œ å·²çŸ¥ $n$ è®¡ç®— $P = nG$ æ˜¯å®¹æ˜“çš„\nä½†æ˜¯å·²çŸ¥$P, G$, è®¡ç®— $n$ æ˜¯å¾ˆå›°éš¾çš„\nECDH \u0026amp; ECDSA ECDH  CAé€‰ç”¨å…±åŒæ›²çº¿ï¼Œå¹¶ä¸‹å‘ç›¸åŒåŸºç‚¹$G$ï¼Œå…¶é˜¶æ•°ä¸º $n$, åˆ™ç§é’¥çš„å–å€¼èŒƒå›´ä¸º$d \\in {1, \u0026hellip;, n - 1}$ Aliceéšæœºé€‰æ‹©ç§é’¥$d_A$ï¼Œè®¡ç®— Pubkey: $P_A = d_AG$, é€šè¿‡éå®‰å…¨ä¿¡é“ä¼ é€’ç»™Bob Bobéšæœºé€‰æ‹©ç§é’¥$d_B$ï¼Œè®¡ç®— Pubkey: $P_B = d_BG$ï¼Œé€šè¿‡éå®‰å…¨ä¿¡é“ä¼ é€’ç»™Alice Aliceå’ŒBobåˆ†åˆ«è®¡ç®—$S = d_AP_b = d_BP_A = d_Ad_BG$ï¼Œ å…±äº«ç§˜å¯†æˆåŠŸ  ç§˜å¯†å…±äº«æˆåŠŸåå¯ä»¥æ¯æ¬¡é€šä¿¡æ—¶æ˜æ–‡ä¼ é€’salt, æ¯æ¬¡é€šè¿‡ $key = KDF(salt + S)$ï¼Œå¾—åˆ°å…·ä½“é€šä¿¡å¯¹ç§°ç§˜é’¥ï¼ŒåŠ å¯†é€šè®¯(TLS/SSL)\né€šè¿‡æœåŠ¡å™¨åŠ¨æ€ç”Ÿæˆçš„ECDHä¸€èˆ¬ç§°ä½œECDHE\nECDSA å®šä¹‰ä¾ç„¶ç»§æ‰¿ä¸Šæ–‡ï¼Œ$n$ ä¸º $G$ ä½œä¸ºåŸºç‚¹çš„å­ç¾¤é˜¶æ•°\nå®šä¹‰ $bit(x)$ ä¸ºè¡¨ç¤º $x$ éœ€è¦çš„æ¯”ç‰¹æ•°ï¼›æ³¨æ„è®¡ç®—DSAæ—¶ï¼Œè‹¥æ‘˜è¦å€¼çš„æ¯”ç‰¹æ•° $bits(digest(plain_test)) \u0026gt; bits(n)$ï¼Œåˆ™éœ€è¦æˆªå–æ‘˜è¦å€¼çš„ä½ $bits(n)$ è¿›è¡Œç­¾å.\nç¬¦å·æ ‡è®° æˆªå–å‰n-bitså‡½æ•° ï¼š $trun_{bit(n)}(digest)$\næˆªå–åçš„æ‘˜è¦å€¼ï¼š$z = trun_{bit(n)}(digest(plain_test))$ï¼Œ$digest$ éœ€è¦é€‰æ‹©å®‰å…¨æ‘˜è¦ç®—æ³•ï¼šå†…éƒ¨è¦æ±‚SHA-256ä»¥ä¸Š\nç§é’¥ï¼š$d$\nå…¬é’¥ï¼š$P = dG$\nç­¾åç®—æ³•   éšæœºé€‰æ‹© $k \\in {1, \u0026hellip;, n -1 }$\n  è®¡ç®—$T = kG = (T_x, T_y)$\n  è®¡ç®—æ•°å­— $r = T_x \\mod n$ï¼Œ è‹¥$r = 0$åˆ™è¿”å›1\n  è®¡ç®—$s = k^{-1}(z + rd) \\mod n$, å¦‚æœ$s = 0$ï¼Œè¿”å›1\n  æœ€åç­¾åï¼š$(r, s)$\n  éªŒè¯ç®—æ³•  è®¡ç®— $u_1 = s^{-1}z \\mod n$ è®¡ç®— $u_2 = s^{-1}r \\mod n$ è®¡ç®— $T\u0026rsquo; = u_1G\\ +\\ u_2P$  è‹¥$T\u0026rsquo;_x = r \\mod n$ï¼ŒéªŒç­¾æˆåŠŸï¼Œå¦åˆ™å¤±è´¥\næ­£ç¡®æ€§ æˆ‘ä»¬å°è¯•è®¡ç®—çš„å…¶å®è¿˜æ˜¯$T = kG$ï¼Œè‹¥æ­¤æ—¶ $z$ æ˜¯æ­£ç¡®æ‘˜è¦å€¼ï¼Œåˆ™æœ‰:\n$k = s^{-1}(z + rd)\\ mod\\ n\\ =\u0026gt;\\ k = s^{-1}z + s^{-1}rd \\mod n$\nå¸¦å…¥ä¸Šå¼ $T = s^{-1}zG + s^{-1}rdG = u_1G + u_2(dG) = u1G + u_2P$\næ‰€ä»¥è‹¥ $z$ å‘ç”Ÿæ”¹å˜ï¼Œåˆ™æ­¤æ—¶è®¡ç®—å‡ºæ¥çš„ $T\u0026rsquo;_x\\ \\ne\\ r \\mod n$\néšæœºæ•°ç›¸ç­‰ä¸‹çš„ç§é’¥å¤åŸ è‹¥æ¯æ¬¡å–å‡ºçš„éšæœºæ•° $k$ éƒ½ç›¸ç­‰ï¼š\nè·å–ä¸¤ä»½ç­¾åä¸æ‘˜è¦ï¼š$z_1, (r_1, s_1)$ å’Œ $z_2, (r_2, s_2)$\nå®¹æ˜“å¾—åˆ°: $r_1 = r_2 = (kG)_x \\mod n$\nä¹‹åé€šè¿‡ $s_1 - s_2$ è®¡ç®— $k$ï¼š\n$s_1 - s_2 = k^{-1}(z_1 + rd - z_2 - rd) \\mod n$\n$=\u0026gt; k = (z_1 - z_2)(s_1 - s_2)^{-1} \\mod n$\nä¹‹åè®¡ç®— $d$ å°±å¾ˆç®€å•äº†:\n$ d = r^{-1}(s_1k - z_1) \\mod n$\né€šè¿‡ç­¾åæ¢å¤å…¬é’¥ è‹¥å·²çŸ¥æ›²çº¿ä¸Š $x = r$ å¯¹åº”çš„ä¸¤ç‚¹ $R, R\u0026rsquo;$ï¼Œåˆ™å¯ä»¥ä»ç­¾å$(s, r)$ä¸­æ¢å¤å…¬é’¥$P$:\n$s = k^{-1}(z + rd) \\mod n$\n$=\u0026gt; skG = (z + rd)G$\næ³¨æ„ $kG = R$ æˆ–è€… $kG = R\u0026rsquo;$, åˆ†åˆ«ä½œä¸ºå¤‡é€‰å¸¦å…¥ä¸Šå¼ï¼ŒåŒæ—¶$P = dG$:\n$=\u0026gt;\\ sR - zG = r(dG)\\ =\u0026gt; P = r^{-1}(sR - zG)$\nor $=\u0026gt;\\ P = r^{-1}(sR\u0026rsquo; - zG)$\nå®ç°æ–¹æ³• ç‚¹å‹ç¼©ï¼šå¢åŠ 2bitæ¥æ ‡è¯†ï¼Œä¸€ä¸ªç”¨æ¥æ ‡è¯† $R_x = r\\mod n$ æˆ–è€… $R_x = r$ï¼Œå¦ä¸€ä¸ªæ ‡è¯†$R_y$æ˜¯åŸºæ•°è¿˜æ˜¯å¶æ•°ï¼š\nå› ä¸º$R, R\u0026rsquo;$å…³äº $x$ è½´å¯¹ç§°ï¼Œ$R_y + R\u0026rsquo;_y = 0 \\mod p$ï¼Œ æ‰€ä»¥$R_y ,P\u0026rsquo;_y$ä¸ºä¸€åŸºä¸€å¶ï¼Œå¯ç”¨ä¸€ä¸ªbitæ ‡è¯†\nè¿™æ ·å¯ä»¥è¾¾åˆ°å¤šç”¨å¢åŠ ä¸€ä¸ªbyte(04æ ‡è®°ç­‰)ï¼Œæ¥è¾¾æˆæ— éœ€ä¼ é€’å…¬é’¥å³å¯éªŒç­¾\nç›¸å…³ç®—æ³•ä¸ä»£ç ï¼šhttps://busy.org/@oflyhigh/397bw1\nä¼ªé€ ç­¾å æ„é€ eæ–¹æ³•  éšæœºé€‰æ‹© $a, b \\in {1, \u0026hellip; n}$, è®¡ç®—$T = aG + bP, r = T_x$ è®¡ç®— $s = rb^{-1}, e = arb^{-1}$ è‹¥$e$ ä¸ºä¼ªé€ æ‘˜è¦å€¼, å¯ä¼ªé€ åˆæ³•ç­¾å $(r, s)$  æ­£ç¡®æ€§:\n$u_1 = s^{-1}e \\mod \\ n$\n$u_2 = s^{-1}r \\mod\\ n$\nå°†$s, e$å¸¦å…¥\n$u_1G + u_2P = (rb^{-1})^{-1}(arb^{-1})G + (rb^{-1})^{-1}rP = (rr^{-1})(bb^{-1})aG + (rr^{-1})bP = aG + bP = T$\nç”±äº$r = T_x \\mod n$ï¼Œæ ¡éªŒé€šè¿‡\nç›¸å…³ç®—æ³•ä¸ä»£ç ï¼šhttps://github.com/GoldSaintEagle/ECDSA-SM2-Signing-Attack\nSM2ç­¾å æ ‡è®°ä¸å˜ï¼Œ$z = SM3(message)$ æ˜¯æ¶ˆæ¯çš„æ‘˜è¦å€¼ï¼ˆå›½å¯†è¦æ±‚æ‘˜è¦ä½¿ç”¨SM3ï¼‰ï¼Œ$d$ æ˜¯ç§é’¥ï¼Œ $P = dG$æ˜¯å…¬é’¥\nç­¾åç®—æ³•   éšæœºé€‰æ‹© $k \\in {1, \u0026hellip;, n -1 }$\n  è®¡ç®—$T = kG = (T_x, T_y)$\n  è®¡ç®—æ•°å­— $r = T_x + z \\mod n$ï¼Œ è‹¥$r = 0$åˆ™è¿”å›1\n  è®¡ç®—$s = (1 + d)^{-1}(k - rd) \\mod n$, å¦‚æœ$s = 0$ï¼Œè¿”å›1\n  æœ€åç­¾åï¼š$(r, s)$\n  éªŒè¯ç®—æ³•  è®¡ç®—æ¶ˆæ¯å€¼æ‘˜è¦$z\u0026rsquo; = SM3(message)$ è®¡ç®—$T\u0026rsquo; = sG + (r + s)P$ åˆ¤æ–­$r\\ ?= T\u0026rsquo;_x + z \\mod n$  æ­£ç¡®æ€§ é¦–å…ˆè®¡ç®— $k$ :\n$s = (1 + d)^{-1}(k - rd) \\mod n$\n=\u0026gt; $s(1 + d) + rd = k \\mod n$ =\u0026gt; $s + (s + r)d = k \\mod n$\næ‰€ä»¥ ï¼š\n$T = kG = sG + (s + r)(dG) = sG + (s + r)P = T'$\nå› æ­¤å¯ä»¥æ¨å¯¼ï¼š\n$r = (T_x + z) = (T\u0026rsquo;_x + z) \\mod n$\næ‰€ä»¥å¦‚æœ$r = T\u0026rsquo;_x + z\u0026rsquo; \\mod n$ï¼Œ åˆ™ $z\u0026rsquo;$ éªŒç­¾é€šè¿‡ï¼Œå¦åˆ™ $z\u0026rsquo;$ æ‘˜è¦æœ‰è¯¯\n","description":"æ¤­åœ†æ›²çº¿ç®—æ³•å…¥é—¨åŠECDSAä¸SM2ç®—æ³•è¯¦è§£","id":9,"section":"posts","tags":["å¯†ç å­¦"],"title":"ECDSAä¸SM2","uri":"https://summersummer3.github.io/posts/ecdsa%E4%B8%8Esm2/"}]